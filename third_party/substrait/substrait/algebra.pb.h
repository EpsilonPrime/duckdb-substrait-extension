// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: substrait/algebra.proto

#ifndef PROTOBUF_INCLUDED_substrait_2falgebra_2eproto
#define PROTOBUF_INCLUDED_substrait_2falgebra_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
#include "substrait/extensions/extensions.pb.h"
#include "substrait/type.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_substrait_2falgebra_2eproto 

namespace protobuf_substrait_2falgebra_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[108];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_substrait_2falgebra_2eproto
namespace substrait {
class AggregateFunction;
class AggregateFunctionDefaultTypeInternal;
extern AggregateFunctionDefaultTypeInternal _AggregateFunction_default_instance_;
class AggregateFunction_ReferenceRel;
class AggregateFunction_ReferenceRelDefaultTypeInternal;
extern AggregateFunction_ReferenceRelDefaultTypeInternal _AggregateFunction_ReferenceRel_default_instance_;
class AggregateRel;
class AggregateRelDefaultTypeInternal;
extern AggregateRelDefaultTypeInternal _AggregateRel_default_instance_;
class AggregateRel_Grouping;
class AggregateRel_GroupingDefaultTypeInternal;
extern AggregateRel_GroupingDefaultTypeInternal _AggregateRel_Grouping_default_instance_;
class AggregateRel_Measure;
class AggregateRel_MeasureDefaultTypeInternal;
extern AggregateRel_MeasureDefaultTypeInternal _AggregateRel_Measure_default_instance_;
class CrossRel;
class CrossRelDefaultTypeInternal;
extern CrossRelDefaultTypeInternal _CrossRel_default_instance_;
class DdlRel;
class DdlRelDefaultTypeInternal;
extern DdlRelDefaultTypeInternal _DdlRel_default_instance_;
class ExchangeRel;
class ExchangeRelDefaultTypeInternal;
extern ExchangeRelDefaultTypeInternal _ExchangeRel_default_instance_;
class ExchangeRel_Broadcast;
class ExchangeRel_BroadcastDefaultTypeInternal;
extern ExchangeRel_BroadcastDefaultTypeInternal _ExchangeRel_Broadcast_default_instance_;
class ExchangeRel_ExchangeTarget;
class ExchangeRel_ExchangeTargetDefaultTypeInternal;
extern ExchangeRel_ExchangeTargetDefaultTypeInternal _ExchangeRel_ExchangeTarget_default_instance_;
class ExchangeRel_MultiBucketExpression;
class ExchangeRel_MultiBucketExpressionDefaultTypeInternal;
extern ExchangeRel_MultiBucketExpressionDefaultTypeInternal _ExchangeRel_MultiBucketExpression_default_instance_;
class ExchangeRel_RoundRobin;
class ExchangeRel_RoundRobinDefaultTypeInternal;
extern ExchangeRel_RoundRobinDefaultTypeInternal _ExchangeRel_RoundRobin_default_instance_;
class ExchangeRel_ScatterFields;
class ExchangeRel_ScatterFieldsDefaultTypeInternal;
extern ExchangeRel_ScatterFieldsDefaultTypeInternal _ExchangeRel_ScatterFields_default_instance_;
class ExchangeRel_SingleBucketExpression;
class ExchangeRel_SingleBucketExpressionDefaultTypeInternal;
extern ExchangeRel_SingleBucketExpressionDefaultTypeInternal _ExchangeRel_SingleBucketExpression_default_instance_;
class Expression;
class ExpressionDefaultTypeInternal;
extern ExpressionDefaultTypeInternal _Expression_default_instance_;
class Expression_Cast;
class Expression_CastDefaultTypeInternal;
extern Expression_CastDefaultTypeInternal _Expression_Cast_default_instance_;
class Expression_EmbeddedFunction;
class Expression_EmbeddedFunctionDefaultTypeInternal;
extern Expression_EmbeddedFunctionDefaultTypeInternal _Expression_EmbeddedFunction_default_instance_;
class Expression_EmbeddedFunction_PythonPickleFunction;
class Expression_EmbeddedFunction_PythonPickleFunctionDefaultTypeInternal;
extern Expression_EmbeddedFunction_PythonPickleFunctionDefaultTypeInternal _Expression_EmbeddedFunction_PythonPickleFunction_default_instance_;
class Expression_EmbeddedFunction_WebAssemblyFunction;
class Expression_EmbeddedFunction_WebAssemblyFunctionDefaultTypeInternal;
extern Expression_EmbeddedFunction_WebAssemblyFunctionDefaultTypeInternal _Expression_EmbeddedFunction_WebAssemblyFunction_default_instance_;
class Expression_Enum;
class Expression_EnumDefaultTypeInternal;
extern Expression_EnumDefaultTypeInternal _Expression_Enum_default_instance_;
class Expression_Enum_Empty;
class Expression_Enum_EmptyDefaultTypeInternal;
extern Expression_Enum_EmptyDefaultTypeInternal _Expression_Enum_Empty_default_instance_;
class Expression_FieldReference;
class Expression_FieldReferenceDefaultTypeInternal;
extern Expression_FieldReferenceDefaultTypeInternal _Expression_FieldReference_default_instance_;
class Expression_FieldReference_OuterReference;
class Expression_FieldReference_OuterReferenceDefaultTypeInternal;
extern Expression_FieldReference_OuterReferenceDefaultTypeInternal _Expression_FieldReference_OuterReference_default_instance_;
class Expression_FieldReference_RootReference;
class Expression_FieldReference_RootReferenceDefaultTypeInternal;
extern Expression_FieldReference_RootReferenceDefaultTypeInternal _Expression_FieldReference_RootReference_default_instance_;
class Expression_IfThen;
class Expression_IfThenDefaultTypeInternal;
extern Expression_IfThenDefaultTypeInternal _Expression_IfThen_default_instance_;
class Expression_IfThen_IfClause;
class Expression_IfThen_IfClauseDefaultTypeInternal;
extern Expression_IfThen_IfClauseDefaultTypeInternal _Expression_IfThen_IfClause_default_instance_;
class Expression_Literal;
class Expression_LiteralDefaultTypeInternal;
extern Expression_LiteralDefaultTypeInternal _Expression_Literal_default_instance_;
class Expression_Literal_Decimal;
class Expression_Literal_DecimalDefaultTypeInternal;
extern Expression_Literal_DecimalDefaultTypeInternal _Expression_Literal_Decimal_default_instance_;
class Expression_Literal_IntervalDayToSecond;
class Expression_Literal_IntervalDayToSecondDefaultTypeInternal;
extern Expression_Literal_IntervalDayToSecondDefaultTypeInternal _Expression_Literal_IntervalDayToSecond_default_instance_;
class Expression_Literal_IntervalYearToMonth;
class Expression_Literal_IntervalYearToMonthDefaultTypeInternal;
extern Expression_Literal_IntervalYearToMonthDefaultTypeInternal _Expression_Literal_IntervalYearToMonth_default_instance_;
class Expression_Literal_List;
class Expression_Literal_ListDefaultTypeInternal;
extern Expression_Literal_ListDefaultTypeInternal _Expression_Literal_List_default_instance_;
class Expression_Literal_Map;
class Expression_Literal_MapDefaultTypeInternal;
extern Expression_Literal_MapDefaultTypeInternal _Expression_Literal_Map_default_instance_;
class Expression_Literal_Map_KeyValue;
class Expression_Literal_Map_KeyValueDefaultTypeInternal;
extern Expression_Literal_Map_KeyValueDefaultTypeInternal _Expression_Literal_Map_KeyValue_default_instance_;
class Expression_Literal_Struct;
class Expression_Literal_StructDefaultTypeInternal;
extern Expression_Literal_StructDefaultTypeInternal _Expression_Literal_Struct_default_instance_;
class Expression_Literal_UserDefined;
class Expression_Literal_UserDefinedDefaultTypeInternal;
extern Expression_Literal_UserDefinedDefaultTypeInternal _Expression_Literal_UserDefined_default_instance_;
class Expression_Literal_VarChar;
class Expression_Literal_VarCharDefaultTypeInternal;
extern Expression_Literal_VarCharDefaultTypeInternal _Expression_Literal_VarChar_default_instance_;
class Expression_MaskExpression;
class Expression_MaskExpressionDefaultTypeInternal;
extern Expression_MaskExpressionDefaultTypeInternal _Expression_MaskExpression_default_instance_;
class Expression_MaskExpression_ListSelect;
class Expression_MaskExpression_ListSelectDefaultTypeInternal;
extern Expression_MaskExpression_ListSelectDefaultTypeInternal _Expression_MaskExpression_ListSelect_default_instance_;
class Expression_MaskExpression_ListSelect_ListSelectItem;
class Expression_MaskExpression_ListSelect_ListSelectItemDefaultTypeInternal;
extern Expression_MaskExpression_ListSelect_ListSelectItemDefaultTypeInternal _Expression_MaskExpression_ListSelect_ListSelectItem_default_instance_;
class Expression_MaskExpression_ListSelect_ListSelectItem_ListElement;
class Expression_MaskExpression_ListSelect_ListSelectItem_ListElementDefaultTypeInternal;
extern Expression_MaskExpression_ListSelect_ListSelectItem_ListElementDefaultTypeInternal _Expression_MaskExpression_ListSelect_ListSelectItem_ListElement_default_instance_;
class Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice;
class Expression_MaskExpression_ListSelect_ListSelectItem_ListSliceDefaultTypeInternal;
extern Expression_MaskExpression_ListSelect_ListSelectItem_ListSliceDefaultTypeInternal _Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice_default_instance_;
class Expression_MaskExpression_MapSelect;
class Expression_MaskExpression_MapSelectDefaultTypeInternal;
extern Expression_MaskExpression_MapSelectDefaultTypeInternal _Expression_MaskExpression_MapSelect_default_instance_;
class Expression_MaskExpression_MapSelect_MapKey;
class Expression_MaskExpression_MapSelect_MapKeyDefaultTypeInternal;
extern Expression_MaskExpression_MapSelect_MapKeyDefaultTypeInternal _Expression_MaskExpression_MapSelect_MapKey_default_instance_;
class Expression_MaskExpression_MapSelect_MapKeyExpression;
class Expression_MaskExpression_MapSelect_MapKeyExpressionDefaultTypeInternal;
extern Expression_MaskExpression_MapSelect_MapKeyExpressionDefaultTypeInternal _Expression_MaskExpression_MapSelect_MapKeyExpression_default_instance_;
class Expression_MaskExpression_Select;
class Expression_MaskExpression_SelectDefaultTypeInternal;
extern Expression_MaskExpression_SelectDefaultTypeInternal _Expression_MaskExpression_Select_default_instance_;
class Expression_MaskExpression_StructItem;
class Expression_MaskExpression_StructItemDefaultTypeInternal;
extern Expression_MaskExpression_StructItemDefaultTypeInternal _Expression_MaskExpression_StructItem_default_instance_;
class Expression_MaskExpression_StructSelect;
class Expression_MaskExpression_StructSelectDefaultTypeInternal;
extern Expression_MaskExpression_StructSelectDefaultTypeInternal _Expression_MaskExpression_StructSelect_default_instance_;
class Expression_MultiOrList;
class Expression_MultiOrListDefaultTypeInternal;
extern Expression_MultiOrListDefaultTypeInternal _Expression_MultiOrList_default_instance_;
class Expression_MultiOrList_Record;
class Expression_MultiOrList_RecordDefaultTypeInternal;
extern Expression_MultiOrList_RecordDefaultTypeInternal _Expression_MultiOrList_Record_default_instance_;
class Expression_Nested;
class Expression_NestedDefaultTypeInternal;
extern Expression_NestedDefaultTypeInternal _Expression_Nested_default_instance_;
class Expression_Nested_List;
class Expression_Nested_ListDefaultTypeInternal;
extern Expression_Nested_ListDefaultTypeInternal _Expression_Nested_List_default_instance_;
class Expression_Nested_Map;
class Expression_Nested_MapDefaultTypeInternal;
extern Expression_Nested_MapDefaultTypeInternal _Expression_Nested_Map_default_instance_;
class Expression_Nested_Map_KeyValue;
class Expression_Nested_Map_KeyValueDefaultTypeInternal;
extern Expression_Nested_Map_KeyValueDefaultTypeInternal _Expression_Nested_Map_KeyValue_default_instance_;
class Expression_Nested_Struct;
class Expression_Nested_StructDefaultTypeInternal;
extern Expression_Nested_StructDefaultTypeInternal _Expression_Nested_Struct_default_instance_;
class Expression_ReferenceSegment;
class Expression_ReferenceSegmentDefaultTypeInternal;
extern Expression_ReferenceSegmentDefaultTypeInternal _Expression_ReferenceSegment_default_instance_;
class Expression_ReferenceSegment_ListElement;
class Expression_ReferenceSegment_ListElementDefaultTypeInternal;
extern Expression_ReferenceSegment_ListElementDefaultTypeInternal _Expression_ReferenceSegment_ListElement_default_instance_;
class Expression_ReferenceSegment_MapKey;
class Expression_ReferenceSegment_MapKeyDefaultTypeInternal;
extern Expression_ReferenceSegment_MapKeyDefaultTypeInternal _Expression_ReferenceSegment_MapKey_default_instance_;
class Expression_ReferenceSegment_StructField;
class Expression_ReferenceSegment_StructFieldDefaultTypeInternal;
extern Expression_ReferenceSegment_StructFieldDefaultTypeInternal _Expression_ReferenceSegment_StructField_default_instance_;
class Expression_ScalarFunction;
class Expression_ScalarFunctionDefaultTypeInternal;
extern Expression_ScalarFunctionDefaultTypeInternal _Expression_ScalarFunction_default_instance_;
class Expression_SingularOrList;
class Expression_SingularOrListDefaultTypeInternal;
extern Expression_SingularOrListDefaultTypeInternal _Expression_SingularOrList_default_instance_;
class Expression_Subquery;
class Expression_SubqueryDefaultTypeInternal;
extern Expression_SubqueryDefaultTypeInternal _Expression_Subquery_default_instance_;
class Expression_Subquery_InPredicate;
class Expression_Subquery_InPredicateDefaultTypeInternal;
extern Expression_Subquery_InPredicateDefaultTypeInternal _Expression_Subquery_InPredicate_default_instance_;
class Expression_Subquery_Scalar;
class Expression_Subquery_ScalarDefaultTypeInternal;
extern Expression_Subquery_ScalarDefaultTypeInternal _Expression_Subquery_Scalar_default_instance_;
class Expression_Subquery_SetComparison;
class Expression_Subquery_SetComparisonDefaultTypeInternal;
extern Expression_Subquery_SetComparisonDefaultTypeInternal _Expression_Subquery_SetComparison_default_instance_;
class Expression_Subquery_SetPredicate;
class Expression_Subquery_SetPredicateDefaultTypeInternal;
extern Expression_Subquery_SetPredicateDefaultTypeInternal _Expression_Subquery_SetPredicate_default_instance_;
class Expression_SwitchExpression;
class Expression_SwitchExpressionDefaultTypeInternal;
extern Expression_SwitchExpressionDefaultTypeInternal _Expression_SwitchExpression_default_instance_;
class Expression_SwitchExpression_IfValue;
class Expression_SwitchExpression_IfValueDefaultTypeInternal;
extern Expression_SwitchExpression_IfValueDefaultTypeInternal _Expression_SwitchExpression_IfValue_default_instance_;
class Expression_WindowFunction;
class Expression_WindowFunctionDefaultTypeInternal;
extern Expression_WindowFunctionDefaultTypeInternal _Expression_WindowFunction_default_instance_;
class Expression_WindowFunction_Bound;
class Expression_WindowFunction_BoundDefaultTypeInternal;
extern Expression_WindowFunction_BoundDefaultTypeInternal _Expression_WindowFunction_Bound_default_instance_;
class Expression_WindowFunction_Bound_CurrentRow;
class Expression_WindowFunction_Bound_CurrentRowDefaultTypeInternal;
extern Expression_WindowFunction_Bound_CurrentRowDefaultTypeInternal _Expression_WindowFunction_Bound_CurrentRow_default_instance_;
class Expression_WindowFunction_Bound_Following;
class Expression_WindowFunction_Bound_FollowingDefaultTypeInternal;
extern Expression_WindowFunction_Bound_FollowingDefaultTypeInternal _Expression_WindowFunction_Bound_Following_default_instance_;
class Expression_WindowFunction_Bound_Preceding;
class Expression_WindowFunction_Bound_PrecedingDefaultTypeInternal;
extern Expression_WindowFunction_Bound_PrecedingDefaultTypeInternal _Expression_WindowFunction_Bound_Preceding_default_instance_;
class Expression_WindowFunction_Bound_Unbounded;
class Expression_WindowFunction_Bound_UnboundedDefaultTypeInternal;
extern Expression_WindowFunction_Bound_UnboundedDefaultTypeInternal _Expression_WindowFunction_Bound_Unbounded_default_instance_;
class ExtensionLeafRel;
class ExtensionLeafRelDefaultTypeInternal;
extern ExtensionLeafRelDefaultTypeInternal _ExtensionLeafRel_default_instance_;
class ExtensionMultiRel;
class ExtensionMultiRelDefaultTypeInternal;
extern ExtensionMultiRelDefaultTypeInternal _ExtensionMultiRel_default_instance_;
class ExtensionObject;
class ExtensionObjectDefaultTypeInternal;
extern ExtensionObjectDefaultTypeInternal _ExtensionObject_default_instance_;
class ExtensionSingleRel;
class ExtensionSingleRelDefaultTypeInternal;
extern ExtensionSingleRelDefaultTypeInternal _ExtensionSingleRel_default_instance_;
class FetchRel;
class FetchRelDefaultTypeInternal;
extern FetchRelDefaultTypeInternal _FetchRel_default_instance_;
class FilterRel;
class FilterRelDefaultTypeInternal;
extern FilterRelDefaultTypeInternal _FilterRel_default_instance_;
class FunctionArgument;
class FunctionArgumentDefaultTypeInternal;
extern FunctionArgumentDefaultTypeInternal _FunctionArgument_default_instance_;
class FunctionOption;
class FunctionOptionDefaultTypeInternal;
extern FunctionOptionDefaultTypeInternal _FunctionOption_default_instance_;
class HashJoinRel;
class HashJoinRelDefaultTypeInternal;
extern HashJoinRelDefaultTypeInternal _HashJoinRel_default_instance_;
class JoinRel;
class JoinRelDefaultTypeInternal;
extern JoinRelDefaultTypeInternal _JoinRel_default_instance_;
class MergeJoinRel;
class MergeJoinRelDefaultTypeInternal;
extern MergeJoinRelDefaultTypeInternal _MergeJoinRel_default_instance_;
class NamedObjectWrite;
class NamedObjectWriteDefaultTypeInternal;
extern NamedObjectWriteDefaultTypeInternal _NamedObjectWrite_default_instance_;
class ProjectRel;
class ProjectRelDefaultTypeInternal;
extern ProjectRelDefaultTypeInternal _ProjectRel_default_instance_;
class ReadRel;
class ReadRelDefaultTypeInternal;
extern ReadRelDefaultTypeInternal _ReadRel_default_instance_;
class ReadRel_ExtensionTable;
class ReadRel_ExtensionTableDefaultTypeInternal;
extern ReadRel_ExtensionTableDefaultTypeInternal _ReadRel_ExtensionTable_default_instance_;
class ReadRel_LocalFiles;
class ReadRel_LocalFilesDefaultTypeInternal;
extern ReadRel_LocalFilesDefaultTypeInternal _ReadRel_LocalFiles_default_instance_;
class ReadRel_LocalFiles_FileOrFiles;
class ReadRel_LocalFiles_FileOrFilesDefaultTypeInternal;
extern ReadRel_LocalFiles_FileOrFilesDefaultTypeInternal _ReadRel_LocalFiles_FileOrFiles_default_instance_;
class ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions;
class ReadRel_LocalFiles_FileOrFiles_ArrowReadOptionsDefaultTypeInternal;
extern ReadRel_LocalFiles_FileOrFiles_ArrowReadOptionsDefaultTypeInternal _ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions_default_instance_;
class ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions;
class ReadRel_LocalFiles_FileOrFiles_DwrfReadOptionsDefaultTypeInternal;
extern ReadRel_LocalFiles_FileOrFiles_DwrfReadOptionsDefaultTypeInternal _ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions_default_instance_;
class ReadRel_LocalFiles_FileOrFiles_OrcReadOptions;
class ReadRel_LocalFiles_FileOrFiles_OrcReadOptionsDefaultTypeInternal;
extern ReadRel_LocalFiles_FileOrFiles_OrcReadOptionsDefaultTypeInternal _ReadRel_LocalFiles_FileOrFiles_OrcReadOptions_default_instance_;
class ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions;
class ReadRel_LocalFiles_FileOrFiles_ParquetReadOptionsDefaultTypeInternal;
extern ReadRel_LocalFiles_FileOrFiles_ParquetReadOptionsDefaultTypeInternal _ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions_default_instance_;
class ReadRel_NamedTable;
class ReadRel_NamedTableDefaultTypeInternal;
extern ReadRel_NamedTableDefaultTypeInternal _ReadRel_NamedTable_default_instance_;
class ReadRel_VirtualTable;
class ReadRel_VirtualTableDefaultTypeInternal;
extern ReadRel_VirtualTableDefaultTypeInternal _ReadRel_VirtualTable_default_instance_;
class Rel;
class RelDefaultTypeInternal;
extern RelDefaultTypeInternal _Rel_default_instance_;
class RelCommon;
class RelCommonDefaultTypeInternal;
extern RelCommonDefaultTypeInternal _RelCommon_default_instance_;
class RelCommon_Direct;
class RelCommon_DirectDefaultTypeInternal;
extern RelCommon_DirectDefaultTypeInternal _RelCommon_Direct_default_instance_;
class RelCommon_Emit;
class RelCommon_EmitDefaultTypeInternal;
extern RelCommon_EmitDefaultTypeInternal _RelCommon_Emit_default_instance_;
class RelCommon_Hint;
class RelCommon_HintDefaultTypeInternal;
extern RelCommon_HintDefaultTypeInternal _RelCommon_Hint_default_instance_;
class RelCommon_Hint_RuntimeConstraint;
class RelCommon_Hint_RuntimeConstraintDefaultTypeInternal;
extern RelCommon_Hint_RuntimeConstraintDefaultTypeInternal _RelCommon_Hint_RuntimeConstraint_default_instance_;
class RelCommon_Hint_Stats;
class RelCommon_Hint_StatsDefaultTypeInternal;
extern RelCommon_Hint_StatsDefaultTypeInternal _RelCommon_Hint_Stats_default_instance_;
class RelRoot;
class RelRootDefaultTypeInternal;
extern RelRootDefaultTypeInternal _RelRoot_default_instance_;
class SetRel;
class SetRelDefaultTypeInternal;
extern SetRelDefaultTypeInternal _SetRel_default_instance_;
class SortField;
class SortFieldDefaultTypeInternal;
extern SortFieldDefaultTypeInternal _SortField_default_instance_;
class SortRel;
class SortRelDefaultTypeInternal;
extern SortRelDefaultTypeInternal _SortRel_default_instance_;
class WriteRel;
class WriteRelDefaultTypeInternal;
extern WriteRelDefaultTypeInternal _WriteRel_default_instance_;
}  // namespace substrait
namespace google {
namespace protobuf {
template<> ::substrait::AggregateFunction* Arena::CreateMaybeMessage<::substrait::AggregateFunction>(Arena*);
template<> ::substrait::AggregateFunction_ReferenceRel* Arena::CreateMaybeMessage<::substrait::AggregateFunction_ReferenceRel>(Arena*);
template<> ::substrait::AggregateRel* Arena::CreateMaybeMessage<::substrait::AggregateRel>(Arena*);
template<> ::substrait::AggregateRel_Grouping* Arena::CreateMaybeMessage<::substrait::AggregateRel_Grouping>(Arena*);
template<> ::substrait::AggregateRel_Measure* Arena::CreateMaybeMessage<::substrait::AggregateRel_Measure>(Arena*);
template<> ::substrait::CrossRel* Arena::CreateMaybeMessage<::substrait::CrossRel>(Arena*);
template<> ::substrait::DdlRel* Arena::CreateMaybeMessage<::substrait::DdlRel>(Arena*);
template<> ::substrait::ExchangeRel* Arena::CreateMaybeMessage<::substrait::ExchangeRel>(Arena*);
template<> ::substrait::ExchangeRel_Broadcast* Arena::CreateMaybeMessage<::substrait::ExchangeRel_Broadcast>(Arena*);
template<> ::substrait::ExchangeRel_ExchangeTarget* Arena::CreateMaybeMessage<::substrait::ExchangeRel_ExchangeTarget>(Arena*);
template<> ::substrait::ExchangeRel_MultiBucketExpression* Arena::CreateMaybeMessage<::substrait::ExchangeRel_MultiBucketExpression>(Arena*);
template<> ::substrait::ExchangeRel_RoundRobin* Arena::CreateMaybeMessage<::substrait::ExchangeRel_RoundRobin>(Arena*);
template<> ::substrait::ExchangeRel_ScatterFields* Arena::CreateMaybeMessage<::substrait::ExchangeRel_ScatterFields>(Arena*);
template<> ::substrait::ExchangeRel_SingleBucketExpression* Arena::CreateMaybeMessage<::substrait::ExchangeRel_SingleBucketExpression>(Arena*);
template<> ::substrait::Expression* Arena::CreateMaybeMessage<::substrait::Expression>(Arena*);
template<> ::substrait::Expression_Cast* Arena::CreateMaybeMessage<::substrait::Expression_Cast>(Arena*);
template<> ::substrait::Expression_EmbeddedFunction* Arena::CreateMaybeMessage<::substrait::Expression_EmbeddedFunction>(Arena*);
template<> ::substrait::Expression_EmbeddedFunction_PythonPickleFunction* Arena::CreateMaybeMessage<::substrait::Expression_EmbeddedFunction_PythonPickleFunction>(Arena*);
template<> ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* Arena::CreateMaybeMessage<::substrait::Expression_EmbeddedFunction_WebAssemblyFunction>(Arena*);
template<> ::substrait::Expression_Enum* Arena::CreateMaybeMessage<::substrait::Expression_Enum>(Arena*);
template<> ::substrait::Expression_Enum_Empty* Arena::CreateMaybeMessage<::substrait::Expression_Enum_Empty>(Arena*);
template<> ::substrait::Expression_FieldReference* Arena::CreateMaybeMessage<::substrait::Expression_FieldReference>(Arena*);
template<> ::substrait::Expression_FieldReference_OuterReference* Arena::CreateMaybeMessage<::substrait::Expression_FieldReference_OuterReference>(Arena*);
template<> ::substrait::Expression_FieldReference_RootReference* Arena::CreateMaybeMessage<::substrait::Expression_FieldReference_RootReference>(Arena*);
template<> ::substrait::Expression_IfThen* Arena::CreateMaybeMessage<::substrait::Expression_IfThen>(Arena*);
template<> ::substrait::Expression_IfThen_IfClause* Arena::CreateMaybeMessage<::substrait::Expression_IfThen_IfClause>(Arena*);
template<> ::substrait::Expression_Literal* Arena::CreateMaybeMessage<::substrait::Expression_Literal>(Arena*);
template<> ::substrait::Expression_Literal_Decimal* Arena::CreateMaybeMessage<::substrait::Expression_Literal_Decimal>(Arena*);
template<> ::substrait::Expression_Literal_IntervalDayToSecond* Arena::CreateMaybeMessage<::substrait::Expression_Literal_IntervalDayToSecond>(Arena*);
template<> ::substrait::Expression_Literal_IntervalYearToMonth* Arena::CreateMaybeMessage<::substrait::Expression_Literal_IntervalYearToMonth>(Arena*);
template<> ::substrait::Expression_Literal_List* Arena::CreateMaybeMessage<::substrait::Expression_Literal_List>(Arena*);
template<> ::substrait::Expression_Literal_Map* Arena::CreateMaybeMessage<::substrait::Expression_Literal_Map>(Arena*);
template<> ::substrait::Expression_Literal_Map_KeyValue* Arena::CreateMaybeMessage<::substrait::Expression_Literal_Map_KeyValue>(Arena*);
template<> ::substrait::Expression_Literal_Struct* Arena::CreateMaybeMessage<::substrait::Expression_Literal_Struct>(Arena*);
template<> ::substrait::Expression_Literal_UserDefined* Arena::CreateMaybeMessage<::substrait::Expression_Literal_UserDefined>(Arena*);
template<> ::substrait::Expression_Literal_VarChar* Arena::CreateMaybeMessage<::substrait::Expression_Literal_VarChar>(Arena*);
template<> ::substrait::Expression_MaskExpression* Arena::CreateMaybeMessage<::substrait::Expression_MaskExpression>(Arena*);
template<> ::substrait::Expression_MaskExpression_ListSelect* Arena::CreateMaybeMessage<::substrait::Expression_MaskExpression_ListSelect>(Arena*);
template<> ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem* Arena::CreateMaybeMessage<::substrait::Expression_MaskExpression_ListSelect_ListSelectItem>(Arena*);
template<> ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* Arena::CreateMaybeMessage<::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement>(Arena*);
template<> ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* Arena::CreateMaybeMessage<::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice>(Arena*);
template<> ::substrait::Expression_MaskExpression_MapSelect* Arena::CreateMaybeMessage<::substrait::Expression_MaskExpression_MapSelect>(Arena*);
template<> ::substrait::Expression_MaskExpression_MapSelect_MapKey* Arena::CreateMaybeMessage<::substrait::Expression_MaskExpression_MapSelect_MapKey>(Arena*);
template<> ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* Arena::CreateMaybeMessage<::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression>(Arena*);
template<> ::substrait::Expression_MaskExpression_Select* Arena::CreateMaybeMessage<::substrait::Expression_MaskExpression_Select>(Arena*);
template<> ::substrait::Expression_MaskExpression_StructItem* Arena::CreateMaybeMessage<::substrait::Expression_MaskExpression_StructItem>(Arena*);
template<> ::substrait::Expression_MaskExpression_StructSelect* Arena::CreateMaybeMessage<::substrait::Expression_MaskExpression_StructSelect>(Arena*);
template<> ::substrait::Expression_MultiOrList* Arena::CreateMaybeMessage<::substrait::Expression_MultiOrList>(Arena*);
template<> ::substrait::Expression_MultiOrList_Record* Arena::CreateMaybeMessage<::substrait::Expression_MultiOrList_Record>(Arena*);
template<> ::substrait::Expression_Nested* Arena::CreateMaybeMessage<::substrait::Expression_Nested>(Arena*);
template<> ::substrait::Expression_Nested_List* Arena::CreateMaybeMessage<::substrait::Expression_Nested_List>(Arena*);
template<> ::substrait::Expression_Nested_Map* Arena::CreateMaybeMessage<::substrait::Expression_Nested_Map>(Arena*);
template<> ::substrait::Expression_Nested_Map_KeyValue* Arena::CreateMaybeMessage<::substrait::Expression_Nested_Map_KeyValue>(Arena*);
template<> ::substrait::Expression_Nested_Struct* Arena::CreateMaybeMessage<::substrait::Expression_Nested_Struct>(Arena*);
template<> ::substrait::Expression_ReferenceSegment* Arena::CreateMaybeMessage<::substrait::Expression_ReferenceSegment>(Arena*);
template<> ::substrait::Expression_ReferenceSegment_ListElement* Arena::CreateMaybeMessage<::substrait::Expression_ReferenceSegment_ListElement>(Arena*);
template<> ::substrait::Expression_ReferenceSegment_MapKey* Arena::CreateMaybeMessage<::substrait::Expression_ReferenceSegment_MapKey>(Arena*);
template<> ::substrait::Expression_ReferenceSegment_StructField* Arena::CreateMaybeMessage<::substrait::Expression_ReferenceSegment_StructField>(Arena*);
template<> ::substrait::Expression_ScalarFunction* Arena::CreateMaybeMessage<::substrait::Expression_ScalarFunction>(Arena*);
template<> ::substrait::Expression_SingularOrList* Arena::CreateMaybeMessage<::substrait::Expression_SingularOrList>(Arena*);
template<> ::substrait::Expression_Subquery* Arena::CreateMaybeMessage<::substrait::Expression_Subquery>(Arena*);
template<> ::substrait::Expression_Subquery_InPredicate* Arena::CreateMaybeMessage<::substrait::Expression_Subquery_InPredicate>(Arena*);
template<> ::substrait::Expression_Subquery_Scalar* Arena::CreateMaybeMessage<::substrait::Expression_Subquery_Scalar>(Arena*);
template<> ::substrait::Expression_Subquery_SetComparison* Arena::CreateMaybeMessage<::substrait::Expression_Subquery_SetComparison>(Arena*);
template<> ::substrait::Expression_Subquery_SetPredicate* Arena::CreateMaybeMessage<::substrait::Expression_Subquery_SetPredicate>(Arena*);
template<> ::substrait::Expression_SwitchExpression* Arena::CreateMaybeMessage<::substrait::Expression_SwitchExpression>(Arena*);
template<> ::substrait::Expression_SwitchExpression_IfValue* Arena::CreateMaybeMessage<::substrait::Expression_SwitchExpression_IfValue>(Arena*);
template<> ::substrait::Expression_WindowFunction* Arena::CreateMaybeMessage<::substrait::Expression_WindowFunction>(Arena*);
template<> ::substrait::Expression_WindowFunction_Bound* Arena::CreateMaybeMessage<::substrait::Expression_WindowFunction_Bound>(Arena*);
template<> ::substrait::Expression_WindowFunction_Bound_CurrentRow* Arena::CreateMaybeMessage<::substrait::Expression_WindowFunction_Bound_CurrentRow>(Arena*);
template<> ::substrait::Expression_WindowFunction_Bound_Following* Arena::CreateMaybeMessage<::substrait::Expression_WindowFunction_Bound_Following>(Arena*);
template<> ::substrait::Expression_WindowFunction_Bound_Preceding* Arena::CreateMaybeMessage<::substrait::Expression_WindowFunction_Bound_Preceding>(Arena*);
template<> ::substrait::Expression_WindowFunction_Bound_Unbounded* Arena::CreateMaybeMessage<::substrait::Expression_WindowFunction_Bound_Unbounded>(Arena*);
template<> ::substrait::ExtensionLeafRel* Arena::CreateMaybeMessage<::substrait::ExtensionLeafRel>(Arena*);
template<> ::substrait::ExtensionMultiRel* Arena::CreateMaybeMessage<::substrait::ExtensionMultiRel>(Arena*);
template<> ::substrait::ExtensionObject* Arena::CreateMaybeMessage<::substrait::ExtensionObject>(Arena*);
template<> ::substrait::ExtensionSingleRel* Arena::CreateMaybeMessage<::substrait::ExtensionSingleRel>(Arena*);
template<> ::substrait::FetchRel* Arena::CreateMaybeMessage<::substrait::FetchRel>(Arena*);
template<> ::substrait::FilterRel* Arena::CreateMaybeMessage<::substrait::FilterRel>(Arena*);
template<> ::substrait::FunctionArgument* Arena::CreateMaybeMessage<::substrait::FunctionArgument>(Arena*);
template<> ::substrait::FunctionOption* Arena::CreateMaybeMessage<::substrait::FunctionOption>(Arena*);
template<> ::substrait::HashJoinRel* Arena::CreateMaybeMessage<::substrait::HashJoinRel>(Arena*);
template<> ::substrait::JoinRel* Arena::CreateMaybeMessage<::substrait::JoinRel>(Arena*);
template<> ::substrait::MergeJoinRel* Arena::CreateMaybeMessage<::substrait::MergeJoinRel>(Arena*);
template<> ::substrait::NamedObjectWrite* Arena::CreateMaybeMessage<::substrait::NamedObjectWrite>(Arena*);
template<> ::substrait::ProjectRel* Arena::CreateMaybeMessage<::substrait::ProjectRel>(Arena*);
template<> ::substrait::ReadRel* Arena::CreateMaybeMessage<::substrait::ReadRel>(Arena*);
template<> ::substrait::ReadRel_ExtensionTable* Arena::CreateMaybeMessage<::substrait::ReadRel_ExtensionTable>(Arena*);
template<> ::substrait::ReadRel_LocalFiles* Arena::CreateMaybeMessage<::substrait::ReadRel_LocalFiles>(Arena*);
template<> ::substrait::ReadRel_LocalFiles_FileOrFiles* Arena::CreateMaybeMessage<::substrait::ReadRel_LocalFiles_FileOrFiles>(Arena*);
template<> ::substrait::ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions* Arena::CreateMaybeMessage<::substrait::ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions>(Arena*);
template<> ::substrait::ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions* Arena::CreateMaybeMessage<::substrait::ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions>(Arena*);
template<> ::substrait::ReadRel_LocalFiles_FileOrFiles_OrcReadOptions* Arena::CreateMaybeMessage<::substrait::ReadRel_LocalFiles_FileOrFiles_OrcReadOptions>(Arena*);
template<> ::substrait::ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions* Arena::CreateMaybeMessage<::substrait::ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions>(Arena*);
template<> ::substrait::ReadRel_NamedTable* Arena::CreateMaybeMessage<::substrait::ReadRel_NamedTable>(Arena*);
template<> ::substrait::ReadRel_VirtualTable* Arena::CreateMaybeMessage<::substrait::ReadRel_VirtualTable>(Arena*);
template<> ::substrait::Rel* Arena::CreateMaybeMessage<::substrait::Rel>(Arena*);
template<> ::substrait::RelCommon* Arena::CreateMaybeMessage<::substrait::RelCommon>(Arena*);
template<> ::substrait::RelCommon_Direct* Arena::CreateMaybeMessage<::substrait::RelCommon_Direct>(Arena*);
template<> ::substrait::RelCommon_Emit* Arena::CreateMaybeMessage<::substrait::RelCommon_Emit>(Arena*);
template<> ::substrait::RelCommon_Hint* Arena::CreateMaybeMessage<::substrait::RelCommon_Hint>(Arena*);
template<> ::substrait::RelCommon_Hint_RuntimeConstraint* Arena::CreateMaybeMessage<::substrait::RelCommon_Hint_RuntimeConstraint>(Arena*);
template<> ::substrait::RelCommon_Hint_Stats* Arena::CreateMaybeMessage<::substrait::RelCommon_Hint_Stats>(Arena*);
template<> ::substrait::RelRoot* Arena::CreateMaybeMessage<::substrait::RelRoot>(Arena*);
template<> ::substrait::SetRel* Arena::CreateMaybeMessage<::substrait::SetRel>(Arena*);
template<> ::substrait::SortField* Arena::CreateMaybeMessage<::substrait::SortField>(Arena*);
template<> ::substrait::SortRel* Arena::CreateMaybeMessage<::substrait::SortRel>(Arena*);
template<> ::substrait::WriteRel* Arena::CreateMaybeMessage<::substrait::WriteRel>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace substrait {

enum JoinRel_JoinType {
  JoinRel_JoinType_JOIN_TYPE_UNSPECIFIED = 0,
  JoinRel_JoinType_JOIN_TYPE_INNER = 1,
  JoinRel_JoinType_JOIN_TYPE_OUTER = 2,
  JoinRel_JoinType_JOIN_TYPE_LEFT = 3,
  JoinRel_JoinType_JOIN_TYPE_RIGHT = 4,
  JoinRel_JoinType_JOIN_TYPE_SEMI = 5,
  JoinRel_JoinType_JOIN_TYPE_ANTI = 6,
  JoinRel_JoinType_JOIN_TYPE_SINGLE = 7,
  JoinRel_JoinType_JoinRel_JoinType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  JoinRel_JoinType_JoinRel_JoinType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool JoinRel_JoinType_IsValid(int value);
const JoinRel_JoinType JoinRel_JoinType_JoinType_MIN = JoinRel_JoinType_JOIN_TYPE_UNSPECIFIED;
const JoinRel_JoinType JoinRel_JoinType_JoinType_MAX = JoinRel_JoinType_JOIN_TYPE_SINGLE;
const int JoinRel_JoinType_JoinType_ARRAYSIZE = JoinRel_JoinType_JoinType_MAX + 1;

const ::google::protobuf::EnumDescriptor* JoinRel_JoinType_descriptor();
inline const ::std::string& JoinRel_JoinType_Name(JoinRel_JoinType value) {
  return ::google::protobuf::internal::NameOfEnum(
    JoinRel_JoinType_descriptor(), value);
}
inline bool JoinRel_JoinType_Parse(
    const ::std::string& name, JoinRel_JoinType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<JoinRel_JoinType>(
    JoinRel_JoinType_descriptor(), name, value);
}
enum SetRel_SetOp {
  SetRel_SetOp_SET_OP_UNSPECIFIED = 0,
  SetRel_SetOp_SET_OP_MINUS_PRIMARY = 1,
  SetRel_SetOp_SET_OP_MINUS_MULTISET = 2,
  SetRel_SetOp_SET_OP_INTERSECTION_PRIMARY = 3,
  SetRel_SetOp_SET_OP_INTERSECTION_MULTISET = 4,
  SetRel_SetOp_SET_OP_UNION_DISTINCT = 5,
  SetRel_SetOp_SET_OP_UNION_ALL = 6,
  SetRel_SetOp_SetRel_SetOp_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SetRel_SetOp_SetRel_SetOp_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SetRel_SetOp_IsValid(int value);
const SetRel_SetOp SetRel_SetOp_SetOp_MIN = SetRel_SetOp_SET_OP_UNSPECIFIED;
const SetRel_SetOp SetRel_SetOp_SetOp_MAX = SetRel_SetOp_SET_OP_UNION_ALL;
const int SetRel_SetOp_SetOp_ARRAYSIZE = SetRel_SetOp_SetOp_MAX + 1;

const ::google::protobuf::EnumDescriptor* SetRel_SetOp_descriptor();
inline const ::std::string& SetRel_SetOp_Name(SetRel_SetOp value) {
  return ::google::protobuf::internal::NameOfEnum(
    SetRel_SetOp_descriptor(), value);
}
inline bool SetRel_SetOp_Parse(
    const ::std::string& name, SetRel_SetOp* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SetRel_SetOp>(
    SetRel_SetOp_descriptor(), name, value);
}
enum DdlRel_DdlObject {
  DdlRel_DdlObject_DDL_OBJECT_UNSPECIFIED = 0,
  DdlRel_DdlObject_DDL_OBJECT_TABLE = 1,
  DdlRel_DdlObject_DDL_OBJECT_VIEW = 2,
  DdlRel_DdlObject_DdlRel_DdlObject_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DdlRel_DdlObject_DdlRel_DdlObject_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DdlRel_DdlObject_IsValid(int value);
const DdlRel_DdlObject DdlRel_DdlObject_DdlObject_MIN = DdlRel_DdlObject_DDL_OBJECT_UNSPECIFIED;
const DdlRel_DdlObject DdlRel_DdlObject_DdlObject_MAX = DdlRel_DdlObject_DDL_OBJECT_VIEW;
const int DdlRel_DdlObject_DdlObject_ARRAYSIZE = DdlRel_DdlObject_DdlObject_MAX + 1;

const ::google::protobuf::EnumDescriptor* DdlRel_DdlObject_descriptor();
inline const ::std::string& DdlRel_DdlObject_Name(DdlRel_DdlObject value) {
  return ::google::protobuf::internal::NameOfEnum(
    DdlRel_DdlObject_descriptor(), value);
}
inline bool DdlRel_DdlObject_Parse(
    const ::std::string& name, DdlRel_DdlObject* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DdlRel_DdlObject>(
    DdlRel_DdlObject_descriptor(), name, value);
}
enum DdlRel_DdlOp {
  DdlRel_DdlOp_DDL_OP_UNSPECIFIED = 0,
  DdlRel_DdlOp_DDL_OP_CREATE = 1,
  DdlRel_DdlOp_DDL_OP_CREATE_OR_REPLACE = 2,
  DdlRel_DdlOp_DDL_OP_ALTER = 3,
  DdlRel_DdlOp_DDL_OP_DROP = 4,
  DdlRel_DdlOp_DDL_OP_DROP_IF_EXIST = 5,
  DdlRel_DdlOp_DdlRel_DdlOp_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DdlRel_DdlOp_DdlRel_DdlOp_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DdlRel_DdlOp_IsValid(int value);
const DdlRel_DdlOp DdlRel_DdlOp_DdlOp_MIN = DdlRel_DdlOp_DDL_OP_UNSPECIFIED;
const DdlRel_DdlOp DdlRel_DdlOp_DdlOp_MAX = DdlRel_DdlOp_DDL_OP_DROP_IF_EXIST;
const int DdlRel_DdlOp_DdlOp_ARRAYSIZE = DdlRel_DdlOp_DdlOp_MAX + 1;

const ::google::protobuf::EnumDescriptor* DdlRel_DdlOp_descriptor();
inline const ::std::string& DdlRel_DdlOp_Name(DdlRel_DdlOp value) {
  return ::google::protobuf::internal::NameOfEnum(
    DdlRel_DdlOp_descriptor(), value);
}
inline bool DdlRel_DdlOp_Parse(
    const ::std::string& name, DdlRel_DdlOp* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DdlRel_DdlOp>(
    DdlRel_DdlOp_descriptor(), name, value);
}
enum WriteRel_WriteOp {
  WriteRel_WriteOp_WRITE_OP_UNSPECIFIED = 0,
  WriteRel_WriteOp_WRITE_OP_INSERT = 1,
  WriteRel_WriteOp_WRITE_OP_DELETE = 2,
  WriteRel_WriteOp_WRITE_OP_UPDATE = 3,
  WriteRel_WriteOp_WRITE_OP_CTAS = 4,
  WriteRel_WriteOp_WriteRel_WriteOp_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  WriteRel_WriteOp_WriteRel_WriteOp_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool WriteRel_WriteOp_IsValid(int value);
const WriteRel_WriteOp WriteRel_WriteOp_WriteOp_MIN = WriteRel_WriteOp_WRITE_OP_UNSPECIFIED;
const WriteRel_WriteOp WriteRel_WriteOp_WriteOp_MAX = WriteRel_WriteOp_WRITE_OP_CTAS;
const int WriteRel_WriteOp_WriteOp_ARRAYSIZE = WriteRel_WriteOp_WriteOp_MAX + 1;

const ::google::protobuf::EnumDescriptor* WriteRel_WriteOp_descriptor();
inline const ::std::string& WriteRel_WriteOp_Name(WriteRel_WriteOp value) {
  return ::google::protobuf::internal::NameOfEnum(
    WriteRel_WriteOp_descriptor(), value);
}
inline bool WriteRel_WriteOp_Parse(
    const ::std::string& name, WriteRel_WriteOp* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WriteRel_WriteOp>(
    WriteRel_WriteOp_descriptor(), name, value);
}
enum WriteRel_OutputMode {
  WriteRel_OutputMode_OUTPUT_MODE_UNSPECIFIED = 0,
  WriteRel_OutputMode_OUTPUT_MODE_NO_OUTPUT = 1,
  WriteRel_OutputMode_OUTPUT_MODE_MODIFIED_TUPLES = 2,
  WriteRel_OutputMode_WriteRel_OutputMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  WriteRel_OutputMode_WriteRel_OutputMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool WriteRel_OutputMode_IsValid(int value);
const WriteRel_OutputMode WriteRel_OutputMode_OutputMode_MIN = WriteRel_OutputMode_OUTPUT_MODE_UNSPECIFIED;
const WriteRel_OutputMode WriteRel_OutputMode_OutputMode_MAX = WriteRel_OutputMode_OUTPUT_MODE_MODIFIED_TUPLES;
const int WriteRel_OutputMode_OutputMode_ARRAYSIZE = WriteRel_OutputMode_OutputMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* WriteRel_OutputMode_descriptor();
inline const ::std::string& WriteRel_OutputMode_Name(WriteRel_OutputMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    WriteRel_OutputMode_descriptor(), value);
}
inline bool WriteRel_OutputMode_Parse(
    const ::std::string& name, WriteRel_OutputMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WriteRel_OutputMode>(
    WriteRel_OutputMode_descriptor(), name, value);
}
enum HashJoinRel_JoinType {
  HashJoinRel_JoinType_JOIN_TYPE_UNSPECIFIED = 0,
  HashJoinRel_JoinType_JOIN_TYPE_INNER = 1,
  HashJoinRel_JoinType_JOIN_TYPE_OUTER = 2,
  HashJoinRel_JoinType_JOIN_TYPE_LEFT = 3,
  HashJoinRel_JoinType_JOIN_TYPE_RIGHT = 4,
  HashJoinRel_JoinType_JOIN_TYPE_LEFT_SEMI = 5,
  HashJoinRel_JoinType_JOIN_TYPE_RIGHT_SEMI = 6,
  HashJoinRel_JoinType_JOIN_TYPE_LEFT_ANTI = 7,
  HashJoinRel_JoinType_JOIN_TYPE_RIGHT_ANTI = 8,
  HashJoinRel_JoinType_HashJoinRel_JoinType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  HashJoinRel_JoinType_HashJoinRel_JoinType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool HashJoinRel_JoinType_IsValid(int value);
const HashJoinRel_JoinType HashJoinRel_JoinType_JoinType_MIN = HashJoinRel_JoinType_JOIN_TYPE_UNSPECIFIED;
const HashJoinRel_JoinType HashJoinRel_JoinType_JoinType_MAX = HashJoinRel_JoinType_JOIN_TYPE_RIGHT_ANTI;
const int HashJoinRel_JoinType_JoinType_ARRAYSIZE = HashJoinRel_JoinType_JoinType_MAX + 1;

const ::google::protobuf::EnumDescriptor* HashJoinRel_JoinType_descriptor();
inline const ::std::string& HashJoinRel_JoinType_Name(HashJoinRel_JoinType value) {
  return ::google::protobuf::internal::NameOfEnum(
    HashJoinRel_JoinType_descriptor(), value);
}
inline bool HashJoinRel_JoinType_Parse(
    const ::std::string& name, HashJoinRel_JoinType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HashJoinRel_JoinType>(
    HashJoinRel_JoinType_descriptor(), name, value);
}
enum MergeJoinRel_JoinType {
  MergeJoinRel_JoinType_JOIN_TYPE_UNSPECIFIED = 0,
  MergeJoinRel_JoinType_JOIN_TYPE_INNER = 1,
  MergeJoinRel_JoinType_JOIN_TYPE_OUTER = 2,
  MergeJoinRel_JoinType_JOIN_TYPE_LEFT = 3,
  MergeJoinRel_JoinType_JOIN_TYPE_RIGHT = 4,
  MergeJoinRel_JoinType_JOIN_TYPE_LEFT_SEMI = 5,
  MergeJoinRel_JoinType_JOIN_TYPE_RIGHT_SEMI = 6,
  MergeJoinRel_JoinType_JOIN_TYPE_LEFT_ANTI = 7,
  MergeJoinRel_JoinType_JOIN_TYPE_RIGHT_ANTI = 8,
  MergeJoinRel_JoinType_MergeJoinRel_JoinType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MergeJoinRel_JoinType_MergeJoinRel_JoinType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MergeJoinRel_JoinType_IsValid(int value);
const MergeJoinRel_JoinType MergeJoinRel_JoinType_JoinType_MIN = MergeJoinRel_JoinType_JOIN_TYPE_UNSPECIFIED;
const MergeJoinRel_JoinType MergeJoinRel_JoinType_JoinType_MAX = MergeJoinRel_JoinType_JOIN_TYPE_RIGHT_ANTI;
const int MergeJoinRel_JoinType_JoinType_ARRAYSIZE = MergeJoinRel_JoinType_JoinType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MergeJoinRel_JoinType_descriptor();
inline const ::std::string& MergeJoinRel_JoinType_Name(MergeJoinRel_JoinType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MergeJoinRel_JoinType_descriptor(), value);
}
inline bool MergeJoinRel_JoinType_Parse(
    const ::std::string& name, MergeJoinRel_JoinType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MergeJoinRel_JoinType>(
    MergeJoinRel_JoinType_descriptor(), name, value);
}
enum Expression_Cast_FailureBehavior {
  Expression_Cast_FailureBehavior_FAILURE_BEHAVIOR_UNSPECIFIED = 0,
  Expression_Cast_FailureBehavior_FAILURE_BEHAVIOR_RETURN_NULL = 1,
  Expression_Cast_FailureBehavior_FAILURE_BEHAVIOR_THROW_EXCEPTION = 2,
  Expression_Cast_FailureBehavior_Expression_Cast_FailureBehavior_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Expression_Cast_FailureBehavior_Expression_Cast_FailureBehavior_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Expression_Cast_FailureBehavior_IsValid(int value);
const Expression_Cast_FailureBehavior Expression_Cast_FailureBehavior_FailureBehavior_MIN = Expression_Cast_FailureBehavior_FAILURE_BEHAVIOR_UNSPECIFIED;
const Expression_Cast_FailureBehavior Expression_Cast_FailureBehavior_FailureBehavior_MAX = Expression_Cast_FailureBehavior_FAILURE_BEHAVIOR_THROW_EXCEPTION;
const int Expression_Cast_FailureBehavior_FailureBehavior_ARRAYSIZE = Expression_Cast_FailureBehavior_FailureBehavior_MAX + 1;

const ::google::protobuf::EnumDescriptor* Expression_Cast_FailureBehavior_descriptor();
inline const ::std::string& Expression_Cast_FailureBehavior_Name(Expression_Cast_FailureBehavior value) {
  return ::google::protobuf::internal::NameOfEnum(
    Expression_Cast_FailureBehavior_descriptor(), value);
}
inline bool Expression_Cast_FailureBehavior_Parse(
    const ::std::string& name, Expression_Cast_FailureBehavior* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Expression_Cast_FailureBehavior>(
    Expression_Cast_FailureBehavior_descriptor(), name, value);
}
enum Expression_Subquery_SetPredicate_PredicateOp {
  Expression_Subquery_SetPredicate_PredicateOp_PREDICATE_OP_UNSPECIFIED = 0,
  Expression_Subquery_SetPredicate_PredicateOp_PREDICATE_OP_EXISTS = 1,
  Expression_Subquery_SetPredicate_PredicateOp_PREDICATE_OP_UNIQUE = 2,
  Expression_Subquery_SetPredicate_PredicateOp_Expression_Subquery_SetPredicate_PredicateOp_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Expression_Subquery_SetPredicate_PredicateOp_Expression_Subquery_SetPredicate_PredicateOp_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Expression_Subquery_SetPredicate_PredicateOp_IsValid(int value);
const Expression_Subquery_SetPredicate_PredicateOp Expression_Subquery_SetPredicate_PredicateOp_PredicateOp_MIN = Expression_Subquery_SetPredicate_PredicateOp_PREDICATE_OP_UNSPECIFIED;
const Expression_Subquery_SetPredicate_PredicateOp Expression_Subquery_SetPredicate_PredicateOp_PredicateOp_MAX = Expression_Subquery_SetPredicate_PredicateOp_PREDICATE_OP_UNIQUE;
const int Expression_Subquery_SetPredicate_PredicateOp_PredicateOp_ARRAYSIZE = Expression_Subquery_SetPredicate_PredicateOp_PredicateOp_MAX + 1;

const ::google::protobuf::EnumDescriptor* Expression_Subquery_SetPredicate_PredicateOp_descriptor();
inline const ::std::string& Expression_Subquery_SetPredicate_PredicateOp_Name(Expression_Subquery_SetPredicate_PredicateOp value) {
  return ::google::protobuf::internal::NameOfEnum(
    Expression_Subquery_SetPredicate_PredicateOp_descriptor(), value);
}
inline bool Expression_Subquery_SetPredicate_PredicateOp_Parse(
    const ::std::string& name, Expression_Subquery_SetPredicate_PredicateOp* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Expression_Subquery_SetPredicate_PredicateOp>(
    Expression_Subquery_SetPredicate_PredicateOp_descriptor(), name, value);
}
enum Expression_Subquery_SetComparison_ComparisonOp {
  Expression_Subquery_SetComparison_ComparisonOp_COMPARISON_OP_UNSPECIFIED = 0,
  Expression_Subquery_SetComparison_ComparisonOp_COMPARISON_OP_EQ = 1,
  Expression_Subquery_SetComparison_ComparisonOp_COMPARISON_OP_NE = 2,
  Expression_Subquery_SetComparison_ComparisonOp_COMPARISON_OP_LT = 3,
  Expression_Subquery_SetComparison_ComparisonOp_COMPARISON_OP_GT = 4,
  Expression_Subquery_SetComparison_ComparisonOp_COMPARISON_OP_LE = 5,
  Expression_Subquery_SetComparison_ComparisonOp_COMPARISON_OP_GE = 6,
  Expression_Subquery_SetComparison_ComparisonOp_Expression_Subquery_SetComparison_ComparisonOp_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Expression_Subquery_SetComparison_ComparisonOp_Expression_Subquery_SetComparison_ComparisonOp_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Expression_Subquery_SetComparison_ComparisonOp_IsValid(int value);
const Expression_Subquery_SetComparison_ComparisonOp Expression_Subquery_SetComparison_ComparisonOp_ComparisonOp_MIN = Expression_Subquery_SetComparison_ComparisonOp_COMPARISON_OP_UNSPECIFIED;
const Expression_Subquery_SetComparison_ComparisonOp Expression_Subquery_SetComparison_ComparisonOp_ComparisonOp_MAX = Expression_Subquery_SetComparison_ComparisonOp_COMPARISON_OP_GE;
const int Expression_Subquery_SetComparison_ComparisonOp_ComparisonOp_ARRAYSIZE = Expression_Subquery_SetComparison_ComparisonOp_ComparisonOp_MAX + 1;

const ::google::protobuf::EnumDescriptor* Expression_Subquery_SetComparison_ComparisonOp_descriptor();
inline const ::std::string& Expression_Subquery_SetComparison_ComparisonOp_Name(Expression_Subquery_SetComparison_ComparisonOp value) {
  return ::google::protobuf::internal::NameOfEnum(
    Expression_Subquery_SetComparison_ComparisonOp_descriptor(), value);
}
inline bool Expression_Subquery_SetComparison_ComparisonOp_Parse(
    const ::std::string& name, Expression_Subquery_SetComparison_ComparisonOp* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Expression_Subquery_SetComparison_ComparisonOp>(
    Expression_Subquery_SetComparison_ComparisonOp_descriptor(), name, value);
}
enum Expression_Subquery_SetComparison_ReductionOp {
  Expression_Subquery_SetComparison_ReductionOp_REDUCTION_OP_UNSPECIFIED = 0,
  Expression_Subquery_SetComparison_ReductionOp_REDUCTION_OP_ANY = 1,
  Expression_Subquery_SetComparison_ReductionOp_REDUCTION_OP_ALL = 2,
  Expression_Subquery_SetComparison_ReductionOp_Expression_Subquery_SetComparison_ReductionOp_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Expression_Subquery_SetComparison_ReductionOp_Expression_Subquery_SetComparison_ReductionOp_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Expression_Subquery_SetComparison_ReductionOp_IsValid(int value);
const Expression_Subquery_SetComparison_ReductionOp Expression_Subquery_SetComparison_ReductionOp_ReductionOp_MIN = Expression_Subquery_SetComparison_ReductionOp_REDUCTION_OP_UNSPECIFIED;
const Expression_Subquery_SetComparison_ReductionOp Expression_Subquery_SetComparison_ReductionOp_ReductionOp_MAX = Expression_Subquery_SetComparison_ReductionOp_REDUCTION_OP_ALL;
const int Expression_Subquery_SetComparison_ReductionOp_ReductionOp_ARRAYSIZE = Expression_Subquery_SetComparison_ReductionOp_ReductionOp_MAX + 1;

const ::google::protobuf::EnumDescriptor* Expression_Subquery_SetComparison_ReductionOp_descriptor();
inline const ::std::string& Expression_Subquery_SetComparison_ReductionOp_Name(Expression_Subquery_SetComparison_ReductionOp value) {
  return ::google::protobuf::internal::NameOfEnum(
    Expression_Subquery_SetComparison_ReductionOp_descriptor(), value);
}
inline bool Expression_Subquery_SetComparison_ReductionOp_Parse(
    const ::std::string& name, Expression_Subquery_SetComparison_ReductionOp* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Expression_Subquery_SetComparison_ReductionOp>(
    Expression_Subquery_SetComparison_ReductionOp_descriptor(), name, value);
}
enum SortField_SortDirection {
  SortField_SortDirection_SORT_DIRECTION_UNSPECIFIED = 0,
  SortField_SortDirection_SORT_DIRECTION_ASC_NULLS_FIRST = 1,
  SortField_SortDirection_SORT_DIRECTION_ASC_NULLS_LAST = 2,
  SortField_SortDirection_SORT_DIRECTION_DESC_NULLS_FIRST = 3,
  SortField_SortDirection_SORT_DIRECTION_DESC_NULLS_LAST = 4,
  SortField_SortDirection_SORT_DIRECTION_CLUSTERED = 5,
  SortField_SortDirection_SortField_SortDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SortField_SortDirection_SortField_SortDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SortField_SortDirection_IsValid(int value);
const SortField_SortDirection SortField_SortDirection_SortDirection_MIN = SortField_SortDirection_SORT_DIRECTION_UNSPECIFIED;
const SortField_SortDirection SortField_SortDirection_SortDirection_MAX = SortField_SortDirection_SORT_DIRECTION_CLUSTERED;
const int SortField_SortDirection_SortDirection_ARRAYSIZE = SortField_SortDirection_SortDirection_MAX + 1;

const ::google::protobuf::EnumDescriptor* SortField_SortDirection_descriptor();
inline const ::std::string& SortField_SortDirection_Name(SortField_SortDirection value) {
  return ::google::protobuf::internal::NameOfEnum(
    SortField_SortDirection_descriptor(), value);
}
inline bool SortField_SortDirection_Parse(
    const ::std::string& name, SortField_SortDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SortField_SortDirection>(
    SortField_SortDirection_descriptor(), name, value);
}
enum AggregateFunction_AggregationInvocation {
  AggregateFunction_AggregationInvocation_AGGREGATION_INVOCATION_UNSPECIFIED = 0,
  AggregateFunction_AggregationInvocation_AGGREGATION_INVOCATION_ALL = 1,
  AggregateFunction_AggregationInvocation_AGGREGATION_INVOCATION_DISTINCT = 2,
  AggregateFunction_AggregationInvocation_AggregateFunction_AggregationInvocation_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AggregateFunction_AggregationInvocation_AggregateFunction_AggregationInvocation_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AggregateFunction_AggregationInvocation_IsValid(int value);
const AggregateFunction_AggregationInvocation AggregateFunction_AggregationInvocation_AggregationInvocation_MIN = AggregateFunction_AggregationInvocation_AGGREGATION_INVOCATION_UNSPECIFIED;
const AggregateFunction_AggregationInvocation AggregateFunction_AggregationInvocation_AggregationInvocation_MAX = AggregateFunction_AggregationInvocation_AGGREGATION_INVOCATION_DISTINCT;
const int AggregateFunction_AggregationInvocation_AggregationInvocation_ARRAYSIZE = AggregateFunction_AggregationInvocation_AggregationInvocation_MAX + 1;

const ::google::protobuf::EnumDescriptor* AggregateFunction_AggregationInvocation_descriptor();
inline const ::std::string& AggregateFunction_AggregationInvocation_Name(AggregateFunction_AggregationInvocation value) {
  return ::google::protobuf::internal::NameOfEnum(
    AggregateFunction_AggregationInvocation_descriptor(), value);
}
inline bool AggregateFunction_AggregationInvocation_Parse(
    const ::std::string& name, AggregateFunction_AggregationInvocation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AggregateFunction_AggregationInvocation>(
    AggregateFunction_AggregationInvocation_descriptor(), name, value);
}
enum AggregationPhase {
  AGGREGATION_PHASE_UNSPECIFIED = 0,
  AGGREGATION_PHASE_INITIAL_TO_INTERMEDIATE = 1,
  AGGREGATION_PHASE_INTERMEDIATE_TO_INTERMEDIATE = 2,
  AGGREGATION_PHASE_INITIAL_TO_RESULT = 3,
  AGGREGATION_PHASE_INTERMEDIATE_TO_RESULT = 4,
  AggregationPhase_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AggregationPhase_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AggregationPhase_IsValid(int value);
const AggregationPhase AggregationPhase_MIN = AGGREGATION_PHASE_UNSPECIFIED;
const AggregationPhase AggregationPhase_MAX = AGGREGATION_PHASE_INTERMEDIATE_TO_RESULT;
const int AggregationPhase_ARRAYSIZE = AggregationPhase_MAX + 1;

const ::google::protobuf::EnumDescriptor* AggregationPhase_descriptor();
inline const ::std::string& AggregationPhase_Name(AggregationPhase value) {
  return ::google::protobuf::internal::NameOfEnum(
    AggregationPhase_descriptor(), value);
}
inline bool AggregationPhase_Parse(
    const ::std::string& name, AggregationPhase* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AggregationPhase>(
    AggregationPhase_descriptor(), name, value);
}
// ===================================================================

class RelCommon_Direct : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.RelCommon.Direct) */ {
 public:
  RelCommon_Direct();
  virtual ~RelCommon_Direct();

  RelCommon_Direct(const RelCommon_Direct& from);

  inline RelCommon_Direct& operator=(const RelCommon_Direct& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RelCommon_Direct(RelCommon_Direct&& from) noexcept
    : RelCommon_Direct() {
    *this = ::std::move(from);
  }

  inline RelCommon_Direct& operator=(RelCommon_Direct&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RelCommon_Direct& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RelCommon_Direct* internal_default_instance() {
    return reinterpret_cast<const RelCommon_Direct*>(
               &_RelCommon_Direct_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(RelCommon_Direct* other);
  friend void swap(RelCommon_Direct& a, RelCommon_Direct& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RelCommon_Direct* New() const final {
    return CreateMaybeMessage<RelCommon_Direct>(NULL);
  }

  RelCommon_Direct* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RelCommon_Direct>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RelCommon_Direct& from);
  void MergeFrom(const RelCommon_Direct& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelCommon_Direct* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:substrait.RelCommon.Direct)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RelCommon_Emit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.RelCommon.Emit) */ {
 public:
  RelCommon_Emit();
  virtual ~RelCommon_Emit();

  RelCommon_Emit(const RelCommon_Emit& from);

  inline RelCommon_Emit& operator=(const RelCommon_Emit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RelCommon_Emit(RelCommon_Emit&& from) noexcept
    : RelCommon_Emit() {
    *this = ::std::move(from);
  }

  inline RelCommon_Emit& operator=(RelCommon_Emit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RelCommon_Emit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RelCommon_Emit* internal_default_instance() {
    return reinterpret_cast<const RelCommon_Emit*>(
               &_RelCommon_Emit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RelCommon_Emit* other);
  friend void swap(RelCommon_Emit& a, RelCommon_Emit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RelCommon_Emit* New() const final {
    return CreateMaybeMessage<RelCommon_Emit>(NULL);
  }

  RelCommon_Emit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RelCommon_Emit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RelCommon_Emit& from);
  void MergeFrom(const RelCommon_Emit& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelCommon_Emit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 output_mapping = 1;
  int output_mapping_size() const;
  void clear_output_mapping();
  static const int kOutputMappingFieldNumber = 1;
  ::google::protobuf::int32 output_mapping(int index) const;
  void set_output_mapping(int index, ::google::protobuf::int32 value);
  void add_output_mapping(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      output_mapping() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_output_mapping();

  // @@protoc_insertion_point(class_scope:substrait.RelCommon.Emit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > output_mapping_;
  mutable int _output_mapping_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RelCommon_Hint_Stats : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.RelCommon.Hint.Stats) */ {
 public:
  RelCommon_Hint_Stats();
  virtual ~RelCommon_Hint_Stats();

  RelCommon_Hint_Stats(const RelCommon_Hint_Stats& from);

  inline RelCommon_Hint_Stats& operator=(const RelCommon_Hint_Stats& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RelCommon_Hint_Stats(RelCommon_Hint_Stats&& from) noexcept
    : RelCommon_Hint_Stats() {
    *this = ::std::move(from);
  }

  inline RelCommon_Hint_Stats& operator=(RelCommon_Hint_Stats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RelCommon_Hint_Stats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RelCommon_Hint_Stats* internal_default_instance() {
    return reinterpret_cast<const RelCommon_Hint_Stats*>(
               &_RelCommon_Hint_Stats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(RelCommon_Hint_Stats* other);
  friend void swap(RelCommon_Hint_Stats& a, RelCommon_Hint_Stats& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RelCommon_Hint_Stats* New() const final {
    return CreateMaybeMessage<RelCommon_Hint_Stats>(NULL);
  }

  RelCommon_Hint_Stats* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RelCommon_Hint_Stats>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RelCommon_Hint_Stats& from);
  void MergeFrom(const RelCommon_Hint_Stats& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelCommon_Hint_Stats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension();
  static const int kAdvancedExtensionFieldNumber = 10;
  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  public:
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension);

  // double row_count = 1;
  void clear_row_count();
  static const int kRowCountFieldNumber = 1;
  double row_count() const;
  void set_row_count(double value);

  // double record_size = 2;
  void clear_record_size();
  static const int kRecordSizeFieldNumber = 2;
  double record_size() const;
  void set_record_size(double value);

  // @@protoc_insertion_point(class_scope:substrait.RelCommon.Hint.Stats)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::substrait::extensions::AdvancedExtension* advanced_extension_;
  double row_count_;
  double record_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RelCommon_Hint_RuntimeConstraint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.RelCommon.Hint.RuntimeConstraint) */ {
 public:
  RelCommon_Hint_RuntimeConstraint();
  virtual ~RelCommon_Hint_RuntimeConstraint();

  RelCommon_Hint_RuntimeConstraint(const RelCommon_Hint_RuntimeConstraint& from);

  inline RelCommon_Hint_RuntimeConstraint& operator=(const RelCommon_Hint_RuntimeConstraint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RelCommon_Hint_RuntimeConstraint(RelCommon_Hint_RuntimeConstraint&& from) noexcept
    : RelCommon_Hint_RuntimeConstraint() {
    *this = ::std::move(from);
  }

  inline RelCommon_Hint_RuntimeConstraint& operator=(RelCommon_Hint_RuntimeConstraint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RelCommon_Hint_RuntimeConstraint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RelCommon_Hint_RuntimeConstraint* internal_default_instance() {
    return reinterpret_cast<const RelCommon_Hint_RuntimeConstraint*>(
               &_RelCommon_Hint_RuntimeConstraint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(RelCommon_Hint_RuntimeConstraint* other);
  friend void swap(RelCommon_Hint_RuntimeConstraint& a, RelCommon_Hint_RuntimeConstraint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RelCommon_Hint_RuntimeConstraint* New() const final {
    return CreateMaybeMessage<RelCommon_Hint_RuntimeConstraint>(NULL);
  }

  RelCommon_Hint_RuntimeConstraint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RelCommon_Hint_RuntimeConstraint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RelCommon_Hint_RuntimeConstraint& from);
  void MergeFrom(const RelCommon_Hint_RuntimeConstraint& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelCommon_Hint_RuntimeConstraint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension();
  static const int kAdvancedExtensionFieldNumber = 10;
  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  public:
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension);

  // @@protoc_insertion_point(class_scope:substrait.RelCommon.Hint.RuntimeConstraint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::substrait::extensions::AdvancedExtension* advanced_extension_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RelCommon_Hint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.RelCommon.Hint) */ {
 public:
  RelCommon_Hint();
  virtual ~RelCommon_Hint();

  RelCommon_Hint(const RelCommon_Hint& from);

  inline RelCommon_Hint& operator=(const RelCommon_Hint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RelCommon_Hint(RelCommon_Hint&& from) noexcept
    : RelCommon_Hint() {
    *this = ::std::move(from);
  }

  inline RelCommon_Hint& operator=(RelCommon_Hint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RelCommon_Hint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RelCommon_Hint* internal_default_instance() {
    return reinterpret_cast<const RelCommon_Hint*>(
               &_RelCommon_Hint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(RelCommon_Hint* other);
  friend void swap(RelCommon_Hint& a, RelCommon_Hint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RelCommon_Hint* New() const final {
    return CreateMaybeMessage<RelCommon_Hint>(NULL);
  }

  RelCommon_Hint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RelCommon_Hint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RelCommon_Hint& from);
  void MergeFrom(const RelCommon_Hint& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelCommon_Hint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RelCommon_Hint_Stats Stats;
  typedef RelCommon_Hint_RuntimeConstraint RuntimeConstraint;

  // accessors -------------------------------------------------------

  // .substrait.RelCommon.Hint.Stats stats = 1;
  bool has_stats() const;
  void clear_stats();
  static const int kStatsFieldNumber = 1;
  private:
  const ::substrait::RelCommon_Hint_Stats& _internal_stats() const;
  public:
  const ::substrait::RelCommon_Hint_Stats& stats() const;
  ::substrait::RelCommon_Hint_Stats* release_stats();
  ::substrait::RelCommon_Hint_Stats* mutable_stats();
  void set_allocated_stats(::substrait::RelCommon_Hint_Stats* stats);

  // .substrait.RelCommon.Hint.RuntimeConstraint constraint = 2;
  bool has_constraint() const;
  void clear_constraint();
  static const int kConstraintFieldNumber = 2;
  private:
  const ::substrait::RelCommon_Hint_RuntimeConstraint& _internal_constraint() const;
  public:
  const ::substrait::RelCommon_Hint_RuntimeConstraint& constraint() const;
  ::substrait::RelCommon_Hint_RuntimeConstraint* release_constraint();
  ::substrait::RelCommon_Hint_RuntimeConstraint* mutable_constraint();
  void set_allocated_constraint(::substrait::RelCommon_Hint_RuntimeConstraint* constraint);

  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension();
  static const int kAdvancedExtensionFieldNumber = 10;
  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  public:
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension);

  // @@protoc_insertion_point(class_scope:substrait.RelCommon.Hint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::substrait::RelCommon_Hint_Stats* stats_;
  ::substrait::RelCommon_Hint_RuntimeConstraint* constraint_;
  ::substrait::extensions::AdvancedExtension* advanced_extension_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RelCommon : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.RelCommon) */ {
 public:
  RelCommon();
  virtual ~RelCommon();

  RelCommon(const RelCommon& from);

  inline RelCommon& operator=(const RelCommon& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RelCommon(RelCommon&& from) noexcept
    : RelCommon() {
    *this = ::std::move(from);
  }

  inline RelCommon& operator=(RelCommon&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RelCommon& default_instance();

  enum EmitKindCase {
    kDirect = 1,
    kEmit = 2,
    EMIT_KIND_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RelCommon* internal_default_instance() {
    return reinterpret_cast<const RelCommon*>(
               &_RelCommon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(RelCommon* other);
  friend void swap(RelCommon& a, RelCommon& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RelCommon* New() const final {
    return CreateMaybeMessage<RelCommon>(NULL);
  }

  RelCommon* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RelCommon>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RelCommon& from);
  void MergeFrom(const RelCommon& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelCommon* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RelCommon_Direct Direct;
  typedef RelCommon_Emit Emit;
  typedef RelCommon_Hint Hint;

  // accessors -------------------------------------------------------

  // .substrait.RelCommon.Hint hint = 3;
  bool has_hint() const;
  void clear_hint();
  static const int kHintFieldNumber = 3;
  private:
  const ::substrait::RelCommon_Hint& _internal_hint() const;
  public:
  const ::substrait::RelCommon_Hint& hint() const;
  ::substrait::RelCommon_Hint* release_hint();
  ::substrait::RelCommon_Hint* mutable_hint();
  void set_allocated_hint(::substrait::RelCommon_Hint* hint);

  // .substrait.extensions.AdvancedExtension advanced_extension = 4;
  bool has_advanced_extension() const;
  void clear_advanced_extension();
  static const int kAdvancedExtensionFieldNumber = 4;
  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  public:
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension);

  // .substrait.RelCommon.Direct direct = 1;
  bool has_direct() const;
  void clear_direct();
  static const int kDirectFieldNumber = 1;
  private:
  const ::substrait::RelCommon_Direct& _internal_direct() const;
  public:
  const ::substrait::RelCommon_Direct& direct() const;
  ::substrait::RelCommon_Direct* release_direct();
  ::substrait::RelCommon_Direct* mutable_direct();
  void set_allocated_direct(::substrait::RelCommon_Direct* direct);

  // .substrait.RelCommon.Emit emit = 2;
  bool has_emit() const;
  void clear_emit();
  static const int kEmitFieldNumber = 2;
  private:
  const ::substrait::RelCommon_Emit& _internal_emit() const;
  public:
  const ::substrait::RelCommon_Emit& emit() const;
  ::substrait::RelCommon_Emit* release_emit();
  ::substrait::RelCommon_Emit* mutable_emit();
  void set_allocated_emit(::substrait::RelCommon_Emit* emit);

  void clear_emit_kind();
  EmitKindCase emit_kind_case() const;
  // @@protoc_insertion_point(class_scope:substrait.RelCommon)
 private:
  void set_has_direct();
  void set_has_emit();

  inline bool has_emit_kind() const;
  inline void clear_has_emit_kind();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::substrait::RelCommon_Hint* hint_;
  ::substrait::extensions::AdvancedExtension* advanced_extension_;
  union EmitKindUnion {
    EmitKindUnion() {}
    ::substrait::RelCommon_Direct* direct_;
    ::substrait::RelCommon_Emit* emit_;
  } emit_kind_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReadRel_NamedTable : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.ReadRel.NamedTable) */ {
 public:
  ReadRel_NamedTable();
  virtual ~ReadRel_NamedTable();

  ReadRel_NamedTable(const ReadRel_NamedTable& from);

  inline ReadRel_NamedTable& operator=(const ReadRel_NamedTable& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReadRel_NamedTable(ReadRel_NamedTable&& from) noexcept
    : ReadRel_NamedTable() {
    *this = ::std::move(from);
  }

  inline ReadRel_NamedTable& operator=(ReadRel_NamedTable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadRel_NamedTable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadRel_NamedTable* internal_default_instance() {
    return reinterpret_cast<const ReadRel_NamedTable*>(
               &_ReadRel_NamedTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ReadRel_NamedTable* other);
  friend void swap(ReadRel_NamedTable& a, ReadRel_NamedTable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReadRel_NamedTable* New() const final {
    return CreateMaybeMessage<ReadRel_NamedTable>(NULL);
  }

  ReadRel_NamedTable* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReadRel_NamedTable>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReadRel_NamedTable& from);
  void MergeFrom(const ReadRel_NamedTable& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadRel_NamedTable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string names = 1;
  int names_size() const;
  void clear_names();
  static const int kNamesFieldNumber = 1;
  const ::std::string& names(int index) const;
  ::std::string* mutable_names(int index);
  void set_names(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_names(int index, ::std::string&& value);
  #endif
  void set_names(int index, const char* value);
  void set_names(int index, const char* value, size_t size);
  ::std::string* add_names();
  void add_names(const ::std::string& value);
  #if LANG_CXX11
  void add_names(::std::string&& value);
  #endif
  void add_names(const char* value);
  void add_names(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& names() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_names();

  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension();
  static const int kAdvancedExtensionFieldNumber = 10;
  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  public:
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension);

  // @@protoc_insertion_point(class_scope:substrait.ReadRel.NamedTable)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> names_;
  ::substrait::extensions::AdvancedExtension* advanced_extension_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReadRel_VirtualTable : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.ReadRel.VirtualTable) */ {
 public:
  ReadRel_VirtualTable();
  virtual ~ReadRel_VirtualTable();

  ReadRel_VirtualTable(const ReadRel_VirtualTable& from);

  inline ReadRel_VirtualTable& operator=(const ReadRel_VirtualTable& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReadRel_VirtualTable(ReadRel_VirtualTable&& from) noexcept
    : ReadRel_VirtualTable() {
    *this = ::std::move(from);
  }

  inline ReadRel_VirtualTable& operator=(ReadRel_VirtualTable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadRel_VirtualTable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadRel_VirtualTable* internal_default_instance() {
    return reinterpret_cast<const ReadRel_VirtualTable*>(
               &_ReadRel_VirtualTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ReadRel_VirtualTable* other);
  friend void swap(ReadRel_VirtualTable& a, ReadRel_VirtualTable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReadRel_VirtualTable* New() const final {
    return CreateMaybeMessage<ReadRel_VirtualTable>(NULL);
  }

  ReadRel_VirtualTable* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReadRel_VirtualTable>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReadRel_VirtualTable& from);
  void MergeFrom(const ReadRel_VirtualTable& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadRel_VirtualTable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .substrait.Expression.Literal.Struct values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  ::substrait::Expression_Literal_Struct* mutable_values(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression_Literal_Struct >*
      mutable_values();
  const ::substrait::Expression_Literal_Struct& values(int index) const;
  ::substrait::Expression_Literal_Struct* add_values();
  const ::google::protobuf::RepeatedPtrField< ::substrait::Expression_Literal_Struct >&
      values() const;

  // @@protoc_insertion_point(class_scope:substrait.ReadRel.VirtualTable)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression_Literal_Struct > values_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReadRel_ExtensionTable : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.ReadRel.ExtensionTable) */ {
 public:
  ReadRel_ExtensionTable();
  virtual ~ReadRel_ExtensionTable();

  ReadRel_ExtensionTable(const ReadRel_ExtensionTable& from);

  inline ReadRel_ExtensionTable& operator=(const ReadRel_ExtensionTable& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReadRel_ExtensionTable(ReadRel_ExtensionTable&& from) noexcept
    : ReadRel_ExtensionTable() {
    *this = ::std::move(from);
  }

  inline ReadRel_ExtensionTable& operator=(ReadRel_ExtensionTable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadRel_ExtensionTable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadRel_ExtensionTable* internal_default_instance() {
    return reinterpret_cast<const ReadRel_ExtensionTable*>(
               &_ReadRel_ExtensionTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ReadRel_ExtensionTable* other);
  friend void swap(ReadRel_ExtensionTable& a, ReadRel_ExtensionTable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReadRel_ExtensionTable* New() const final {
    return CreateMaybeMessage<ReadRel_ExtensionTable>(NULL);
  }

  ReadRel_ExtensionTable* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReadRel_ExtensionTable>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReadRel_ExtensionTable& from);
  void MergeFrom(const ReadRel_ExtensionTable& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadRel_ExtensionTable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.Any detail = 1;
  bool has_detail() const;
  void clear_detail();
  static const int kDetailFieldNumber = 1;
  private:
  const ::google::protobuf::Any& _internal_detail() const;
  public:
  const ::google::protobuf::Any& detail() const;
  ::google::protobuf::Any* release_detail();
  ::google::protobuf::Any* mutable_detail();
  void set_allocated_detail(::google::protobuf::Any* detail);

  // @@protoc_insertion_point(class_scope:substrait.ReadRel.ExtensionTable)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Any* detail_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.ReadRel.LocalFiles.FileOrFiles.ParquetReadOptions) */ {
 public:
  ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions();
  virtual ~ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions();

  ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions(const ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions& from);

  inline ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions& operator=(const ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions(ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions&& from) noexcept
    : ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions() {
    *this = ::std::move(from);
  }

  inline ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions& operator=(ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions* internal_default_instance() {
    return reinterpret_cast<const ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions*>(
               &_ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions* other);
  friend void swap(ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions& a, ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions* New() const final {
    return CreateMaybeMessage<ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions>(NULL);
  }

  ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions& from);
  void MergeFrom(const ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:substrait.ReadRel.LocalFiles.FileOrFiles.ParquetReadOptions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.ReadRel.LocalFiles.FileOrFiles.ArrowReadOptions) */ {
 public:
  ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions();
  virtual ~ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions();

  ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions(const ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions& from);

  inline ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions& operator=(const ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions(ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions&& from) noexcept
    : ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions() {
    *this = ::std::move(from);
  }

  inline ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions& operator=(ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions* internal_default_instance() {
    return reinterpret_cast<const ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions*>(
               &_ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions* other);
  friend void swap(ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions& a, ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions* New() const final {
    return CreateMaybeMessage<ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions>(NULL);
  }

  ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions& from);
  void MergeFrom(const ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:substrait.ReadRel.LocalFiles.FileOrFiles.ArrowReadOptions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReadRel_LocalFiles_FileOrFiles_OrcReadOptions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.ReadRel.LocalFiles.FileOrFiles.OrcReadOptions) */ {
 public:
  ReadRel_LocalFiles_FileOrFiles_OrcReadOptions();
  virtual ~ReadRel_LocalFiles_FileOrFiles_OrcReadOptions();

  ReadRel_LocalFiles_FileOrFiles_OrcReadOptions(const ReadRel_LocalFiles_FileOrFiles_OrcReadOptions& from);

  inline ReadRel_LocalFiles_FileOrFiles_OrcReadOptions& operator=(const ReadRel_LocalFiles_FileOrFiles_OrcReadOptions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReadRel_LocalFiles_FileOrFiles_OrcReadOptions(ReadRel_LocalFiles_FileOrFiles_OrcReadOptions&& from) noexcept
    : ReadRel_LocalFiles_FileOrFiles_OrcReadOptions() {
    *this = ::std::move(from);
  }

  inline ReadRel_LocalFiles_FileOrFiles_OrcReadOptions& operator=(ReadRel_LocalFiles_FileOrFiles_OrcReadOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadRel_LocalFiles_FileOrFiles_OrcReadOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadRel_LocalFiles_FileOrFiles_OrcReadOptions* internal_default_instance() {
    return reinterpret_cast<const ReadRel_LocalFiles_FileOrFiles_OrcReadOptions*>(
               &_ReadRel_LocalFiles_FileOrFiles_OrcReadOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(ReadRel_LocalFiles_FileOrFiles_OrcReadOptions* other);
  friend void swap(ReadRel_LocalFiles_FileOrFiles_OrcReadOptions& a, ReadRel_LocalFiles_FileOrFiles_OrcReadOptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReadRel_LocalFiles_FileOrFiles_OrcReadOptions* New() const final {
    return CreateMaybeMessage<ReadRel_LocalFiles_FileOrFiles_OrcReadOptions>(NULL);
  }

  ReadRel_LocalFiles_FileOrFiles_OrcReadOptions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReadRel_LocalFiles_FileOrFiles_OrcReadOptions>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReadRel_LocalFiles_FileOrFiles_OrcReadOptions& from);
  void MergeFrom(const ReadRel_LocalFiles_FileOrFiles_OrcReadOptions& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadRel_LocalFiles_FileOrFiles_OrcReadOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:substrait.ReadRel.LocalFiles.FileOrFiles.OrcReadOptions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.ReadRel.LocalFiles.FileOrFiles.DwrfReadOptions) */ {
 public:
  ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions();
  virtual ~ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions();

  ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions(const ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions& from);

  inline ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions& operator=(const ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions(ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions&& from) noexcept
    : ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions() {
    *this = ::std::move(from);
  }

  inline ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions& operator=(ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions* internal_default_instance() {
    return reinterpret_cast<const ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions*>(
               &_ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions* other);
  friend void swap(ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions& a, ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions* New() const final {
    return CreateMaybeMessage<ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions>(NULL);
  }

  ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions& from);
  void MergeFrom(const ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:substrait.ReadRel.LocalFiles.FileOrFiles.DwrfReadOptions)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReadRel_LocalFiles_FileOrFiles : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.ReadRel.LocalFiles.FileOrFiles) */ {
 public:
  ReadRel_LocalFiles_FileOrFiles();
  virtual ~ReadRel_LocalFiles_FileOrFiles();

  ReadRel_LocalFiles_FileOrFiles(const ReadRel_LocalFiles_FileOrFiles& from);

  inline ReadRel_LocalFiles_FileOrFiles& operator=(const ReadRel_LocalFiles_FileOrFiles& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReadRel_LocalFiles_FileOrFiles(ReadRel_LocalFiles_FileOrFiles&& from) noexcept
    : ReadRel_LocalFiles_FileOrFiles() {
    *this = ::std::move(from);
  }

  inline ReadRel_LocalFiles_FileOrFiles& operator=(ReadRel_LocalFiles_FileOrFiles&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadRel_LocalFiles_FileOrFiles& default_instance();

  enum PathTypeCase {
    kUriPath = 1,
    kUriPathGlob = 2,
    kUriFile = 3,
    kUriFolder = 4,
    PATH_TYPE_NOT_SET = 0,
  };

  enum FileFormatCase {
    kParquet = 9,
    kArrow = 10,
    kOrc = 11,
    kExtension = 12,
    kDwrf = 13,
    FILE_FORMAT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadRel_LocalFiles_FileOrFiles* internal_default_instance() {
    return reinterpret_cast<const ReadRel_LocalFiles_FileOrFiles*>(
               &_ReadRel_LocalFiles_FileOrFiles_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(ReadRel_LocalFiles_FileOrFiles* other);
  friend void swap(ReadRel_LocalFiles_FileOrFiles& a, ReadRel_LocalFiles_FileOrFiles& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReadRel_LocalFiles_FileOrFiles* New() const final {
    return CreateMaybeMessage<ReadRel_LocalFiles_FileOrFiles>(NULL);
  }

  ReadRel_LocalFiles_FileOrFiles* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReadRel_LocalFiles_FileOrFiles>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReadRel_LocalFiles_FileOrFiles& from);
  void MergeFrom(const ReadRel_LocalFiles_FileOrFiles& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadRel_LocalFiles_FileOrFiles* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions ParquetReadOptions;
  typedef ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions ArrowReadOptions;
  typedef ReadRel_LocalFiles_FileOrFiles_OrcReadOptions OrcReadOptions;
  typedef ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions DwrfReadOptions;

  // accessors -------------------------------------------------------

  // uint64 partition_index = 6;
  void clear_partition_index();
  static const int kPartitionIndexFieldNumber = 6;
  ::google::protobuf::uint64 partition_index() const;
  void set_partition_index(::google::protobuf::uint64 value);

  // uint64 start = 7;
  void clear_start();
  static const int kStartFieldNumber = 7;
  ::google::protobuf::uint64 start() const;
  void set_start(::google::protobuf::uint64 value);

  // uint64 length = 8;
  void clear_length();
  static const int kLengthFieldNumber = 8;
  ::google::protobuf::uint64 length() const;
  void set_length(::google::protobuf::uint64 value);

  // string uri_path = 1;
  private:
  bool has_uri_path() const;
  public:
  void clear_uri_path();
  static const int kUriPathFieldNumber = 1;
  const ::std::string& uri_path() const;
  void set_uri_path(const ::std::string& value);
  #if LANG_CXX11
  void set_uri_path(::std::string&& value);
  #endif
  void set_uri_path(const char* value);
  void set_uri_path(const char* value, size_t size);
  ::std::string* mutable_uri_path();
  ::std::string* release_uri_path();
  void set_allocated_uri_path(::std::string* uri_path);

  // string uri_path_glob = 2;
  private:
  bool has_uri_path_glob() const;
  public:
  void clear_uri_path_glob();
  static const int kUriPathGlobFieldNumber = 2;
  const ::std::string& uri_path_glob() const;
  void set_uri_path_glob(const ::std::string& value);
  #if LANG_CXX11
  void set_uri_path_glob(::std::string&& value);
  #endif
  void set_uri_path_glob(const char* value);
  void set_uri_path_glob(const char* value, size_t size);
  ::std::string* mutable_uri_path_glob();
  ::std::string* release_uri_path_glob();
  void set_allocated_uri_path_glob(::std::string* uri_path_glob);

  // string uri_file = 3;
  private:
  bool has_uri_file() const;
  public:
  void clear_uri_file();
  static const int kUriFileFieldNumber = 3;
  const ::std::string& uri_file() const;
  void set_uri_file(const ::std::string& value);
  #if LANG_CXX11
  void set_uri_file(::std::string&& value);
  #endif
  void set_uri_file(const char* value);
  void set_uri_file(const char* value, size_t size);
  ::std::string* mutable_uri_file();
  ::std::string* release_uri_file();
  void set_allocated_uri_file(::std::string* uri_file);

  // string uri_folder = 4;
  private:
  bool has_uri_folder() const;
  public:
  void clear_uri_folder();
  static const int kUriFolderFieldNumber = 4;
  const ::std::string& uri_folder() const;
  void set_uri_folder(const ::std::string& value);
  #if LANG_CXX11
  void set_uri_folder(::std::string&& value);
  #endif
  void set_uri_folder(const char* value);
  void set_uri_folder(const char* value, size_t size);
  ::std::string* mutable_uri_folder();
  ::std::string* release_uri_folder();
  void set_allocated_uri_folder(::std::string* uri_folder);

  // .substrait.ReadRel.LocalFiles.FileOrFiles.ParquetReadOptions parquet = 9;
  bool has_parquet() const;
  void clear_parquet();
  static const int kParquetFieldNumber = 9;
  private:
  const ::substrait::ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions& _internal_parquet() const;
  public:
  const ::substrait::ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions& parquet() const;
  ::substrait::ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions* release_parquet();
  ::substrait::ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions* mutable_parquet();
  void set_allocated_parquet(::substrait::ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions* parquet);

  // .substrait.ReadRel.LocalFiles.FileOrFiles.ArrowReadOptions arrow = 10;
  bool has_arrow() const;
  void clear_arrow();
  static const int kArrowFieldNumber = 10;
  private:
  const ::substrait::ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions& _internal_arrow() const;
  public:
  const ::substrait::ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions& arrow() const;
  ::substrait::ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions* release_arrow();
  ::substrait::ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions* mutable_arrow();
  void set_allocated_arrow(::substrait::ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions* arrow);

  // .substrait.ReadRel.LocalFiles.FileOrFiles.OrcReadOptions orc = 11;
  bool has_orc() const;
  void clear_orc();
  static const int kOrcFieldNumber = 11;
  private:
  const ::substrait::ReadRel_LocalFiles_FileOrFiles_OrcReadOptions& _internal_orc() const;
  public:
  const ::substrait::ReadRel_LocalFiles_FileOrFiles_OrcReadOptions& orc() const;
  ::substrait::ReadRel_LocalFiles_FileOrFiles_OrcReadOptions* release_orc();
  ::substrait::ReadRel_LocalFiles_FileOrFiles_OrcReadOptions* mutable_orc();
  void set_allocated_orc(::substrait::ReadRel_LocalFiles_FileOrFiles_OrcReadOptions* orc);

  // .google.protobuf.Any extension = 12;
  bool has_extension() const;
  void clear_extension();
  static const int kExtensionFieldNumber = 12;
  private:
  const ::google::protobuf::Any& _internal_extension() const;
  public:
  const ::google::protobuf::Any& extension() const;
  ::google::protobuf::Any* release_extension();
  ::google::protobuf::Any* mutable_extension();
  void set_allocated_extension(::google::protobuf::Any* extension);

  // .substrait.ReadRel.LocalFiles.FileOrFiles.DwrfReadOptions dwrf = 13;
  bool has_dwrf() const;
  void clear_dwrf();
  static const int kDwrfFieldNumber = 13;
  private:
  const ::substrait::ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions& _internal_dwrf() const;
  public:
  const ::substrait::ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions& dwrf() const;
  ::substrait::ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions* release_dwrf();
  ::substrait::ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions* mutable_dwrf();
  void set_allocated_dwrf(::substrait::ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions* dwrf);

  void clear_path_type();
  PathTypeCase path_type_case() const;
  void clear_file_format();
  FileFormatCase file_format_case() const;
  // @@protoc_insertion_point(class_scope:substrait.ReadRel.LocalFiles.FileOrFiles)
 private:
  void set_has_uri_path();
  void set_has_uri_path_glob();
  void set_has_uri_file();
  void set_has_uri_folder();
  void set_has_parquet();
  void set_has_arrow();
  void set_has_orc();
  void set_has_extension();
  void set_has_dwrf();

  inline bool has_path_type() const;
  inline void clear_has_path_type();

  inline bool has_file_format() const;
  inline void clear_has_file_format();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 partition_index_;
  ::google::protobuf::uint64 start_;
  ::google::protobuf::uint64 length_;
  union PathTypeUnion {
    PathTypeUnion() {}
    ::google::protobuf::internal::ArenaStringPtr uri_path_;
    ::google::protobuf::internal::ArenaStringPtr uri_path_glob_;
    ::google::protobuf::internal::ArenaStringPtr uri_file_;
    ::google::protobuf::internal::ArenaStringPtr uri_folder_;
  } path_type_;
  union FileFormatUnion {
    FileFormatUnion() {}
    ::substrait::ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions* parquet_;
    ::substrait::ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions* arrow_;
    ::substrait::ReadRel_LocalFiles_FileOrFiles_OrcReadOptions* orc_;
    ::google::protobuf::Any* extension_;
    ::substrait::ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions* dwrf_;
  } file_format_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[2];

  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReadRel_LocalFiles : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.ReadRel.LocalFiles) */ {
 public:
  ReadRel_LocalFiles();
  virtual ~ReadRel_LocalFiles();

  ReadRel_LocalFiles(const ReadRel_LocalFiles& from);

  inline ReadRel_LocalFiles& operator=(const ReadRel_LocalFiles& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReadRel_LocalFiles(ReadRel_LocalFiles&& from) noexcept
    : ReadRel_LocalFiles() {
    *this = ::std::move(from);
  }

  inline ReadRel_LocalFiles& operator=(ReadRel_LocalFiles&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadRel_LocalFiles& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadRel_LocalFiles* internal_default_instance() {
    return reinterpret_cast<const ReadRel_LocalFiles*>(
               &_ReadRel_LocalFiles_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(ReadRel_LocalFiles* other);
  friend void swap(ReadRel_LocalFiles& a, ReadRel_LocalFiles& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReadRel_LocalFiles* New() const final {
    return CreateMaybeMessage<ReadRel_LocalFiles>(NULL);
  }

  ReadRel_LocalFiles* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReadRel_LocalFiles>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReadRel_LocalFiles& from);
  void MergeFrom(const ReadRel_LocalFiles& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadRel_LocalFiles* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ReadRel_LocalFiles_FileOrFiles FileOrFiles;

  // accessors -------------------------------------------------------

  // repeated .substrait.ReadRel.LocalFiles.FileOrFiles items = 1;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 1;
  ::substrait::ReadRel_LocalFiles_FileOrFiles* mutable_items(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::ReadRel_LocalFiles_FileOrFiles >*
      mutable_items();
  const ::substrait::ReadRel_LocalFiles_FileOrFiles& items(int index) const;
  ::substrait::ReadRel_LocalFiles_FileOrFiles* add_items();
  const ::google::protobuf::RepeatedPtrField< ::substrait::ReadRel_LocalFiles_FileOrFiles >&
      items() const;

  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension();
  static const int kAdvancedExtensionFieldNumber = 10;
  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  public:
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension);

  // @@protoc_insertion_point(class_scope:substrait.ReadRel.LocalFiles)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::substrait::ReadRel_LocalFiles_FileOrFiles > items_;
  ::substrait::extensions::AdvancedExtension* advanced_extension_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReadRel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.ReadRel) */ {
 public:
  ReadRel();
  virtual ~ReadRel();

  ReadRel(const ReadRel& from);

  inline ReadRel& operator=(const ReadRel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReadRel(ReadRel&& from) noexcept
    : ReadRel() {
    *this = ::std::move(from);
  }

  inline ReadRel& operator=(ReadRel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadRel& default_instance();

  enum ReadTypeCase {
    kVirtualTable = 5,
    kLocalFiles = 6,
    kNamedTable = 7,
    kExtensionTable = 8,
    READ_TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadRel* internal_default_instance() {
    return reinterpret_cast<const ReadRel*>(
               &_ReadRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(ReadRel* other);
  friend void swap(ReadRel& a, ReadRel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReadRel* New() const final {
    return CreateMaybeMessage<ReadRel>(NULL);
  }

  ReadRel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReadRel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReadRel& from);
  void MergeFrom(const ReadRel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadRel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ReadRel_NamedTable NamedTable;
  typedef ReadRel_VirtualTable VirtualTable;
  typedef ReadRel_ExtensionTable ExtensionTable;
  typedef ReadRel_LocalFiles LocalFiles;

  // accessors -------------------------------------------------------

  // .substrait.RelCommon common = 1;
  bool has_common() const;
  void clear_common();
  static const int kCommonFieldNumber = 1;
  private:
  const ::substrait::RelCommon& _internal_common() const;
  public:
  const ::substrait::RelCommon& common() const;
  ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* common);

  // .substrait.NamedStruct base_schema = 2;
  bool has_base_schema() const;
  void clear_base_schema();
  static const int kBaseSchemaFieldNumber = 2;
  private:
  const ::substrait::NamedStruct& _internal_base_schema() const;
  public:
  const ::substrait::NamedStruct& base_schema() const;
  ::substrait::NamedStruct* release_base_schema();
  ::substrait::NamedStruct* mutable_base_schema();
  void set_allocated_base_schema(::substrait::NamedStruct* base_schema);

  // .substrait.Expression filter = 3;
  bool has_filter() const;
  void clear_filter();
  static const int kFilterFieldNumber = 3;
  private:
  const ::substrait::Expression& _internal_filter() const;
  public:
  const ::substrait::Expression& filter() const;
  ::substrait::Expression* release_filter();
  ::substrait::Expression* mutable_filter();
  void set_allocated_filter(::substrait::Expression* filter);

  // .substrait.Expression.MaskExpression projection = 4;
  bool has_projection() const;
  void clear_projection();
  static const int kProjectionFieldNumber = 4;
  private:
  const ::substrait::Expression_MaskExpression& _internal_projection() const;
  public:
  const ::substrait::Expression_MaskExpression& projection() const;
  ::substrait::Expression_MaskExpression* release_projection();
  ::substrait::Expression_MaskExpression* mutable_projection();
  void set_allocated_projection(::substrait::Expression_MaskExpression* projection);

  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension();
  static const int kAdvancedExtensionFieldNumber = 10;
  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  public:
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension);

  // .substrait.Expression best_effort_filter = 11;
  bool has_best_effort_filter() const;
  void clear_best_effort_filter();
  static const int kBestEffortFilterFieldNumber = 11;
  private:
  const ::substrait::Expression& _internal_best_effort_filter() const;
  public:
  const ::substrait::Expression& best_effort_filter() const;
  ::substrait::Expression* release_best_effort_filter();
  ::substrait::Expression* mutable_best_effort_filter();
  void set_allocated_best_effort_filter(::substrait::Expression* best_effort_filter);

  // .substrait.ReadRel.VirtualTable virtual_table = 5;
  bool has_virtual_table() const;
  void clear_virtual_table();
  static const int kVirtualTableFieldNumber = 5;
  private:
  const ::substrait::ReadRel_VirtualTable& _internal_virtual_table() const;
  public:
  const ::substrait::ReadRel_VirtualTable& virtual_table() const;
  ::substrait::ReadRel_VirtualTable* release_virtual_table();
  ::substrait::ReadRel_VirtualTable* mutable_virtual_table();
  void set_allocated_virtual_table(::substrait::ReadRel_VirtualTable* virtual_table);

  // .substrait.ReadRel.LocalFiles local_files = 6;
  bool has_local_files() const;
  void clear_local_files();
  static const int kLocalFilesFieldNumber = 6;
  private:
  const ::substrait::ReadRel_LocalFiles& _internal_local_files() const;
  public:
  const ::substrait::ReadRel_LocalFiles& local_files() const;
  ::substrait::ReadRel_LocalFiles* release_local_files();
  ::substrait::ReadRel_LocalFiles* mutable_local_files();
  void set_allocated_local_files(::substrait::ReadRel_LocalFiles* local_files);

  // .substrait.ReadRel.NamedTable named_table = 7;
  bool has_named_table() const;
  void clear_named_table();
  static const int kNamedTableFieldNumber = 7;
  private:
  const ::substrait::ReadRel_NamedTable& _internal_named_table() const;
  public:
  const ::substrait::ReadRel_NamedTable& named_table() const;
  ::substrait::ReadRel_NamedTable* release_named_table();
  ::substrait::ReadRel_NamedTable* mutable_named_table();
  void set_allocated_named_table(::substrait::ReadRel_NamedTable* named_table);

  // .substrait.ReadRel.ExtensionTable extension_table = 8;
  bool has_extension_table() const;
  void clear_extension_table();
  static const int kExtensionTableFieldNumber = 8;
  private:
  const ::substrait::ReadRel_ExtensionTable& _internal_extension_table() const;
  public:
  const ::substrait::ReadRel_ExtensionTable& extension_table() const;
  ::substrait::ReadRel_ExtensionTable* release_extension_table();
  ::substrait::ReadRel_ExtensionTable* mutable_extension_table();
  void set_allocated_extension_table(::substrait::ReadRel_ExtensionTable* extension_table);

  void clear_read_type();
  ReadTypeCase read_type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.ReadRel)
 private:
  void set_has_virtual_table();
  void set_has_local_files();
  void set_has_named_table();
  void set_has_extension_table();

  inline bool has_read_type() const;
  inline void clear_has_read_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::substrait::RelCommon* common_;
  ::substrait::NamedStruct* base_schema_;
  ::substrait::Expression* filter_;
  ::substrait::Expression_MaskExpression* projection_;
  ::substrait::extensions::AdvancedExtension* advanced_extension_;
  ::substrait::Expression* best_effort_filter_;
  union ReadTypeUnion {
    ReadTypeUnion() {}
    ::substrait::ReadRel_VirtualTable* virtual_table_;
    ::substrait::ReadRel_LocalFiles* local_files_;
    ::substrait::ReadRel_NamedTable* named_table_;
    ::substrait::ReadRel_ExtensionTable* extension_table_;
  } read_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProjectRel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.ProjectRel) */ {
 public:
  ProjectRel();
  virtual ~ProjectRel();

  ProjectRel(const ProjectRel& from);

  inline ProjectRel& operator=(const ProjectRel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProjectRel(ProjectRel&& from) noexcept
    : ProjectRel() {
    *this = ::std::move(from);
  }

  inline ProjectRel& operator=(ProjectRel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProjectRel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProjectRel* internal_default_instance() {
    return reinterpret_cast<const ProjectRel*>(
               &_ProjectRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(ProjectRel* other);
  friend void swap(ProjectRel& a, ProjectRel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProjectRel* New() const final {
    return CreateMaybeMessage<ProjectRel>(NULL);
  }

  ProjectRel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProjectRel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProjectRel& from);
  void MergeFrom(const ProjectRel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProjectRel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .substrait.Expression expressions = 3;
  int expressions_size() const;
  void clear_expressions();
  static const int kExpressionsFieldNumber = 3;
  ::substrait::Expression* mutable_expressions(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression >*
      mutable_expressions();
  const ::substrait::Expression& expressions(int index) const;
  ::substrait::Expression* add_expressions();
  const ::google::protobuf::RepeatedPtrField< ::substrait::Expression >&
      expressions() const;

  // .substrait.RelCommon common = 1;
  bool has_common() const;
  void clear_common();
  static const int kCommonFieldNumber = 1;
  private:
  const ::substrait::RelCommon& _internal_common() const;
  public:
  const ::substrait::RelCommon& common() const;
  ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* common);

  // .substrait.Rel input = 2;
  bool has_input() const;
  void clear_input();
  static const int kInputFieldNumber = 2;
  private:
  const ::substrait::Rel& _internal_input() const;
  public:
  const ::substrait::Rel& input() const;
  ::substrait::Rel* release_input();
  ::substrait::Rel* mutable_input();
  void set_allocated_input(::substrait::Rel* input);

  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension();
  static const int kAdvancedExtensionFieldNumber = 10;
  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  public:
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension);

  // @@protoc_insertion_point(class_scope:substrait.ProjectRel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression > expressions_;
  ::substrait::RelCommon* common_;
  ::substrait::Rel* input_;
  ::substrait::extensions::AdvancedExtension* advanced_extension_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class JoinRel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.JoinRel) */ {
 public:
  JoinRel();
  virtual ~JoinRel();

  JoinRel(const JoinRel& from);

  inline JoinRel& operator=(const JoinRel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JoinRel(JoinRel&& from) noexcept
    : JoinRel() {
    *this = ::std::move(from);
  }

  inline JoinRel& operator=(JoinRel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinRel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JoinRel* internal_default_instance() {
    return reinterpret_cast<const JoinRel*>(
               &_JoinRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(JoinRel* other);
  friend void swap(JoinRel& a, JoinRel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JoinRel* New() const final {
    return CreateMaybeMessage<JoinRel>(NULL);
  }

  JoinRel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JoinRel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JoinRel& from);
  void MergeFrom(const JoinRel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinRel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef JoinRel_JoinType JoinType;
  static const JoinType JOIN_TYPE_UNSPECIFIED =
    JoinRel_JoinType_JOIN_TYPE_UNSPECIFIED;
  static const JoinType JOIN_TYPE_INNER =
    JoinRel_JoinType_JOIN_TYPE_INNER;
  static const JoinType JOIN_TYPE_OUTER =
    JoinRel_JoinType_JOIN_TYPE_OUTER;
  static const JoinType JOIN_TYPE_LEFT =
    JoinRel_JoinType_JOIN_TYPE_LEFT;
  static const JoinType JOIN_TYPE_RIGHT =
    JoinRel_JoinType_JOIN_TYPE_RIGHT;
  static const JoinType JOIN_TYPE_SEMI =
    JoinRel_JoinType_JOIN_TYPE_SEMI;
  static const JoinType JOIN_TYPE_ANTI =
    JoinRel_JoinType_JOIN_TYPE_ANTI;
  static const JoinType JOIN_TYPE_SINGLE =
    JoinRel_JoinType_JOIN_TYPE_SINGLE;
  static inline bool JoinType_IsValid(int value) {
    return JoinRel_JoinType_IsValid(value);
  }
  static const JoinType JoinType_MIN =
    JoinRel_JoinType_JoinType_MIN;
  static const JoinType JoinType_MAX =
    JoinRel_JoinType_JoinType_MAX;
  static const int JoinType_ARRAYSIZE =
    JoinRel_JoinType_JoinType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  JoinType_descriptor() {
    return JoinRel_JoinType_descriptor();
  }
  static inline const ::std::string& JoinType_Name(JoinType value) {
    return JoinRel_JoinType_Name(value);
  }
  static inline bool JoinType_Parse(const ::std::string& name,
      JoinType* value) {
    return JoinRel_JoinType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .substrait.RelCommon common = 1;
  bool has_common() const;
  void clear_common();
  static const int kCommonFieldNumber = 1;
  private:
  const ::substrait::RelCommon& _internal_common() const;
  public:
  const ::substrait::RelCommon& common() const;
  ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* common);

  // .substrait.Rel left = 2;
  bool has_left() const;
  void clear_left();
  static const int kLeftFieldNumber = 2;
  private:
  const ::substrait::Rel& _internal_left() const;
  public:
  const ::substrait::Rel& left() const;
  ::substrait::Rel* release_left();
  ::substrait::Rel* mutable_left();
  void set_allocated_left(::substrait::Rel* left);

  // .substrait.Rel right = 3;
  bool has_right() const;
  void clear_right();
  static const int kRightFieldNumber = 3;
  private:
  const ::substrait::Rel& _internal_right() const;
  public:
  const ::substrait::Rel& right() const;
  ::substrait::Rel* release_right();
  ::substrait::Rel* mutable_right();
  void set_allocated_right(::substrait::Rel* right);

  // .substrait.Expression expression = 4;
  bool has_expression() const;
  void clear_expression();
  static const int kExpressionFieldNumber = 4;
  private:
  const ::substrait::Expression& _internal_expression() const;
  public:
  const ::substrait::Expression& expression() const;
  ::substrait::Expression* release_expression();
  ::substrait::Expression* mutable_expression();
  void set_allocated_expression(::substrait::Expression* expression);

  // .substrait.Expression post_join_filter = 5;
  bool has_post_join_filter() const;
  void clear_post_join_filter();
  static const int kPostJoinFilterFieldNumber = 5;
  private:
  const ::substrait::Expression& _internal_post_join_filter() const;
  public:
  const ::substrait::Expression& post_join_filter() const;
  ::substrait::Expression* release_post_join_filter();
  ::substrait::Expression* mutable_post_join_filter();
  void set_allocated_post_join_filter(::substrait::Expression* post_join_filter);

  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension();
  static const int kAdvancedExtensionFieldNumber = 10;
  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  public:
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension);

  // .substrait.JoinRel.JoinType type = 6;
  void clear_type();
  static const int kTypeFieldNumber = 6;
  ::substrait::JoinRel_JoinType type() const;
  void set_type(::substrait::JoinRel_JoinType value);

  // @@protoc_insertion_point(class_scope:substrait.JoinRel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::substrait::RelCommon* common_;
  ::substrait::Rel* left_;
  ::substrait::Rel* right_;
  ::substrait::Expression* expression_;
  ::substrait::Expression* post_join_filter_;
  ::substrait::extensions::AdvancedExtension* advanced_extension_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CrossRel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.CrossRel) */ {
 public:
  CrossRel();
  virtual ~CrossRel();

  CrossRel(const CrossRel& from);

  inline CrossRel& operator=(const CrossRel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CrossRel(CrossRel&& from) noexcept
    : CrossRel() {
    *this = ::std::move(from);
  }

  inline CrossRel& operator=(CrossRel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CrossRel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CrossRel* internal_default_instance() {
    return reinterpret_cast<const CrossRel*>(
               &_CrossRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(CrossRel* other);
  friend void swap(CrossRel& a, CrossRel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CrossRel* New() const final {
    return CreateMaybeMessage<CrossRel>(NULL);
  }

  CrossRel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CrossRel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CrossRel& from);
  void MergeFrom(const CrossRel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CrossRel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .substrait.RelCommon common = 1;
  bool has_common() const;
  void clear_common();
  static const int kCommonFieldNumber = 1;
  private:
  const ::substrait::RelCommon& _internal_common() const;
  public:
  const ::substrait::RelCommon& common() const;
  ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* common);

  // .substrait.Rel left = 2;
  bool has_left() const;
  void clear_left();
  static const int kLeftFieldNumber = 2;
  private:
  const ::substrait::Rel& _internal_left() const;
  public:
  const ::substrait::Rel& left() const;
  ::substrait::Rel* release_left();
  ::substrait::Rel* mutable_left();
  void set_allocated_left(::substrait::Rel* left);

  // .substrait.Rel right = 3;
  bool has_right() const;
  void clear_right();
  static const int kRightFieldNumber = 3;
  private:
  const ::substrait::Rel& _internal_right() const;
  public:
  const ::substrait::Rel& right() const;
  ::substrait::Rel* release_right();
  ::substrait::Rel* mutable_right();
  void set_allocated_right(::substrait::Rel* right);

  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension();
  static const int kAdvancedExtensionFieldNumber = 10;
  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  public:
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension);

  // @@protoc_insertion_point(class_scope:substrait.CrossRel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::substrait::RelCommon* common_;
  ::substrait::Rel* left_;
  ::substrait::Rel* right_;
  ::substrait::extensions::AdvancedExtension* advanced_extension_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FetchRel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.FetchRel) */ {
 public:
  FetchRel();
  virtual ~FetchRel();

  FetchRel(const FetchRel& from);

  inline FetchRel& operator=(const FetchRel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FetchRel(FetchRel&& from) noexcept
    : FetchRel() {
    *this = ::std::move(from);
  }

  inline FetchRel& operator=(FetchRel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FetchRel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FetchRel* internal_default_instance() {
    return reinterpret_cast<const FetchRel*>(
               &_FetchRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(FetchRel* other);
  friend void swap(FetchRel& a, FetchRel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FetchRel* New() const final {
    return CreateMaybeMessage<FetchRel>(NULL);
  }

  FetchRel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FetchRel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FetchRel& from);
  void MergeFrom(const FetchRel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FetchRel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .substrait.RelCommon common = 1;
  bool has_common() const;
  void clear_common();
  static const int kCommonFieldNumber = 1;
  private:
  const ::substrait::RelCommon& _internal_common() const;
  public:
  const ::substrait::RelCommon& common() const;
  ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* common);

  // .substrait.Rel input = 2;
  bool has_input() const;
  void clear_input();
  static const int kInputFieldNumber = 2;
  private:
  const ::substrait::Rel& _internal_input() const;
  public:
  const ::substrait::Rel& input() const;
  ::substrait::Rel* release_input();
  ::substrait::Rel* mutable_input();
  void set_allocated_input(::substrait::Rel* input);

  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension();
  static const int kAdvancedExtensionFieldNumber = 10;
  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  public:
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension);

  // int64 offset = 3;
  void clear_offset();
  static const int kOffsetFieldNumber = 3;
  ::google::protobuf::int64 offset() const;
  void set_offset(::google::protobuf::int64 value);

  // int64 count = 4;
  void clear_count();
  static const int kCountFieldNumber = 4;
  ::google::protobuf::int64 count() const;
  void set_count(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:substrait.FetchRel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::substrait::RelCommon* common_;
  ::substrait::Rel* input_;
  ::substrait::extensions::AdvancedExtension* advanced_extension_;
  ::google::protobuf::int64 offset_;
  ::google::protobuf::int64 count_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AggregateRel_Grouping : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.AggregateRel.Grouping) */ {
 public:
  AggregateRel_Grouping();
  virtual ~AggregateRel_Grouping();

  AggregateRel_Grouping(const AggregateRel_Grouping& from);

  inline AggregateRel_Grouping& operator=(const AggregateRel_Grouping& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AggregateRel_Grouping(AggregateRel_Grouping&& from) noexcept
    : AggregateRel_Grouping() {
    *this = ::std::move(from);
  }

  inline AggregateRel_Grouping& operator=(AggregateRel_Grouping&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AggregateRel_Grouping& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AggregateRel_Grouping* internal_default_instance() {
    return reinterpret_cast<const AggregateRel_Grouping*>(
               &_AggregateRel_Grouping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(AggregateRel_Grouping* other);
  friend void swap(AggregateRel_Grouping& a, AggregateRel_Grouping& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AggregateRel_Grouping* New() const final {
    return CreateMaybeMessage<AggregateRel_Grouping>(NULL);
  }

  AggregateRel_Grouping* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AggregateRel_Grouping>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AggregateRel_Grouping& from);
  void MergeFrom(const AggregateRel_Grouping& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AggregateRel_Grouping* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .substrait.Expression grouping_expressions = 1;
  int grouping_expressions_size() const;
  void clear_grouping_expressions();
  static const int kGroupingExpressionsFieldNumber = 1;
  ::substrait::Expression* mutable_grouping_expressions(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression >*
      mutable_grouping_expressions();
  const ::substrait::Expression& grouping_expressions(int index) const;
  ::substrait::Expression* add_grouping_expressions();
  const ::google::protobuf::RepeatedPtrField< ::substrait::Expression >&
      grouping_expressions() const;

  // @@protoc_insertion_point(class_scope:substrait.AggregateRel.Grouping)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression > grouping_expressions_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AggregateRel_Measure : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.AggregateRel.Measure) */ {
 public:
  AggregateRel_Measure();
  virtual ~AggregateRel_Measure();

  AggregateRel_Measure(const AggregateRel_Measure& from);

  inline AggregateRel_Measure& operator=(const AggregateRel_Measure& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AggregateRel_Measure(AggregateRel_Measure&& from) noexcept
    : AggregateRel_Measure() {
    *this = ::std::move(from);
  }

  inline AggregateRel_Measure& operator=(AggregateRel_Measure&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AggregateRel_Measure& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AggregateRel_Measure* internal_default_instance() {
    return reinterpret_cast<const AggregateRel_Measure*>(
               &_AggregateRel_Measure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(AggregateRel_Measure* other);
  friend void swap(AggregateRel_Measure& a, AggregateRel_Measure& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AggregateRel_Measure* New() const final {
    return CreateMaybeMessage<AggregateRel_Measure>(NULL);
  }

  AggregateRel_Measure* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AggregateRel_Measure>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AggregateRel_Measure& from);
  void MergeFrom(const AggregateRel_Measure& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AggregateRel_Measure* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .substrait.AggregateFunction measure = 1;
  bool has_measure() const;
  void clear_measure();
  static const int kMeasureFieldNumber = 1;
  private:
  const ::substrait::AggregateFunction& _internal_measure() const;
  public:
  const ::substrait::AggregateFunction& measure() const;
  ::substrait::AggregateFunction* release_measure();
  ::substrait::AggregateFunction* mutable_measure();
  void set_allocated_measure(::substrait::AggregateFunction* measure);

  // .substrait.Expression filter = 2;
  bool has_filter() const;
  void clear_filter();
  static const int kFilterFieldNumber = 2;
  private:
  const ::substrait::Expression& _internal_filter() const;
  public:
  const ::substrait::Expression& filter() const;
  ::substrait::Expression* release_filter();
  ::substrait::Expression* mutable_filter();
  void set_allocated_filter(::substrait::Expression* filter);

  // @@protoc_insertion_point(class_scope:substrait.AggregateRel.Measure)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::substrait::AggregateFunction* measure_;
  ::substrait::Expression* filter_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AggregateRel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.AggregateRel) */ {
 public:
  AggregateRel();
  virtual ~AggregateRel();

  AggregateRel(const AggregateRel& from);

  inline AggregateRel& operator=(const AggregateRel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AggregateRel(AggregateRel&& from) noexcept
    : AggregateRel() {
    *this = ::std::move(from);
  }

  inline AggregateRel& operator=(AggregateRel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AggregateRel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AggregateRel* internal_default_instance() {
    return reinterpret_cast<const AggregateRel*>(
               &_AggregateRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(AggregateRel* other);
  friend void swap(AggregateRel& a, AggregateRel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AggregateRel* New() const final {
    return CreateMaybeMessage<AggregateRel>(NULL);
  }

  AggregateRel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AggregateRel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AggregateRel& from);
  void MergeFrom(const AggregateRel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AggregateRel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AggregateRel_Grouping Grouping;
  typedef AggregateRel_Measure Measure;

  // accessors -------------------------------------------------------

  // repeated .substrait.AggregateRel.Grouping groupings = 3;
  int groupings_size() const;
  void clear_groupings();
  static const int kGroupingsFieldNumber = 3;
  ::substrait::AggregateRel_Grouping* mutable_groupings(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::AggregateRel_Grouping >*
      mutable_groupings();
  const ::substrait::AggregateRel_Grouping& groupings(int index) const;
  ::substrait::AggregateRel_Grouping* add_groupings();
  const ::google::protobuf::RepeatedPtrField< ::substrait::AggregateRel_Grouping >&
      groupings() const;

  // repeated .substrait.AggregateRel.Measure measures = 4;
  int measures_size() const;
  void clear_measures();
  static const int kMeasuresFieldNumber = 4;
  ::substrait::AggregateRel_Measure* mutable_measures(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::AggregateRel_Measure >*
      mutable_measures();
  const ::substrait::AggregateRel_Measure& measures(int index) const;
  ::substrait::AggregateRel_Measure* add_measures();
  const ::google::protobuf::RepeatedPtrField< ::substrait::AggregateRel_Measure >&
      measures() const;

  // .substrait.RelCommon common = 1;
  bool has_common() const;
  void clear_common();
  static const int kCommonFieldNumber = 1;
  private:
  const ::substrait::RelCommon& _internal_common() const;
  public:
  const ::substrait::RelCommon& common() const;
  ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* common);

  // .substrait.Rel input = 2;
  bool has_input() const;
  void clear_input();
  static const int kInputFieldNumber = 2;
  private:
  const ::substrait::Rel& _internal_input() const;
  public:
  const ::substrait::Rel& input() const;
  ::substrait::Rel* release_input();
  ::substrait::Rel* mutable_input();
  void set_allocated_input(::substrait::Rel* input);

  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension();
  static const int kAdvancedExtensionFieldNumber = 10;
  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  public:
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension);

  // @@protoc_insertion_point(class_scope:substrait.AggregateRel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::substrait::AggregateRel_Grouping > groupings_;
  ::google::protobuf::RepeatedPtrField< ::substrait::AggregateRel_Measure > measures_;
  ::substrait::RelCommon* common_;
  ::substrait::Rel* input_;
  ::substrait::extensions::AdvancedExtension* advanced_extension_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SortRel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.SortRel) */ {
 public:
  SortRel();
  virtual ~SortRel();

  SortRel(const SortRel& from);

  inline SortRel& operator=(const SortRel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SortRel(SortRel&& from) noexcept
    : SortRel() {
    *this = ::std::move(from);
  }

  inline SortRel& operator=(SortRel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SortRel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SortRel* internal_default_instance() {
    return reinterpret_cast<const SortRel*>(
               &_SortRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(SortRel* other);
  friend void swap(SortRel& a, SortRel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SortRel* New() const final {
    return CreateMaybeMessage<SortRel>(NULL);
  }

  SortRel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SortRel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SortRel& from);
  void MergeFrom(const SortRel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SortRel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .substrait.SortField sorts = 3;
  int sorts_size() const;
  void clear_sorts();
  static const int kSortsFieldNumber = 3;
  ::substrait::SortField* mutable_sorts(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::SortField >*
      mutable_sorts();
  const ::substrait::SortField& sorts(int index) const;
  ::substrait::SortField* add_sorts();
  const ::google::protobuf::RepeatedPtrField< ::substrait::SortField >&
      sorts() const;

  // .substrait.RelCommon common = 1;
  bool has_common() const;
  void clear_common();
  static const int kCommonFieldNumber = 1;
  private:
  const ::substrait::RelCommon& _internal_common() const;
  public:
  const ::substrait::RelCommon& common() const;
  ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* common);

  // .substrait.Rel input = 2;
  bool has_input() const;
  void clear_input();
  static const int kInputFieldNumber = 2;
  private:
  const ::substrait::Rel& _internal_input() const;
  public:
  const ::substrait::Rel& input() const;
  ::substrait::Rel* release_input();
  ::substrait::Rel* mutable_input();
  void set_allocated_input(::substrait::Rel* input);

  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension();
  static const int kAdvancedExtensionFieldNumber = 10;
  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  public:
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension);

  // @@protoc_insertion_point(class_scope:substrait.SortRel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::substrait::SortField > sorts_;
  ::substrait::RelCommon* common_;
  ::substrait::Rel* input_;
  ::substrait::extensions::AdvancedExtension* advanced_extension_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FilterRel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.FilterRel) */ {
 public:
  FilterRel();
  virtual ~FilterRel();

  FilterRel(const FilterRel& from);

  inline FilterRel& operator=(const FilterRel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FilterRel(FilterRel&& from) noexcept
    : FilterRel() {
    *this = ::std::move(from);
  }

  inline FilterRel& operator=(FilterRel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FilterRel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FilterRel* internal_default_instance() {
    return reinterpret_cast<const FilterRel*>(
               &_FilterRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(FilterRel* other);
  friend void swap(FilterRel& a, FilterRel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FilterRel* New() const final {
    return CreateMaybeMessage<FilterRel>(NULL);
  }

  FilterRel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FilterRel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FilterRel& from);
  void MergeFrom(const FilterRel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FilterRel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .substrait.RelCommon common = 1;
  bool has_common() const;
  void clear_common();
  static const int kCommonFieldNumber = 1;
  private:
  const ::substrait::RelCommon& _internal_common() const;
  public:
  const ::substrait::RelCommon& common() const;
  ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* common);

  // .substrait.Rel input = 2;
  bool has_input() const;
  void clear_input();
  static const int kInputFieldNumber = 2;
  private:
  const ::substrait::Rel& _internal_input() const;
  public:
  const ::substrait::Rel& input() const;
  ::substrait::Rel* release_input();
  ::substrait::Rel* mutable_input();
  void set_allocated_input(::substrait::Rel* input);

  // .substrait.Expression condition = 3;
  bool has_condition() const;
  void clear_condition();
  static const int kConditionFieldNumber = 3;
  private:
  const ::substrait::Expression& _internal_condition() const;
  public:
  const ::substrait::Expression& condition() const;
  ::substrait::Expression* release_condition();
  ::substrait::Expression* mutable_condition();
  void set_allocated_condition(::substrait::Expression* condition);

  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension();
  static const int kAdvancedExtensionFieldNumber = 10;
  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  public:
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension);

  // @@protoc_insertion_point(class_scope:substrait.FilterRel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::substrait::RelCommon* common_;
  ::substrait::Rel* input_;
  ::substrait::Expression* condition_;
  ::substrait::extensions::AdvancedExtension* advanced_extension_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetRel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.SetRel) */ {
 public:
  SetRel();
  virtual ~SetRel();

  SetRel(const SetRel& from);

  inline SetRel& operator=(const SetRel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetRel(SetRel&& from) noexcept
    : SetRel() {
    *this = ::std::move(from);
  }

  inline SetRel& operator=(SetRel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetRel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetRel* internal_default_instance() {
    return reinterpret_cast<const SetRel*>(
               &_SetRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(SetRel* other);
  friend void swap(SetRel& a, SetRel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetRel* New() const final {
    return CreateMaybeMessage<SetRel>(NULL);
  }

  SetRel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetRel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetRel& from);
  void MergeFrom(const SetRel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetRel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SetRel_SetOp SetOp;
  static const SetOp SET_OP_UNSPECIFIED =
    SetRel_SetOp_SET_OP_UNSPECIFIED;
  static const SetOp SET_OP_MINUS_PRIMARY =
    SetRel_SetOp_SET_OP_MINUS_PRIMARY;
  static const SetOp SET_OP_MINUS_MULTISET =
    SetRel_SetOp_SET_OP_MINUS_MULTISET;
  static const SetOp SET_OP_INTERSECTION_PRIMARY =
    SetRel_SetOp_SET_OP_INTERSECTION_PRIMARY;
  static const SetOp SET_OP_INTERSECTION_MULTISET =
    SetRel_SetOp_SET_OP_INTERSECTION_MULTISET;
  static const SetOp SET_OP_UNION_DISTINCT =
    SetRel_SetOp_SET_OP_UNION_DISTINCT;
  static const SetOp SET_OP_UNION_ALL =
    SetRel_SetOp_SET_OP_UNION_ALL;
  static inline bool SetOp_IsValid(int value) {
    return SetRel_SetOp_IsValid(value);
  }
  static const SetOp SetOp_MIN =
    SetRel_SetOp_SetOp_MIN;
  static const SetOp SetOp_MAX =
    SetRel_SetOp_SetOp_MAX;
  static const int SetOp_ARRAYSIZE =
    SetRel_SetOp_SetOp_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SetOp_descriptor() {
    return SetRel_SetOp_descriptor();
  }
  static inline const ::std::string& SetOp_Name(SetOp value) {
    return SetRel_SetOp_Name(value);
  }
  static inline bool SetOp_Parse(const ::std::string& name,
      SetOp* value) {
    return SetRel_SetOp_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .substrait.Rel inputs = 2;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 2;
  ::substrait::Rel* mutable_inputs(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::Rel >*
      mutable_inputs();
  const ::substrait::Rel& inputs(int index) const;
  ::substrait::Rel* add_inputs();
  const ::google::protobuf::RepeatedPtrField< ::substrait::Rel >&
      inputs() const;

  // .substrait.RelCommon common = 1;
  bool has_common() const;
  void clear_common();
  static const int kCommonFieldNumber = 1;
  private:
  const ::substrait::RelCommon& _internal_common() const;
  public:
  const ::substrait::RelCommon& common() const;
  ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* common);

  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension();
  static const int kAdvancedExtensionFieldNumber = 10;
  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  public:
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension);

  // .substrait.SetRel.SetOp op = 3;
  void clear_op();
  static const int kOpFieldNumber = 3;
  ::substrait::SetRel_SetOp op() const;
  void set_op(::substrait::SetRel_SetOp value);

  // @@protoc_insertion_point(class_scope:substrait.SetRel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::substrait::Rel > inputs_;
  ::substrait::RelCommon* common_;
  ::substrait::extensions::AdvancedExtension* advanced_extension_;
  int op_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExtensionSingleRel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.ExtensionSingleRel) */ {
 public:
  ExtensionSingleRel();
  virtual ~ExtensionSingleRel();

  ExtensionSingleRel(const ExtensionSingleRel& from);

  inline ExtensionSingleRel& operator=(const ExtensionSingleRel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExtensionSingleRel(ExtensionSingleRel&& from) noexcept
    : ExtensionSingleRel() {
    *this = ::std::move(from);
  }

  inline ExtensionSingleRel& operator=(ExtensionSingleRel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExtensionSingleRel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExtensionSingleRel* internal_default_instance() {
    return reinterpret_cast<const ExtensionSingleRel*>(
               &_ExtensionSingleRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(ExtensionSingleRel* other);
  friend void swap(ExtensionSingleRel& a, ExtensionSingleRel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExtensionSingleRel* New() const final {
    return CreateMaybeMessage<ExtensionSingleRel>(NULL);
  }

  ExtensionSingleRel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExtensionSingleRel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExtensionSingleRel& from);
  void MergeFrom(const ExtensionSingleRel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExtensionSingleRel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .substrait.RelCommon common = 1;
  bool has_common() const;
  void clear_common();
  static const int kCommonFieldNumber = 1;
  private:
  const ::substrait::RelCommon& _internal_common() const;
  public:
  const ::substrait::RelCommon& common() const;
  ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* common);

  // .substrait.Rel input = 2;
  bool has_input() const;
  void clear_input();
  static const int kInputFieldNumber = 2;
  private:
  const ::substrait::Rel& _internal_input() const;
  public:
  const ::substrait::Rel& input() const;
  ::substrait::Rel* release_input();
  ::substrait::Rel* mutable_input();
  void set_allocated_input(::substrait::Rel* input);

  // .google.protobuf.Any detail = 3;
  bool has_detail() const;
  void clear_detail();
  static const int kDetailFieldNumber = 3;
  private:
  const ::google::protobuf::Any& _internal_detail() const;
  public:
  const ::google::protobuf::Any& detail() const;
  ::google::protobuf::Any* release_detail();
  ::google::protobuf::Any* mutable_detail();
  void set_allocated_detail(::google::protobuf::Any* detail);

  // @@protoc_insertion_point(class_scope:substrait.ExtensionSingleRel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::substrait::RelCommon* common_;
  ::substrait::Rel* input_;
  ::google::protobuf::Any* detail_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExtensionLeafRel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.ExtensionLeafRel) */ {
 public:
  ExtensionLeafRel();
  virtual ~ExtensionLeafRel();

  ExtensionLeafRel(const ExtensionLeafRel& from);

  inline ExtensionLeafRel& operator=(const ExtensionLeafRel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExtensionLeafRel(ExtensionLeafRel&& from) noexcept
    : ExtensionLeafRel() {
    *this = ::std::move(from);
  }

  inline ExtensionLeafRel& operator=(ExtensionLeafRel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExtensionLeafRel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExtensionLeafRel* internal_default_instance() {
    return reinterpret_cast<const ExtensionLeafRel*>(
               &_ExtensionLeafRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(ExtensionLeafRel* other);
  friend void swap(ExtensionLeafRel& a, ExtensionLeafRel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExtensionLeafRel* New() const final {
    return CreateMaybeMessage<ExtensionLeafRel>(NULL);
  }

  ExtensionLeafRel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExtensionLeafRel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExtensionLeafRel& from);
  void MergeFrom(const ExtensionLeafRel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExtensionLeafRel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .substrait.RelCommon common = 1;
  bool has_common() const;
  void clear_common();
  static const int kCommonFieldNumber = 1;
  private:
  const ::substrait::RelCommon& _internal_common() const;
  public:
  const ::substrait::RelCommon& common() const;
  ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* common);

  // .google.protobuf.Any detail = 2;
  bool has_detail() const;
  void clear_detail();
  static const int kDetailFieldNumber = 2;
  private:
  const ::google::protobuf::Any& _internal_detail() const;
  public:
  const ::google::protobuf::Any& detail() const;
  ::google::protobuf::Any* release_detail();
  ::google::protobuf::Any* mutable_detail();
  void set_allocated_detail(::google::protobuf::Any* detail);

  // @@protoc_insertion_point(class_scope:substrait.ExtensionLeafRel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::substrait::RelCommon* common_;
  ::google::protobuf::Any* detail_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExtensionMultiRel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.ExtensionMultiRel) */ {
 public:
  ExtensionMultiRel();
  virtual ~ExtensionMultiRel();

  ExtensionMultiRel(const ExtensionMultiRel& from);

  inline ExtensionMultiRel& operator=(const ExtensionMultiRel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExtensionMultiRel(ExtensionMultiRel&& from) noexcept
    : ExtensionMultiRel() {
    *this = ::std::move(from);
  }

  inline ExtensionMultiRel& operator=(ExtensionMultiRel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExtensionMultiRel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExtensionMultiRel* internal_default_instance() {
    return reinterpret_cast<const ExtensionMultiRel*>(
               &_ExtensionMultiRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(ExtensionMultiRel* other);
  friend void swap(ExtensionMultiRel& a, ExtensionMultiRel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExtensionMultiRel* New() const final {
    return CreateMaybeMessage<ExtensionMultiRel>(NULL);
  }

  ExtensionMultiRel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExtensionMultiRel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExtensionMultiRel& from);
  void MergeFrom(const ExtensionMultiRel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExtensionMultiRel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .substrait.Rel inputs = 2;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 2;
  ::substrait::Rel* mutable_inputs(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::Rel >*
      mutable_inputs();
  const ::substrait::Rel& inputs(int index) const;
  ::substrait::Rel* add_inputs();
  const ::google::protobuf::RepeatedPtrField< ::substrait::Rel >&
      inputs() const;

  // .substrait.RelCommon common = 1;
  bool has_common() const;
  void clear_common();
  static const int kCommonFieldNumber = 1;
  private:
  const ::substrait::RelCommon& _internal_common() const;
  public:
  const ::substrait::RelCommon& common() const;
  ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* common);

  // .google.protobuf.Any detail = 3;
  bool has_detail() const;
  void clear_detail();
  static const int kDetailFieldNumber = 3;
  private:
  const ::google::protobuf::Any& _internal_detail() const;
  public:
  const ::google::protobuf::Any& detail() const;
  ::google::protobuf::Any* release_detail();
  ::google::protobuf::Any* mutable_detail();
  void set_allocated_detail(::google::protobuf::Any* detail);

  // @@protoc_insertion_point(class_scope:substrait.ExtensionMultiRel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::substrait::Rel > inputs_;
  ::substrait::RelCommon* common_;
  ::google::protobuf::Any* detail_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExchangeRel_ScatterFields : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.ExchangeRel.ScatterFields) */ {
 public:
  ExchangeRel_ScatterFields();
  virtual ~ExchangeRel_ScatterFields();

  ExchangeRel_ScatterFields(const ExchangeRel_ScatterFields& from);

  inline ExchangeRel_ScatterFields& operator=(const ExchangeRel_ScatterFields& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExchangeRel_ScatterFields(ExchangeRel_ScatterFields&& from) noexcept
    : ExchangeRel_ScatterFields() {
    *this = ::std::move(from);
  }

  inline ExchangeRel_ScatterFields& operator=(ExchangeRel_ScatterFields&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExchangeRel_ScatterFields& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExchangeRel_ScatterFields* internal_default_instance() {
    return reinterpret_cast<const ExchangeRel_ScatterFields*>(
               &_ExchangeRel_ScatterFields_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(ExchangeRel_ScatterFields* other);
  friend void swap(ExchangeRel_ScatterFields& a, ExchangeRel_ScatterFields& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExchangeRel_ScatterFields* New() const final {
    return CreateMaybeMessage<ExchangeRel_ScatterFields>(NULL);
  }

  ExchangeRel_ScatterFields* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExchangeRel_ScatterFields>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExchangeRel_ScatterFields& from);
  void MergeFrom(const ExchangeRel_ScatterFields& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExchangeRel_ScatterFields* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .substrait.Expression.FieldReference fields = 1;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 1;
  ::substrait::Expression_FieldReference* mutable_fields(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression_FieldReference >*
      mutable_fields();
  const ::substrait::Expression_FieldReference& fields(int index) const;
  ::substrait::Expression_FieldReference* add_fields();
  const ::google::protobuf::RepeatedPtrField< ::substrait::Expression_FieldReference >&
      fields() const;

  // @@protoc_insertion_point(class_scope:substrait.ExchangeRel.ScatterFields)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression_FieldReference > fields_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExchangeRel_SingleBucketExpression : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.ExchangeRel.SingleBucketExpression) */ {
 public:
  ExchangeRel_SingleBucketExpression();
  virtual ~ExchangeRel_SingleBucketExpression();

  ExchangeRel_SingleBucketExpression(const ExchangeRel_SingleBucketExpression& from);

  inline ExchangeRel_SingleBucketExpression& operator=(const ExchangeRel_SingleBucketExpression& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExchangeRel_SingleBucketExpression(ExchangeRel_SingleBucketExpression&& from) noexcept
    : ExchangeRel_SingleBucketExpression() {
    *this = ::std::move(from);
  }

  inline ExchangeRel_SingleBucketExpression& operator=(ExchangeRel_SingleBucketExpression&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExchangeRel_SingleBucketExpression& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExchangeRel_SingleBucketExpression* internal_default_instance() {
    return reinterpret_cast<const ExchangeRel_SingleBucketExpression*>(
               &_ExchangeRel_SingleBucketExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(ExchangeRel_SingleBucketExpression* other);
  friend void swap(ExchangeRel_SingleBucketExpression& a, ExchangeRel_SingleBucketExpression& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExchangeRel_SingleBucketExpression* New() const final {
    return CreateMaybeMessage<ExchangeRel_SingleBucketExpression>(NULL);
  }

  ExchangeRel_SingleBucketExpression* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExchangeRel_SingleBucketExpression>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExchangeRel_SingleBucketExpression& from);
  void MergeFrom(const ExchangeRel_SingleBucketExpression& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExchangeRel_SingleBucketExpression* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .substrait.Expression expression = 1;
  bool has_expression() const;
  void clear_expression();
  static const int kExpressionFieldNumber = 1;
  private:
  const ::substrait::Expression& _internal_expression() const;
  public:
  const ::substrait::Expression& expression() const;
  ::substrait::Expression* release_expression();
  ::substrait::Expression* mutable_expression();
  void set_allocated_expression(::substrait::Expression* expression);

  // @@protoc_insertion_point(class_scope:substrait.ExchangeRel.SingleBucketExpression)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::substrait::Expression* expression_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExchangeRel_MultiBucketExpression : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.ExchangeRel.MultiBucketExpression) */ {
 public:
  ExchangeRel_MultiBucketExpression();
  virtual ~ExchangeRel_MultiBucketExpression();

  ExchangeRel_MultiBucketExpression(const ExchangeRel_MultiBucketExpression& from);

  inline ExchangeRel_MultiBucketExpression& operator=(const ExchangeRel_MultiBucketExpression& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExchangeRel_MultiBucketExpression(ExchangeRel_MultiBucketExpression&& from) noexcept
    : ExchangeRel_MultiBucketExpression() {
    *this = ::std::move(from);
  }

  inline ExchangeRel_MultiBucketExpression& operator=(ExchangeRel_MultiBucketExpression&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExchangeRel_MultiBucketExpression& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExchangeRel_MultiBucketExpression* internal_default_instance() {
    return reinterpret_cast<const ExchangeRel_MultiBucketExpression*>(
               &_ExchangeRel_MultiBucketExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(ExchangeRel_MultiBucketExpression* other);
  friend void swap(ExchangeRel_MultiBucketExpression& a, ExchangeRel_MultiBucketExpression& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExchangeRel_MultiBucketExpression* New() const final {
    return CreateMaybeMessage<ExchangeRel_MultiBucketExpression>(NULL);
  }

  ExchangeRel_MultiBucketExpression* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExchangeRel_MultiBucketExpression>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExchangeRel_MultiBucketExpression& from);
  void MergeFrom(const ExchangeRel_MultiBucketExpression& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExchangeRel_MultiBucketExpression* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .substrait.Expression expression = 1;
  bool has_expression() const;
  void clear_expression();
  static const int kExpressionFieldNumber = 1;
  private:
  const ::substrait::Expression& _internal_expression() const;
  public:
  const ::substrait::Expression& expression() const;
  ::substrait::Expression* release_expression();
  ::substrait::Expression* mutable_expression();
  void set_allocated_expression(::substrait::Expression* expression);

  // bool constrained_to_count = 2;
  void clear_constrained_to_count();
  static const int kConstrainedToCountFieldNumber = 2;
  bool constrained_to_count() const;
  void set_constrained_to_count(bool value);

  // @@protoc_insertion_point(class_scope:substrait.ExchangeRel.MultiBucketExpression)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::substrait::Expression* expression_;
  bool constrained_to_count_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExchangeRel_Broadcast : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.ExchangeRel.Broadcast) */ {
 public:
  ExchangeRel_Broadcast();
  virtual ~ExchangeRel_Broadcast();

  ExchangeRel_Broadcast(const ExchangeRel_Broadcast& from);

  inline ExchangeRel_Broadcast& operator=(const ExchangeRel_Broadcast& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExchangeRel_Broadcast(ExchangeRel_Broadcast&& from) noexcept
    : ExchangeRel_Broadcast() {
    *this = ::std::move(from);
  }

  inline ExchangeRel_Broadcast& operator=(ExchangeRel_Broadcast&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExchangeRel_Broadcast& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExchangeRel_Broadcast* internal_default_instance() {
    return reinterpret_cast<const ExchangeRel_Broadcast*>(
               &_ExchangeRel_Broadcast_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(ExchangeRel_Broadcast* other);
  friend void swap(ExchangeRel_Broadcast& a, ExchangeRel_Broadcast& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExchangeRel_Broadcast* New() const final {
    return CreateMaybeMessage<ExchangeRel_Broadcast>(NULL);
  }

  ExchangeRel_Broadcast* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExchangeRel_Broadcast>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExchangeRel_Broadcast& from);
  void MergeFrom(const ExchangeRel_Broadcast& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExchangeRel_Broadcast* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:substrait.ExchangeRel.Broadcast)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExchangeRel_RoundRobin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.ExchangeRel.RoundRobin) */ {
 public:
  ExchangeRel_RoundRobin();
  virtual ~ExchangeRel_RoundRobin();

  ExchangeRel_RoundRobin(const ExchangeRel_RoundRobin& from);

  inline ExchangeRel_RoundRobin& operator=(const ExchangeRel_RoundRobin& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExchangeRel_RoundRobin(ExchangeRel_RoundRobin&& from) noexcept
    : ExchangeRel_RoundRobin() {
    *this = ::std::move(from);
  }

  inline ExchangeRel_RoundRobin& operator=(ExchangeRel_RoundRobin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExchangeRel_RoundRobin& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExchangeRel_RoundRobin* internal_default_instance() {
    return reinterpret_cast<const ExchangeRel_RoundRobin*>(
               &_ExchangeRel_RoundRobin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(ExchangeRel_RoundRobin* other);
  friend void swap(ExchangeRel_RoundRobin& a, ExchangeRel_RoundRobin& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExchangeRel_RoundRobin* New() const final {
    return CreateMaybeMessage<ExchangeRel_RoundRobin>(NULL);
  }

  ExchangeRel_RoundRobin* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExchangeRel_RoundRobin>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExchangeRel_RoundRobin& from);
  void MergeFrom(const ExchangeRel_RoundRobin& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExchangeRel_RoundRobin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool exact = 1;
  void clear_exact();
  static const int kExactFieldNumber = 1;
  bool exact() const;
  void set_exact(bool value);

  // @@protoc_insertion_point(class_scope:substrait.ExchangeRel.RoundRobin)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool exact_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExchangeRel_ExchangeTarget : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.ExchangeRel.ExchangeTarget) */ {
 public:
  ExchangeRel_ExchangeTarget();
  virtual ~ExchangeRel_ExchangeTarget();

  ExchangeRel_ExchangeTarget(const ExchangeRel_ExchangeTarget& from);

  inline ExchangeRel_ExchangeTarget& operator=(const ExchangeRel_ExchangeTarget& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExchangeRel_ExchangeTarget(ExchangeRel_ExchangeTarget&& from) noexcept
    : ExchangeRel_ExchangeTarget() {
    *this = ::std::move(from);
  }

  inline ExchangeRel_ExchangeTarget& operator=(ExchangeRel_ExchangeTarget&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExchangeRel_ExchangeTarget& default_instance();

  enum TargetTypeCase {
    kUri = 2,
    kExtended = 3,
    TARGET_TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExchangeRel_ExchangeTarget* internal_default_instance() {
    return reinterpret_cast<const ExchangeRel_ExchangeTarget*>(
               &_ExchangeRel_ExchangeTarget_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(ExchangeRel_ExchangeTarget* other);
  friend void swap(ExchangeRel_ExchangeTarget& a, ExchangeRel_ExchangeTarget& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExchangeRel_ExchangeTarget* New() const final {
    return CreateMaybeMessage<ExchangeRel_ExchangeTarget>(NULL);
  }

  ExchangeRel_ExchangeTarget* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExchangeRel_ExchangeTarget>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExchangeRel_ExchangeTarget& from);
  void MergeFrom(const ExchangeRel_ExchangeTarget& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExchangeRel_ExchangeTarget* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 partition_id = 1;
  int partition_id_size() const;
  void clear_partition_id();
  static const int kPartitionIdFieldNumber = 1;
  ::google::protobuf::int32 partition_id(int index) const;
  void set_partition_id(int index, ::google::protobuf::int32 value);
  void add_partition_id(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      partition_id() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_partition_id();

  // string uri = 2;
  private:
  bool has_uri() const;
  public:
  void clear_uri();
  static const int kUriFieldNumber = 2;
  const ::std::string& uri() const;
  void set_uri(const ::std::string& value);
  #if LANG_CXX11
  void set_uri(::std::string&& value);
  #endif
  void set_uri(const char* value);
  void set_uri(const char* value, size_t size);
  ::std::string* mutable_uri();
  ::std::string* release_uri();
  void set_allocated_uri(::std::string* uri);

  // .google.protobuf.Any extended = 3;
  bool has_extended() const;
  void clear_extended();
  static const int kExtendedFieldNumber = 3;
  private:
  const ::google::protobuf::Any& _internal_extended() const;
  public:
  const ::google::protobuf::Any& extended() const;
  ::google::protobuf::Any* release_extended();
  ::google::protobuf::Any* mutable_extended();
  void set_allocated_extended(::google::protobuf::Any* extended);

  void clear_target_type();
  TargetTypeCase target_type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.ExchangeRel.ExchangeTarget)
 private:
  void set_has_uri();
  void set_has_extended();

  inline bool has_target_type() const;
  inline void clear_has_target_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > partition_id_;
  mutable int _partition_id_cached_byte_size_;
  union TargetTypeUnion {
    TargetTypeUnion() {}
    ::google::protobuf::internal::ArenaStringPtr uri_;
    ::google::protobuf::Any* extended_;
  } target_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExchangeRel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.ExchangeRel) */ {
 public:
  ExchangeRel();
  virtual ~ExchangeRel();

  ExchangeRel(const ExchangeRel& from);

  inline ExchangeRel& operator=(const ExchangeRel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExchangeRel(ExchangeRel&& from) noexcept
    : ExchangeRel() {
    *this = ::std::move(from);
  }

  inline ExchangeRel& operator=(ExchangeRel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExchangeRel& default_instance();

  enum ExchangeKindCase {
    kScatterByFields = 5,
    kSingleTarget = 6,
    kMultiTarget = 7,
    kRoundRobin = 8,
    kBroadcast = 9,
    EXCHANGE_KIND_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExchangeRel* internal_default_instance() {
    return reinterpret_cast<const ExchangeRel*>(
               &_ExchangeRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(ExchangeRel* other);
  friend void swap(ExchangeRel& a, ExchangeRel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExchangeRel* New() const final {
    return CreateMaybeMessage<ExchangeRel>(NULL);
  }

  ExchangeRel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExchangeRel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExchangeRel& from);
  void MergeFrom(const ExchangeRel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExchangeRel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ExchangeRel_ScatterFields ScatterFields;
  typedef ExchangeRel_SingleBucketExpression SingleBucketExpression;
  typedef ExchangeRel_MultiBucketExpression MultiBucketExpression;
  typedef ExchangeRel_Broadcast Broadcast;
  typedef ExchangeRel_RoundRobin RoundRobin;
  typedef ExchangeRel_ExchangeTarget ExchangeTarget;

  // accessors -------------------------------------------------------

  // repeated .substrait.ExchangeRel.ExchangeTarget targets = 4;
  int targets_size() const;
  void clear_targets();
  static const int kTargetsFieldNumber = 4;
  ::substrait::ExchangeRel_ExchangeTarget* mutable_targets(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::ExchangeRel_ExchangeTarget >*
      mutable_targets();
  const ::substrait::ExchangeRel_ExchangeTarget& targets(int index) const;
  ::substrait::ExchangeRel_ExchangeTarget* add_targets();
  const ::google::protobuf::RepeatedPtrField< ::substrait::ExchangeRel_ExchangeTarget >&
      targets() const;

  // .substrait.RelCommon common = 1;
  bool has_common() const;
  void clear_common();
  static const int kCommonFieldNumber = 1;
  private:
  const ::substrait::RelCommon& _internal_common() const;
  public:
  const ::substrait::RelCommon& common() const;
  ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* common);

  // .substrait.Rel input = 2;
  bool has_input() const;
  void clear_input();
  static const int kInputFieldNumber = 2;
  private:
  const ::substrait::Rel& _internal_input() const;
  public:
  const ::substrait::Rel& input() const;
  ::substrait::Rel* release_input();
  ::substrait::Rel* mutable_input();
  void set_allocated_input(::substrait::Rel* input);

  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension();
  static const int kAdvancedExtensionFieldNumber = 10;
  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  public:
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension);

  // int32 partition_count = 3;
  void clear_partition_count();
  static const int kPartitionCountFieldNumber = 3;
  ::google::protobuf::int32 partition_count() const;
  void set_partition_count(::google::protobuf::int32 value);

  // .substrait.ExchangeRel.ScatterFields scatter_by_fields = 5;
  bool has_scatter_by_fields() const;
  void clear_scatter_by_fields();
  static const int kScatterByFieldsFieldNumber = 5;
  private:
  const ::substrait::ExchangeRel_ScatterFields& _internal_scatter_by_fields() const;
  public:
  const ::substrait::ExchangeRel_ScatterFields& scatter_by_fields() const;
  ::substrait::ExchangeRel_ScatterFields* release_scatter_by_fields();
  ::substrait::ExchangeRel_ScatterFields* mutable_scatter_by_fields();
  void set_allocated_scatter_by_fields(::substrait::ExchangeRel_ScatterFields* scatter_by_fields);

  // .substrait.ExchangeRel.SingleBucketExpression single_target = 6;
  bool has_single_target() const;
  void clear_single_target();
  static const int kSingleTargetFieldNumber = 6;
  private:
  const ::substrait::ExchangeRel_SingleBucketExpression& _internal_single_target() const;
  public:
  const ::substrait::ExchangeRel_SingleBucketExpression& single_target() const;
  ::substrait::ExchangeRel_SingleBucketExpression* release_single_target();
  ::substrait::ExchangeRel_SingleBucketExpression* mutable_single_target();
  void set_allocated_single_target(::substrait::ExchangeRel_SingleBucketExpression* single_target);

  // .substrait.ExchangeRel.MultiBucketExpression multi_target = 7;
  bool has_multi_target() const;
  void clear_multi_target();
  static const int kMultiTargetFieldNumber = 7;
  private:
  const ::substrait::ExchangeRel_MultiBucketExpression& _internal_multi_target() const;
  public:
  const ::substrait::ExchangeRel_MultiBucketExpression& multi_target() const;
  ::substrait::ExchangeRel_MultiBucketExpression* release_multi_target();
  ::substrait::ExchangeRel_MultiBucketExpression* mutable_multi_target();
  void set_allocated_multi_target(::substrait::ExchangeRel_MultiBucketExpression* multi_target);

  // .substrait.ExchangeRel.RoundRobin round_robin = 8;
  bool has_round_robin() const;
  void clear_round_robin();
  static const int kRoundRobinFieldNumber = 8;
  private:
  const ::substrait::ExchangeRel_RoundRobin& _internal_round_robin() const;
  public:
  const ::substrait::ExchangeRel_RoundRobin& round_robin() const;
  ::substrait::ExchangeRel_RoundRobin* release_round_robin();
  ::substrait::ExchangeRel_RoundRobin* mutable_round_robin();
  void set_allocated_round_robin(::substrait::ExchangeRel_RoundRobin* round_robin);

  // .substrait.ExchangeRel.Broadcast broadcast = 9;
  bool has_broadcast() const;
  void clear_broadcast();
  static const int kBroadcastFieldNumber = 9;
  private:
  const ::substrait::ExchangeRel_Broadcast& _internal_broadcast() const;
  public:
  const ::substrait::ExchangeRel_Broadcast& broadcast() const;
  ::substrait::ExchangeRel_Broadcast* release_broadcast();
  ::substrait::ExchangeRel_Broadcast* mutable_broadcast();
  void set_allocated_broadcast(::substrait::ExchangeRel_Broadcast* broadcast);

  void clear_exchange_kind();
  ExchangeKindCase exchange_kind_case() const;
  // @@protoc_insertion_point(class_scope:substrait.ExchangeRel)
 private:
  void set_has_scatter_by_fields();
  void set_has_single_target();
  void set_has_multi_target();
  void set_has_round_robin();
  void set_has_broadcast();

  inline bool has_exchange_kind() const;
  inline void clear_has_exchange_kind();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::substrait::ExchangeRel_ExchangeTarget > targets_;
  ::substrait::RelCommon* common_;
  ::substrait::Rel* input_;
  ::substrait::extensions::AdvancedExtension* advanced_extension_;
  ::google::protobuf::int32 partition_count_;
  union ExchangeKindUnion {
    ExchangeKindUnion() {}
    ::substrait::ExchangeRel_ScatterFields* scatter_by_fields_;
    ::substrait::ExchangeRel_SingleBucketExpression* single_target_;
    ::substrait::ExchangeRel_MultiBucketExpression* multi_target_;
    ::substrait::ExchangeRel_RoundRobin* round_robin_;
    ::substrait::ExchangeRel_Broadcast* broadcast_;
  } exchange_kind_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RelRoot : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.RelRoot) */ {
 public:
  RelRoot();
  virtual ~RelRoot();

  RelRoot(const RelRoot& from);

  inline RelRoot& operator=(const RelRoot& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RelRoot(RelRoot&& from) noexcept
    : RelRoot() {
    *this = ::std::move(from);
  }

  inline RelRoot& operator=(RelRoot&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RelRoot& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RelRoot* internal_default_instance() {
    return reinterpret_cast<const RelRoot*>(
               &_RelRoot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(RelRoot* other);
  friend void swap(RelRoot& a, RelRoot& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RelRoot* New() const final {
    return CreateMaybeMessage<RelRoot>(NULL);
  }

  RelRoot* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RelRoot>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RelRoot& from);
  void MergeFrom(const RelRoot& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelRoot* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string names = 2;
  int names_size() const;
  void clear_names();
  static const int kNamesFieldNumber = 2;
  const ::std::string& names(int index) const;
  ::std::string* mutable_names(int index);
  void set_names(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_names(int index, ::std::string&& value);
  #endif
  void set_names(int index, const char* value);
  void set_names(int index, const char* value, size_t size);
  ::std::string* add_names();
  void add_names(const ::std::string& value);
  #if LANG_CXX11
  void add_names(::std::string&& value);
  #endif
  void add_names(const char* value);
  void add_names(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& names() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_names();

  // .substrait.Rel input = 1;
  bool has_input() const;
  void clear_input();
  static const int kInputFieldNumber = 1;
  private:
  const ::substrait::Rel& _internal_input() const;
  public:
  const ::substrait::Rel& input() const;
  ::substrait::Rel* release_input();
  ::substrait::Rel* mutable_input();
  void set_allocated_input(::substrait::Rel* input);

  // @@protoc_insertion_point(class_scope:substrait.RelRoot)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> names_;
  ::substrait::Rel* input_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Rel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Rel) */ {
 public:
  Rel();
  virtual ~Rel();

  Rel(const Rel& from);

  inline Rel& operator=(const Rel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Rel(Rel&& from) noexcept
    : Rel() {
    *this = ::std::move(from);
  }

  inline Rel& operator=(Rel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Rel& default_instance();

  enum RelTypeCase {
    kRead = 1,
    kFilter = 2,
    kFetch = 3,
    kAggregate = 4,
    kSort = 5,
    kJoin = 6,
    kProject = 7,
    kSet = 8,
    kExtensionSingle = 9,
    kExtensionMulti = 10,
    kExtensionLeaf = 11,
    kCross = 12,
    kHashJoin = 13,
    kMergeJoin = 14,
    REL_TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Rel* internal_default_instance() {
    return reinterpret_cast<const Rel*>(
               &_Rel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(Rel* other);
  friend void swap(Rel& a, Rel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Rel* New() const final {
    return CreateMaybeMessage<Rel>(NULL);
  }

  Rel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Rel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Rel& from);
  void MergeFrom(const Rel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .substrait.ReadRel read = 1;
  bool has_read() const;
  void clear_read();
  static const int kReadFieldNumber = 1;
  private:
  const ::substrait::ReadRel& _internal_read() const;
  public:
  const ::substrait::ReadRel& read() const;
  ::substrait::ReadRel* release_read();
  ::substrait::ReadRel* mutable_read();
  void set_allocated_read(::substrait::ReadRel* read);

  // .substrait.FilterRel filter = 2;
  bool has_filter() const;
  void clear_filter();
  static const int kFilterFieldNumber = 2;
  private:
  const ::substrait::FilterRel& _internal_filter() const;
  public:
  const ::substrait::FilterRel& filter() const;
  ::substrait::FilterRel* release_filter();
  ::substrait::FilterRel* mutable_filter();
  void set_allocated_filter(::substrait::FilterRel* filter);

  // .substrait.FetchRel fetch = 3;
  bool has_fetch() const;
  void clear_fetch();
  static const int kFetchFieldNumber = 3;
  private:
  const ::substrait::FetchRel& _internal_fetch() const;
  public:
  const ::substrait::FetchRel& fetch() const;
  ::substrait::FetchRel* release_fetch();
  ::substrait::FetchRel* mutable_fetch();
  void set_allocated_fetch(::substrait::FetchRel* fetch);

  // .substrait.AggregateRel aggregate = 4;
  bool has_aggregate() const;
  void clear_aggregate();
  static const int kAggregateFieldNumber = 4;
  private:
  const ::substrait::AggregateRel& _internal_aggregate() const;
  public:
  const ::substrait::AggregateRel& aggregate() const;
  ::substrait::AggregateRel* release_aggregate();
  ::substrait::AggregateRel* mutable_aggregate();
  void set_allocated_aggregate(::substrait::AggregateRel* aggregate);

  // .substrait.SortRel sort = 5;
  bool has_sort() const;
  void clear_sort();
  static const int kSortFieldNumber = 5;
  private:
  const ::substrait::SortRel& _internal_sort() const;
  public:
  const ::substrait::SortRel& sort() const;
  ::substrait::SortRel* release_sort();
  ::substrait::SortRel* mutable_sort();
  void set_allocated_sort(::substrait::SortRel* sort);

  // .substrait.JoinRel join = 6;
  bool has_join() const;
  void clear_join();
  static const int kJoinFieldNumber = 6;
  private:
  const ::substrait::JoinRel& _internal_join() const;
  public:
  const ::substrait::JoinRel& join() const;
  ::substrait::JoinRel* release_join();
  ::substrait::JoinRel* mutable_join();
  void set_allocated_join(::substrait::JoinRel* join);

  // .substrait.ProjectRel project = 7;
  bool has_project() const;
  void clear_project();
  static const int kProjectFieldNumber = 7;
  private:
  const ::substrait::ProjectRel& _internal_project() const;
  public:
  const ::substrait::ProjectRel& project() const;
  ::substrait::ProjectRel* release_project();
  ::substrait::ProjectRel* mutable_project();
  void set_allocated_project(::substrait::ProjectRel* project);

  // .substrait.SetRel set = 8;
  bool has_set() const;
  void clear_set();
  static const int kSetFieldNumber = 8;
  private:
  const ::substrait::SetRel& _internal_set() const;
  public:
  const ::substrait::SetRel& set() const;
  ::substrait::SetRel* release_set();
  ::substrait::SetRel* mutable_set();
  void set_allocated_set(::substrait::SetRel* set);

  // .substrait.ExtensionSingleRel extension_single = 9;
  bool has_extension_single() const;
  void clear_extension_single();
  static const int kExtensionSingleFieldNumber = 9;
  private:
  const ::substrait::ExtensionSingleRel& _internal_extension_single() const;
  public:
  const ::substrait::ExtensionSingleRel& extension_single() const;
  ::substrait::ExtensionSingleRel* release_extension_single();
  ::substrait::ExtensionSingleRel* mutable_extension_single();
  void set_allocated_extension_single(::substrait::ExtensionSingleRel* extension_single);

  // .substrait.ExtensionMultiRel extension_multi = 10;
  bool has_extension_multi() const;
  void clear_extension_multi();
  static const int kExtensionMultiFieldNumber = 10;
  private:
  const ::substrait::ExtensionMultiRel& _internal_extension_multi() const;
  public:
  const ::substrait::ExtensionMultiRel& extension_multi() const;
  ::substrait::ExtensionMultiRel* release_extension_multi();
  ::substrait::ExtensionMultiRel* mutable_extension_multi();
  void set_allocated_extension_multi(::substrait::ExtensionMultiRel* extension_multi);

  // .substrait.ExtensionLeafRel extension_leaf = 11;
  bool has_extension_leaf() const;
  void clear_extension_leaf();
  static const int kExtensionLeafFieldNumber = 11;
  private:
  const ::substrait::ExtensionLeafRel& _internal_extension_leaf() const;
  public:
  const ::substrait::ExtensionLeafRel& extension_leaf() const;
  ::substrait::ExtensionLeafRel* release_extension_leaf();
  ::substrait::ExtensionLeafRel* mutable_extension_leaf();
  void set_allocated_extension_leaf(::substrait::ExtensionLeafRel* extension_leaf);

  // .substrait.CrossRel cross = 12;
  bool has_cross() const;
  void clear_cross();
  static const int kCrossFieldNumber = 12;
  private:
  const ::substrait::CrossRel& _internal_cross() const;
  public:
  const ::substrait::CrossRel& cross() const;
  ::substrait::CrossRel* release_cross();
  ::substrait::CrossRel* mutable_cross();
  void set_allocated_cross(::substrait::CrossRel* cross);

  // .substrait.HashJoinRel hash_join = 13;
  bool has_hash_join() const;
  void clear_hash_join();
  static const int kHashJoinFieldNumber = 13;
  private:
  const ::substrait::HashJoinRel& _internal_hash_join() const;
  public:
  const ::substrait::HashJoinRel& hash_join() const;
  ::substrait::HashJoinRel* release_hash_join();
  ::substrait::HashJoinRel* mutable_hash_join();
  void set_allocated_hash_join(::substrait::HashJoinRel* hash_join);

  // .substrait.MergeJoinRel merge_join = 14;
  bool has_merge_join() const;
  void clear_merge_join();
  static const int kMergeJoinFieldNumber = 14;
  private:
  const ::substrait::MergeJoinRel& _internal_merge_join() const;
  public:
  const ::substrait::MergeJoinRel& merge_join() const;
  ::substrait::MergeJoinRel* release_merge_join();
  ::substrait::MergeJoinRel* mutable_merge_join();
  void set_allocated_merge_join(::substrait::MergeJoinRel* merge_join);

  void clear_rel_type();
  RelTypeCase rel_type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Rel)
 private:
  void set_has_read();
  void set_has_filter();
  void set_has_fetch();
  void set_has_aggregate();
  void set_has_sort();
  void set_has_join();
  void set_has_project();
  void set_has_set();
  void set_has_extension_single();
  void set_has_extension_multi();
  void set_has_extension_leaf();
  void set_has_cross();
  void set_has_hash_join();
  void set_has_merge_join();

  inline bool has_rel_type() const;
  inline void clear_has_rel_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union RelTypeUnion {
    RelTypeUnion() {}
    ::substrait::ReadRel* read_;
    ::substrait::FilterRel* filter_;
    ::substrait::FetchRel* fetch_;
    ::substrait::AggregateRel* aggregate_;
    ::substrait::SortRel* sort_;
    ::substrait::JoinRel* join_;
    ::substrait::ProjectRel* project_;
    ::substrait::SetRel* set_;
    ::substrait::ExtensionSingleRel* extension_single_;
    ::substrait::ExtensionMultiRel* extension_multi_;
    ::substrait::ExtensionLeafRel* extension_leaf_;
    ::substrait::CrossRel* cross_;
    ::substrait::HashJoinRel* hash_join_;
    ::substrait::MergeJoinRel* merge_join_;
  } rel_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NamedObjectWrite : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.NamedObjectWrite) */ {
 public:
  NamedObjectWrite();
  virtual ~NamedObjectWrite();

  NamedObjectWrite(const NamedObjectWrite& from);

  inline NamedObjectWrite& operator=(const NamedObjectWrite& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NamedObjectWrite(NamedObjectWrite&& from) noexcept
    : NamedObjectWrite() {
    *this = ::std::move(from);
  }

  inline NamedObjectWrite& operator=(NamedObjectWrite&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NamedObjectWrite& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NamedObjectWrite* internal_default_instance() {
    return reinterpret_cast<const NamedObjectWrite*>(
               &_NamedObjectWrite_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  void Swap(NamedObjectWrite* other);
  friend void swap(NamedObjectWrite& a, NamedObjectWrite& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NamedObjectWrite* New() const final {
    return CreateMaybeMessage<NamedObjectWrite>(NULL);
  }

  NamedObjectWrite* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NamedObjectWrite>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NamedObjectWrite& from);
  void MergeFrom(const NamedObjectWrite& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedObjectWrite* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string names = 1;
  int names_size() const;
  void clear_names();
  static const int kNamesFieldNumber = 1;
  const ::std::string& names(int index) const;
  ::std::string* mutable_names(int index);
  void set_names(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_names(int index, ::std::string&& value);
  #endif
  void set_names(int index, const char* value);
  void set_names(int index, const char* value, size_t size);
  ::std::string* add_names();
  void add_names(const ::std::string& value);
  #if LANG_CXX11
  void add_names(::std::string&& value);
  #endif
  void add_names(const char* value);
  void add_names(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& names() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_names();

  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension();
  static const int kAdvancedExtensionFieldNumber = 10;
  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  public:
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension);

  // @@protoc_insertion_point(class_scope:substrait.NamedObjectWrite)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> names_;
  ::substrait::extensions::AdvancedExtension* advanced_extension_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExtensionObject : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.ExtensionObject) */ {
 public:
  ExtensionObject();
  virtual ~ExtensionObject();

  ExtensionObject(const ExtensionObject& from);

  inline ExtensionObject& operator=(const ExtensionObject& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExtensionObject(ExtensionObject&& from) noexcept
    : ExtensionObject() {
    *this = ::std::move(from);
  }

  inline ExtensionObject& operator=(ExtensionObject&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExtensionObject& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExtensionObject* internal_default_instance() {
    return reinterpret_cast<const ExtensionObject*>(
               &_ExtensionObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  void Swap(ExtensionObject* other);
  friend void swap(ExtensionObject& a, ExtensionObject& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExtensionObject* New() const final {
    return CreateMaybeMessage<ExtensionObject>(NULL);
  }

  ExtensionObject* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExtensionObject>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExtensionObject& from);
  void MergeFrom(const ExtensionObject& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExtensionObject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.Any detail = 1;
  bool has_detail() const;
  void clear_detail();
  static const int kDetailFieldNumber = 1;
  private:
  const ::google::protobuf::Any& _internal_detail() const;
  public:
  const ::google::protobuf::Any& detail() const;
  ::google::protobuf::Any* release_detail();
  ::google::protobuf::Any* mutable_detail();
  void set_allocated_detail(::google::protobuf::Any* detail);

  // @@protoc_insertion_point(class_scope:substrait.ExtensionObject)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Any* detail_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DdlRel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.DdlRel) */ {
 public:
  DdlRel();
  virtual ~DdlRel();

  DdlRel(const DdlRel& from);

  inline DdlRel& operator=(const DdlRel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DdlRel(DdlRel&& from) noexcept
    : DdlRel() {
    *this = ::std::move(from);
  }

  inline DdlRel& operator=(DdlRel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DdlRel& default_instance();

  enum WriteTypeCase {
    kNamedObject = 1,
    kExtensionObject = 2,
    WRITE_TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DdlRel* internal_default_instance() {
    return reinterpret_cast<const DdlRel*>(
               &_DdlRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  void Swap(DdlRel* other);
  friend void swap(DdlRel& a, DdlRel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DdlRel* New() const final {
    return CreateMaybeMessage<DdlRel>(NULL);
  }

  DdlRel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DdlRel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DdlRel& from);
  void MergeFrom(const DdlRel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DdlRel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DdlRel_DdlObject DdlObject;
  static const DdlObject DDL_OBJECT_UNSPECIFIED =
    DdlRel_DdlObject_DDL_OBJECT_UNSPECIFIED;
  static const DdlObject DDL_OBJECT_TABLE =
    DdlRel_DdlObject_DDL_OBJECT_TABLE;
  static const DdlObject DDL_OBJECT_VIEW =
    DdlRel_DdlObject_DDL_OBJECT_VIEW;
  static inline bool DdlObject_IsValid(int value) {
    return DdlRel_DdlObject_IsValid(value);
  }
  static const DdlObject DdlObject_MIN =
    DdlRel_DdlObject_DdlObject_MIN;
  static const DdlObject DdlObject_MAX =
    DdlRel_DdlObject_DdlObject_MAX;
  static const int DdlObject_ARRAYSIZE =
    DdlRel_DdlObject_DdlObject_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DdlObject_descriptor() {
    return DdlRel_DdlObject_descriptor();
  }
  static inline const ::std::string& DdlObject_Name(DdlObject value) {
    return DdlRel_DdlObject_Name(value);
  }
  static inline bool DdlObject_Parse(const ::std::string& name,
      DdlObject* value) {
    return DdlRel_DdlObject_Parse(name, value);
  }

  typedef DdlRel_DdlOp DdlOp;
  static const DdlOp DDL_OP_UNSPECIFIED =
    DdlRel_DdlOp_DDL_OP_UNSPECIFIED;
  static const DdlOp DDL_OP_CREATE =
    DdlRel_DdlOp_DDL_OP_CREATE;
  static const DdlOp DDL_OP_CREATE_OR_REPLACE =
    DdlRel_DdlOp_DDL_OP_CREATE_OR_REPLACE;
  static const DdlOp DDL_OP_ALTER =
    DdlRel_DdlOp_DDL_OP_ALTER;
  static const DdlOp DDL_OP_DROP =
    DdlRel_DdlOp_DDL_OP_DROP;
  static const DdlOp DDL_OP_DROP_IF_EXIST =
    DdlRel_DdlOp_DDL_OP_DROP_IF_EXIST;
  static inline bool DdlOp_IsValid(int value) {
    return DdlRel_DdlOp_IsValid(value);
  }
  static const DdlOp DdlOp_MIN =
    DdlRel_DdlOp_DdlOp_MIN;
  static const DdlOp DdlOp_MAX =
    DdlRel_DdlOp_DdlOp_MAX;
  static const int DdlOp_ARRAYSIZE =
    DdlRel_DdlOp_DdlOp_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DdlOp_descriptor() {
    return DdlRel_DdlOp_descriptor();
  }
  static inline const ::std::string& DdlOp_Name(DdlOp value) {
    return DdlRel_DdlOp_Name(value);
  }
  static inline bool DdlOp_Parse(const ::std::string& name,
      DdlOp* value) {
    return DdlRel_DdlOp_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .substrait.NamedStruct table_schema = 3;
  bool has_table_schema() const;
  void clear_table_schema();
  static const int kTableSchemaFieldNumber = 3;
  private:
  const ::substrait::NamedStruct& _internal_table_schema() const;
  public:
  const ::substrait::NamedStruct& table_schema() const;
  ::substrait::NamedStruct* release_table_schema();
  ::substrait::NamedStruct* mutable_table_schema();
  void set_allocated_table_schema(::substrait::NamedStruct* table_schema);

  // .substrait.Expression.Literal.Struct table_defaults = 4;
  bool has_table_defaults() const;
  void clear_table_defaults();
  static const int kTableDefaultsFieldNumber = 4;
  private:
  const ::substrait::Expression_Literal_Struct& _internal_table_defaults() const;
  public:
  const ::substrait::Expression_Literal_Struct& table_defaults() const;
  ::substrait::Expression_Literal_Struct* release_table_defaults();
  ::substrait::Expression_Literal_Struct* mutable_table_defaults();
  void set_allocated_table_defaults(::substrait::Expression_Literal_Struct* table_defaults);

  // .substrait.Rel view_definition = 7;
  bool has_view_definition() const;
  void clear_view_definition();
  static const int kViewDefinitionFieldNumber = 7;
  private:
  const ::substrait::Rel& _internal_view_definition() const;
  public:
  const ::substrait::Rel& view_definition() const;
  ::substrait::Rel* release_view_definition();
  ::substrait::Rel* mutable_view_definition();
  void set_allocated_view_definition(::substrait::Rel* view_definition);

  // .substrait.DdlRel.DdlObject object = 5;
  void clear_object();
  static const int kObjectFieldNumber = 5;
  ::substrait::DdlRel_DdlObject object() const;
  void set_object(::substrait::DdlRel_DdlObject value);

  // .substrait.DdlRel.DdlOp op = 6;
  void clear_op();
  static const int kOpFieldNumber = 6;
  ::substrait::DdlRel_DdlOp op() const;
  void set_op(::substrait::DdlRel_DdlOp value);

  // .substrait.NamedObjectWrite named_object = 1;
  bool has_named_object() const;
  void clear_named_object();
  static const int kNamedObjectFieldNumber = 1;
  private:
  const ::substrait::NamedObjectWrite& _internal_named_object() const;
  public:
  const ::substrait::NamedObjectWrite& named_object() const;
  ::substrait::NamedObjectWrite* release_named_object();
  ::substrait::NamedObjectWrite* mutable_named_object();
  void set_allocated_named_object(::substrait::NamedObjectWrite* named_object);

  // .substrait.ExtensionObject extension_object = 2;
  bool has_extension_object() const;
  void clear_extension_object();
  static const int kExtensionObjectFieldNumber = 2;
  private:
  const ::substrait::ExtensionObject& _internal_extension_object() const;
  public:
  const ::substrait::ExtensionObject& extension_object() const;
  ::substrait::ExtensionObject* release_extension_object();
  ::substrait::ExtensionObject* mutable_extension_object();
  void set_allocated_extension_object(::substrait::ExtensionObject* extension_object);

  void clear_write_type();
  WriteTypeCase write_type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.DdlRel)
 private:
  void set_has_named_object();
  void set_has_extension_object();

  inline bool has_write_type() const;
  inline void clear_has_write_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::substrait::NamedStruct* table_schema_;
  ::substrait::Expression_Literal_Struct* table_defaults_;
  ::substrait::Rel* view_definition_;
  int object_;
  int op_;
  union WriteTypeUnion {
    WriteTypeUnion() {}
    ::substrait::NamedObjectWrite* named_object_;
    ::substrait::ExtensionObject* extension_object_;
  } write_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WriteRel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.WriteRel) */ {
 public:
  WriteRel();
  virtual ~WriteRel();

  WriteRel(const WriteRel& from);

  inline WriteRel& operator=(const WriteRel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WriteRel(WriteRel&& from) noexcept
    : WriteRel() {
    *this = ::std::move(from);
  }

  inline WriteRel& operator=(WriteRel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WriteRel& default_instance();

  enum WriteTypeCase {
    kNamedTable = 1,
    kExtensionTable = 2,
    WRITE_TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WriteRel* internal_default_instance() {
    return reinterpret_cast<const WriteRel*>(
               &_WriteRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  void Swap(WriteRel* other);
  friend void swap(WriteRel& a, WriteRel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WriteRel* New() const final {
    return CreateMaybeMessage<WriteRel>(NULL);
  }

  WriteRel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WriteRel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WriteRel& from);
  void MergeFrom(const WriteRel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteRel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef WriteRel_WriteOp WriteOp;
  static const WriteOp WRITE_OP_UNSPECIFIED =
    WriteRel_WriteOp_WRITE_OP_UNSPECIFIED;
  static const WriteOp WRITE_OP_INSERT =
    WriteRel_WriteOp_WRITE_OP_INSERT;
  static const WriteOp WRITE_OP_DELETE =
    WriteRel_WriteOp_WRITE_OP_DELETE;
  static const WriteOp WRITE_OP_UPDATE =
    WriteRel_WriteOp_WRITE_OP_UPDATE;
  static const WriteOp WRITE_OP_CTAS =
    WriteRel_WriteOp_WRITE_OP_CTAS;
  static inline bool WriteOp_IsValid(int value) {
    return WriteRel_WriteOp_IsValid(value);
  }
  static const WriteOp WriteOp_MIN =
    WriteRel_WriteOp_WriteOp_MIN;
  static const WriteOp WriteOp_MAX =
    WriteRel_WriteOp_WriteOp_MAX;
  static const int WriteOp_ARRAYSIZE =
    WriteRel_WriteOp_WriteOp_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  WriteOp_descriptor() {
    return WriteRel_WriteOp_descriptor();
  }
  static inline const ::std::string& WriteOp_Name(WriteOp value) {
    return WriteRel_WriteOp_Name(value);
  }
  static inline bool WriteOp_Parse(const ::std::string& name,
      WriteOp* value) {
    return WriteRel_WriteOp_Parse(name, value);
  }

  typedef WriteRel_OutputMode OutputMode;
  static const OutputMode OUTPUT_MODE_UNSPECIFIED =
    WriteRel_OutputMode_OUTPUT_MODE_UNSPECIFIED;
  static const OutputMode OUTPUT_MODE_NO_OUTPUT =
    WriteRel_OutputMode_OUTPUT_MODE_NO_OUTPUT;
  static const OutputMode OUTPUT_MODE_MODIFIED_TUPLES =
    WriteRel_OutputMode_OUTPUT_MODE_MODIFIED_TUPLES;
  static inline bool OutputMode_IsValid(int value) {
    return WriteRel_OutputMode_IsValid(value);
  }
  static const OutputMode OutputMode_MIN =
    WriteRel_OutputMode_OutputMode_MIN;
  static const OutputMode OutputMode_MAX =
    WriteRel_OutputMode_OutputMode_MAX;
  static const int OutputMode_ARRAYSIZE =
    WriteRel_OutputMode_OutputMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OutputMode_descriptor() {
    return WriteRel_OutputMode_descriptor();
  }
  static inline const ::std::string& OutputMode_Name(OutputMode value) {
    return WriteRel_OutputMode_Name(value);
  }
  static inline bool OutputMode_Parse(const ::std::string& name,
      OutputMode* value) {
    return WriteRel_OutputMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .substrait.NamedStruct table_schema = 3;
  bool has_table_schema() const;
  void clear_table_schema();
  static const int kTableSchemaFieldNumber = 3;
  private:
  const ::substrait::NamedStruct& _internal_table_schema() const;
  public:
  const ::substrait::NamedStruct& table_schema() const;
  ::substrait::NamedStruct* release_table_schema();
  ::substrait::NamedStruct* mutable_table_schema();
  void set_allocated_table_schema(::substrait::NamedStruct* table_schema);

  // .substrait.Rel input = 5;
  bool has_input() const;
  void clear_input();
  static const int kInputFieldNumber = 5;
  private:
  const ::substrait::Rel& _internal_input() const;
  public:
  const ::substrait::Rel& input() const;
  ::substrait::Rel* release_input();
  ::substrait::Rel* mutable_input();
  void set_allocated_input(::substrait::Rel* input);

  // .substrait.WriteRel.WriteOp op = 4;
  void clear_op();
  static const int kOpFieldNumber = 4;
  ::substrait::WriteRel_WriteOp op() const;
  void set_op(::substrait::WriteRel_WriteOp value);

  // .substrait.WriteRel.OutputMode output = 6;
  void clear_output();
  static const int kOutputFieldNumber = 6;
  ::substrait::WriteRel_OutputMode output() const;
  void set_output(::substrait::WriteRel_OutputMode value);

  // .substrait.NamedObjectWrite named_table = 1;
  bool has_named_table() const;
  void clear_named_table();
  static const int kNamedTableFieldNumber = 1;
  private:
  const ::substrait::NamedObjectWrite& _internal_named_table() const;
  public:
  const ::substrait::NamedObjectWrite& named_table() const;
  ::substrait::NamedObjectWrite* release_named_table();
  ::substrait::NamedObjectWrite* mutable_named_table();
  void set_allocated_named_table(::substrait::NamedObjectWrite* named_table);

  // .substrait.ExtensionObject extension_table = 2;
  bool has_extension_table() const;
  void clear_extension_table();
  static const int kExtensionTableFieldNumber = 2;
  private:
  const ::substrait::ExtensionObject& _internal_extension_table() const;
  public:
  const ::substrait::ExtensionObject& extension_table() const;
  ::substrait::ExtensionObject* release_extension_table();
  ::substrait::ExtensionObject* mutable_extension_table();
  void set_allocated_extension_table(::substrait::ExtensionObject* extension_table);

  void clear_write_type();
  WriteTypeCase write_type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.WriteRel)
 private:
  void set_has_named_table();
  void set_has_extension_table();

  inline bool has_write_type() const;
  inline void clear_has_write_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::substrait::NamedStruct* table_schema_;
  ::substrait::Rel* input_;
  int op_;
  int output_;
  union WriteTypeUnion {
    WriteTypeUnion() {}
    ::substrait::NamedObjectWrite* named_table_;
    ::substrait::ExtensionObject* extension_table_;
  } write_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HashJoinRel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.HashJoinRel) */ {
 public:
  HashJoinRel();
  virtual ~HashJoinRel();

  HashJoinRel(const HashJoinRel& from);

  inline HashJoinRel& operator=(const HashJoinRel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HashJoinRel(HashJoinRel&& from) noexcept
    : HashJoinRel() {
    *this = ::std::move(from);
  }

  inline HashJoinRel& operator=(HashJoinRel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HashJoinRel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HashJoinRel* internal_default_instance() {
    return reinterpret_cast<const HashJoinRel*>(
               &_HashJoinRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  void Swap(HashJoinRel* other);
  friend void swap(HashJoinRel& a, HashJoinRel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HashJoinRel* New() const final {
    return CreateMaybeMessage<HashJoinRel>(NULL);
  }

  HashJoinRel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HashJoinRel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HashJoinRel& from);
  void MergeFrom(const HashJoinRel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HashJoinRel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef HashJoinRel_JoinType JoinType;
  static const JoinType JOIN_TYPE_UNSPECIFIED =
    HashJoinRel_JoinType_JOIN_TYPE_UNSPECIFIED;
  static const JoinType JOIN_TYPE_INNER =
    HashJoinRel_JoinType_JOIN_TYPE_INNER;
  static const JoinType JOIN_TYPE_OUTER =
    HashJoinRel_JoinType_JOIN_TYPE_OUTER;
  static const JoinType JOIN_TYPE_LEFT =
    HashJoinRel_JoinType_JOIN_TYPE_LEFT;
  static const JoinType JOIN_TYPE_RIGHT =
    HashJoinRel_JoinType_JOIN_TYPE_RIGHT;
  static const JoinType JOIN_TYPE_LEFT_SEMI =
    HashJoinRel_JoinType_JOIN_TYPE_LEFT_SEMI;
  static const JoinType JOIN_TYPE_RIGHT_SEMI =
    HashJoinRel_JoinType_JOIN_TYPE_RIGHT_SEMI;
  static const JoinType JOIN_TYPE_LEFT_ANTI =
    HashJoinRel_JoinType_JOIN_TYPE_LEFT_ANTI;
  static const JoinType JOIN_TYPE_RIGHT_ANTI =
    HashJoinRel_JoinType_JOIN_TYPE_RIGHT_ANTI;
  static inline bool JoinType_IsValid(int value) {
    return HashJoinRel_JoinType_IsValid(value);
  }
  static const JoinType JoinType_MIN =
    HashJoinRel_JoinType_JoinType_MIN;
  static const JoinType JoinType_MAX =
    HashJoinRel_JoinType_JoinType_MAX;
  static const int JoinType_ARRAYSIZE =
    HashJoinRel_JoinType_JoinType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  JoinType_descriptor() {
    return HashJoinRel_JoinType_descriptor();
  }
  static inline const ::std::string& JoinType_Name(JoinType value) {
    return HashJoinRel_JoinType_Name(value);
  }
  static inline bool JoinType_Parse(const ::std::string& name,
      JoinType* value) {
    return HashJoinRel_JoinType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .substrait.Expression.FieldReference left_keys = 4;
  int left_keys_size() const;
  void clear_left_keys();
  static const int kLeftKeysFieldNumber = 4;
  ::substrait::Expression_FieldReference* mutable_left_keys(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression_FieldReference >*
      mutable_left_keys();
  const ::substrait::Expression_FieldReference& left_keys(int index) const;
  ::substrait::Expression_FieldReference* add_left_keys();
  const ::google::protobuf::RepeatedPtrField< ::substrait::Expression_FieldReference >&
      left_keys() const;

  // repeated .substrait.Expression.FieldReference right_keys = 5;
  int right_keys_size() const;
  void clear_right_keys();
  static const int kRightKeysFieldNumber = 5;
  ::substrait::Expression_FieldReference* mutable_right_keys(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression_FieldReference >*
      mutable_right_keys();
  const ::substrait::Expression_FieldReference& right_keys(int index) const;
  ::substrait::Expression_FieldReference* add_right_keys();
  const ::google::protobuf::RepeatedPtrField< ::substrait::Expression_FieldReference >&
      right_keys() const;

  // .substrait.RelCommon common = 1;
  bool has_common() const;
  void clear_common();
  static const int kCommonFieldNumber = 1;
  private:
  const ::substrait::RelCommon& _internal_common() const;
  public:
  const ::substrait::RelCommon& common() const;
  ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* common);

  // .substrait.Rel left = 2;
  bool has_left() const;
  void clear_left();
  static const int kLeftFieldNumber = 2;
  private:
  const ::substrait::Rel& _internal_left() const;
  public:
  const ::substrait::Rel& left() const;
  ::substrait::Rel* release_left();
  ::substrait::Rel* mutable_left();
  void set_allocated_left(::substrait::Rel* left);

  // .substrait.Rel right = 3;
  bool has_right() const;
  void clear_right();
  static const int kRightFieldNumber = 3;
  private:
  const ::substrait::Rel& _internal_right() const;
  public:
  const ::substrait::Rel& right() const;
  ::substrait::Rel* release_right();
  ::substrait::Rel* mutable_right();
  void set_allocated_right(::substrait::Rel* right);

  // .substrait.Expression post_join_filter = 6;
  bool has_post_join_filter() const;
  void clear_post_join_filter();
  static const int kPostJoinFilterFieldNumber = 6;
  private:
  const ::substrait::Expression& _internal_post_join_filter() const;
  public:
  const ::substrait::Expression& post_join_filter() const;
  ::substrait::Expression* release_post_join_filter();
  ::substrait::Expression* mutable_post_join_filter();
  void set_allocated_post_join_filter(::substrait::Expression* post_join_filter);

  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension();
  static const int kAdvancedExtensionFieldNumber = 10;
  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  public:
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension);

  // .substrait.HashJoinRel.JoinType type = 7;
  void clear_type();
  static const int kTypeFieldNumber = 7;
  ::substrait::HashJoinRel_JoinType type() const;
  void set_type(::substrait::HashJoinRel_JoinType value);

  // @@protoc_insertion_point(class_scope:substrait.HashJoinRel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression_FieldReference > left_keys_;
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression_FieldReference > right_keys_;
  ::substrait::RelCommon* common_;
  ::substrait::Rel* left_;
  ::substrait::Rel* right_;
  ::substrait::Expression* post_join_filter_;
  ::substrait::extensions::AdvancedExtension* advanced_extension_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MergeJoinRel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.MergeJoinRel) */ {
 public:
  MergeJoinRel();
  virtual ~MergeJoinRel();

  MergeJoinRel(const MergeJoinRel& from);

  inline MergeJoinRel& operator=(const MergeJoinRel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MergeJoinRel(MergeJoinRel&& from) noexcept
    : MergeJoinRel() {
    *this = ::std::move(from);
  }

  inline MergeJoinRel& operator=(MergeJoinRel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MergeJoinRel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MergeJoinRel* internal_default_instance() {
    return reinterpret_cast<const MergeJoinRel*>(
               &_MergeJoinRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  void Swap(MergeJoinRel* other);
  friend void swap(MergeJoinRel& a, MergeJoinRel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MergeJoinRel* New() const final {
    return CreateMaybeMessage<MergeJoinRel>(NULL);
  }

  MergeJoinRel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MergeJoinRel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MergeJoinRel& from);
  void MergeFrom(const MergeJoinRel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MergeJoinRel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MergeJoinRel_JoinType JoinType;
  static const JoinType JOIN_TYPE_UNSPECIFIED =
    MergeJoinRel_JoinType_JOIN_TYPE_UNSPECIFIED;
  static const JoinType JOIN_TYPE_INNER =
    MergeJoinRel_JoinType_JOIN_TYPE_INNER;
  static const JoinType JOIN_TYPE_OUTER =
    MergeJoinRel_JoinType_JOIN_TYPE_OUTER;
  static const JoinType JOIN_TYPE_LEFT =
    MergeJoinRel_JoinType_JOIN_TYPE_LEFT;
  static const JoinType JOIN_TYPE_RIGHT =
    MergeJoinRel_JoinType_JOIN_TYPE_RIGHT;
  static const JoinType JOIN_TYPE_LEFT_SEMI =
    MergeJoinRel_JoinType_JOIN_TYPE_LEFT_SEMI;
  static const JoinType JOIN_TYPE_RIGHT_SEMI =
    MergeJoinRel_JoinType_JOIN_TYPE_RIGHT_SEMI;
  static const JoinType JOIN_TYPE_LEFT_ANTI =
    MergeJoinRel_JoinType_JOIN_TYPE_LEFT_ANTI;
  static const JoinType JOIN_TYPE_RIGHT_ANTI =
    MergeJoinRel_JoinType_JOIN_TYPE_RIGHT_ANTI;
  static inline bool JoinType_IsValid(int value) {
    return MergeJoinRel_JoinType_IsValid(value);
  }
  static const JoinType JoinType_MIN =
    MergeJoinRel_JoinType_JoinType_MIN;
  static const JoinType JoinType_MAX =
    MergeJoinRel_JoinType_JoinType_MAX;
  static const int JoinType_ARRAYSIZE =
    MergeJoinRel_JoinType_JoinType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  JoinType_descriptor() {
    return MergeJoinRel_JoinType_descriptor();
  }
  static inline const ::std::string& JoinType_Name(JoinType value) {
    return MergeJoinRel_JoinType_Name(value);
  }
  static inline bool JoinType_Parse(const ::std::string& name,
      JoinType* value) {
    return MergeJoinRel_JoinType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .substrait.Expression.FieldReference left_keys = 4;
  int left_keys_size() const;
  void clear_left_keys();
  static const int kLeftKeysFieldNumber = 4;
  ::substrait::Expression_FieldReference* mutable_left_keys(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression_FieldReference >*
      mutable_left_keys();
  const ::substrait::Expression_FieldReference& left_keys(int index) const;
  ::substrait::Expression_FieldReference* add_left_keys();
  const ::google::protobuf::RepeatedPtrField< ::substrait::Expression_FieldReference >&
      left_keys() const;

  // repeated .substrait.Expression.FieldReference right_keys = 5;
  int right_keys_size() const;
  void clear_right_keys();
  static const int kRightKeysFieldNumber = 5;
  ::substrait::Expression_FieldReference* mutable_right_keys(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression_FieldReference >*
      mutable_right_keys();
  const ::substrait::Expression_FieldReference& right_keys(int index) const;
  ::substrait::Expression_FieldReference* add_right_keys();
  const ::google::protobuf::RepeatedPtrField< ::substrait::Expression_FieldReference >&
      right_keys() const;

  // .substrait.RelCommon common = 1;
  bool has_common() const;
  void clear_common();
  static const int kCommonFieldNumber = 1;
  private:
  const ::substrait::RelCommon& _internal_common() const;
  public:
  const ::substrait::RelCommon& common() const;
  ::substrait::RelCommon* release_common();
  ::substrait::RelCommon* mutable_common();
  void set_allocated_common(::substrait::RelCommon* common);

  // .substrait.Rel left = 2;
  bool has_left() const;
  void clear_left();
  static const int kLeftFieldNumber = 2;
  private:
  const ::substrait::Rel& _internal_left() const;
  public:
  const ::substrait::Rel& left() const;
  ::substrait::Rel* release_left();
  ::substrait::Rel* mutable_left();
  void set_allocated_left(::substrait::Rel* left);

  // .substrait.Rel right = 3;
  bool has_right() const;
  void clear_right();
  static const int kRightFieldNumber = 3;
  private:
  const ::substrait::Rel& _internal_right() const;
  public:
  const ::substrait::Rel& right() const;
  ::substrait::Rel* release_right();
  ::substrait::Rel* mutable_right();
  void set_allocated_right(::substrait::Rel* right);

  // .substrait.Expression post_join_filter = 6;
  bool has_post_join_filter() const;
  void clear_post_join_filter();
  static const int kPostJoinFilterFieldNumber = 6;
  private:
  const ::substrait::Expression& _internal_post_join_filter() const;
  public:
  const ::substrait::Expression& post_join_filter() const;
  ::substrait::Expression* release_post_join_filter();
  ::substrait::Expression* mutable_post_join_filter();
  void set_allocated_post_join_filter(::substrait::Expression* post_join_filter);

  // .substrait.extensions.AdvancedExtension advanced_extension = 10;
  bool has_advanced_extension() const;
  void clear_advanced_extension();
  static const int kAdvancedExtensionFieldNumber = 10;
  private:
  const ::substrait::extensions::AdvancedExtension& _internal_advanced_extension() const;
  public:
  const ::substrait::extensions::AdvancedExtension& advanced_extension() const;
  ::substrait::extensions::AdvancedExtension* release_advanced_extension();
  ::substrait::extensions::AdvancedExtension* mutable_advanced_extension();
  void set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension);

  // .substrait.MergeJoinRel.JoinType type = 7;
  void clear_type();
  static const int kTypeFieldNumber = 7;
  ::substrait::MergeJoinRel_JoinType type() const;
  void set_type(::substrait::MergeJoinRel_JoinType value);

  // @@protoc_insertion_point(class_scope:substrait.MergeJoinRel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression_FieldReference > left_keys_;
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression_FieldReference > right_keys_;
  ::substrait::RelCommon* common_;
  ::substrait::Rel* left_;
  ::substrait::Rel* right_;
  ::substrait::Expression* post_join_filter_;
  ::substrait::extensions::AdvancedExtension* advanced_extension_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FunctionArgument : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.FunctionArgument) */ {
 public:
  FunctionArgument();
  virtual ~FunctionArgument();

  FunctionArgument(const FunctionArgument& from);

  inline FunctionArgument& operator=(const FunctionArgument& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FunctionArgument(FunctionArgument&& from) noexcept
    : FunctionArgument() {
    *this = ::std::move(from);
  }

  inline FunctionArgument& operator=(FunctionArgument&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FunctionArgument& default_instance();

  enum ArgTypeCase {
    kEnum = 1,
    kType = 2,
    kValue = 3,
    ARG_TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FunctionArgument* internal_default_instance() {
    return reinterpret_cast<const FunctionArgument*>(
               &_FunctionArgument_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  void Swap(FunctionArgument* other);
  friend void swap(FunctionArgument& a, FunctionArgument& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FunctionArgument* New() const final {
    return CreateMaybeMessage<FunctionArgument>(NULL);
  }

  FunctionArgument* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FunctionArgument>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FunctionArgument& from);
  void MergeFrom(const FunctionArgument& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FunctionArgument* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string enum = 1;
  private:
  bool has_enum_() const;
  public:
  void clear_enum_();
  static const int kEnumFieldNumber = 1;
  const ::std::string& enum_() const;
  void set_enum_(const ::std::string& value);
  #if LANG_CXX11
  void set_enum_(::std::string&& value);
  #endif
  void set_enum_(const char* value);
  void set_enum_(const char* value, size_t size);
  ::std::string* mutable_enum_();
  ::std::string* release_enum_();
  void set_allocated_enum_(::std::string* enum_);

  // .substrait.Type type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  private:
  const ::substrait::Type& _internal_type() const;
  public:
  const ::substrait::Type& type() const;
  ::substrait::Type* release_type();
  ::substrait::Type* mutable_type();
  void set_allocated_type(::substrait::Type* type);

  // .substrait.Expression value = 3;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  private:
  const ::substrait::Expression& _internal_value() const;
  public:
  const ::substrait::Expression& value() const;
  ::substrait::Expression* release_value();
  ::substrait::Expression* mutable_value();
  void set_allocated_value(::substrait::Expression* value);

  void clear_arg_type();
  ArgTypeCase arg_type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.FunctionArgument)
 private:
  void set_has_enum_();
  void set_has_type();
  void set_has_value();

  inline bool has_arg_type() const;
  inline void clear_has_arg_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ArgTypeUnion {
    ArgTypeUnion() {}
    ::google::protobuf::internal::ArenaStringPtr enum__;
    ::substrait::Type* type_;
    ::substrait::Expression* value_;
  } arg_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FunctionOption : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.FunctionOption) */ {
 public:
  FunctionOption();
  virtual ~FunctionOption();

  FunctionOption(const FunctionOption& from);

  inline FunctionOption& operator=(const FunctionOption& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FunctionOption(FunctionOption&& from) noexcept
    : FunctionOption() {
    *this = ::std::move(from);
  }

  inline FunctionOption& operator=(FunctionOption&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FunctionOption& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FunctionOption* internal_default_instance() {
    return reinterpret_cast<const FunctionOption*>(
               &_FunctionOption_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  void Swap(FunctionOption* other);
  friend void swap(FunctionOption& a, FunctionOption& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FunctionOption* New() const final {
    return CreateMaybeMessage<FunctionOption>(NULL);
  }

  FunctionOption* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FunctionOption>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FunctionOption& from);
  void MergeFrom(const FunctionOption& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FunctionOption* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string preference = 2;
  int preference_size() const;
  void clear_preference();
  static const int kPreferenceFieldNumber = 2;
  const ::std::string& preference(int index) const;
  ::std::string* mutable_preference(int index);
  void set_preference(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_preference(int index, ::std::string&& value);
  #endif
  void set_preference(int index, const char* value);
  void set_preference(int index, const char* value, size_t size);
  ::std::string* add_preference();
  void add_preference(const ::std::string& value);
  #if LANG_CXX11
  void add_preference(::std::string&& value);
  #endif
  void add_preference(const char* value);
  void add_preference(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& preference() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_preference();

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:substrait.FunctionOption)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> preference_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_Enum_Empty : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.Enum.Empty) */ {
 public:
  Expression_Enum_Empty();
  virtual ~Expression_Enum_Empty();

  Expression_Enum_Empty(const Expression_Enum_Empty& from);

  inline Expression_Enum_Empty& operator=(const Expression_Enum_Empty& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_Enum_Empty(Expression_Enum_Empty&& from) noexcept
    : Expression_Enum_Empty() {
    *this = ::std::move(from);
  }

  inline Expression_Enum_Empty& operator=(Expression_Enum_Empty&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_Enum_Empty& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_Enum_Empty* internal_default_instance() {
    return reinterpret_cast<const Expression_Enum_Empty*>(
               &_Expression_Enum_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  void Swap(Expression_Enum_Empty* other);
  friend void swap(Expression_Enum_Empty& a, Expression_Enum_Empty& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_Enum_Empty* New() const final {
    return CreateMaybeMessage<Expression_Enum_Empty>(NULL);
  }

  Expression_Enum_Empty* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_Enum_Empty>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_Enum_Empty& from);
  void MergeFrom(const Expression_Enum_Empty& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_Enum_Empty* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:substrait.Expression.Enum.Empty)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_Enum : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.Enum) */ {
 public:
  Expression_Enum();
  virtual ~Expression_Enum();

  Expression_Enum(const Expression_Enum& from);

  inline Expression_Enum& operator=(const Expression_Enum& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_Enum(Expression_Enum&& from) noexcept
    : Expression_Enum() {
    *this = ::std::move(from);
  }

  inline Expression_Enum& operator=(Expression_Enum&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_Enum& default_instance();

  enum EnumKindCase {
    kSpecified = 1,
    kUnspecified = 2,
    ENUM_KIND_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_Enum* internal_default_instance() {
    return reinterpret_cast<const Expression_Enum*>(
               &_Expression_Enum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  void Swap(Expression_Enum* other);
  friend void swap(Expression_Enum& a, Expression_Enum& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_Enum* New() const final {
    return CreateMaybeMessage<Expression_Enum>(NULL);
  }

  Expression_Enum* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_Enum>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_Enum& from);
  void MergeFrom(const Expression_Enum& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_Enum* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_Enum_Empty Empty;

  // accessors -------------------------------------------------------

  // string specified = 1;
  private:
  bool has_specified() const;
  public:
  void clear_specified();
  static const int kSpecifiedFieldNumber = 1;
  const ::std::string& specified() const;
  void set_specified(const ::std::string& value);
  #if LANG_CXX11
  void set_specified(::std::string&& value);
  #endif
  void set_specified(const char* value);
  void set_specified(const char* value, size_t size);
  ::std::string* mutable_specified();
  ::std::string* release_specified();
  void set_allocated_specified(::std::string* specified);

  // .substrait.Expression.Enum.Empty unspecified = 2;
  bool has_unspecified() const;
  void clear_unspecified();
  static const int kUnspecifiedFieldNumber = 2;
  private:
  const ::substrait::Expression_Enum_Empty& _internal_unspecified() const;
  public:
  const ::substrait::Expression_Enum_Empty& unspecified() const;
  ::substrait::Expression_Enum_Empty* release_unspecified();
  ::substrait::Expression_Enum_Empty* mutable_unspecified();
  void set_allocated_unspecified(::substrait::Expression_Enum_Empty* unspecified);

  void clear_enum_kind();
  EnumKindCase enum_kind_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.Enum)
 private:
  void set_has_specified();
  void set_has_unspecified();

  inline bool has_enum_kind() const;
  inline void clear_has_enum_kind();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union EnumKindUnion {
    EnumKindUnion() {}
    ::google::protobuf::internal::ArenaStringPtr specified_;
    ::substrait::Expression_Enum_Empty* unspecified_;
  } enum_kind_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_Literal_VarChar : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.Literal.VarChar) */ {
 public:
  Expression_Literal_VarChar();
  virtual ~Expression_Literal_VarChar();

  Expression_Literal_VarChar(const Expression_Literal_VarChar& from);

  inline Expression_Literal_VarChar& operator=(const Expression_Literal_VarChar& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_Literal_VarChar(Expression_Literal_VarChar&& from) noexcept
    : Expression_Literal_VarChar() {
    *this = ::std::move(from);
  }

  inline Expression_Literal_VarChar& operator=(Expression_Literal_VarChar&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_Literal_VarChar& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_Literal_VarChar* internal_default_instance() {
    return reinterpret_cast<const Expression_Literal_VarChar*>(
               &_Expression_Literal_VarChar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  void Swap(Expression_Literal_VarChar* other);
  friend void swap(Expression_Literal_VarChar& a, Expression_Literal_VarChar& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_Literal_VarChar* New() const final {
    return CreateMaybeMessage<Expression_Literal_VarChar>(NULL);
  }

  Expression_Literal_VarChar* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_Literal_VarChar>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_Literal_VarChar& from);
  void MergeFrom(const Expression_Literal_VarChar& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_Literal_VarChar* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // uint32 length = 2;
  void clear_length();
  static const int kLengthFieldNumber = 2;
  ::google::protobuf::uint32 length() const;
  void set_length(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:substrait.Expression.Literal.VarChar)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::uint32 length_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_Literal_Decimal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.Literal.Decimal) */ {
 public:
  Expression_Literal_Decimal();
  virtual ~Expression_Literal_Decimal();

  Expression_Literal_Decimal(const Expression_Literal_Decimal& from);

  inline Expression_Literal_Decimal& operator=(const Expression_Literal_Decimal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_Literal_Decimal(Expression_Literal_Decimal&& from) noexcept
    : Expression_Literal_Decimal() {
    *this = ::std::move(from);
  }

  inline Expression_Literal_Decimal& operator=(Expression_Literal_Decimal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_Literal_Decimal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_Literal_Decimal* internal_default_instance() {
    return reinterpret_cast<const Expression_Literal_Decimal*>(
               &_Expression_Literal_Decimal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  void Swap(Expression_Literal_Decimal* other);
  friend void swap(Expression_Literal_Decimal& a, Expression_Literal_Decimal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_Literal_Decimal* New() const final {
    return CreateMaybeMessage<Expression_Literal_Decimal>(NULL);
  }

  Expression_Literal_Decimal* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_Literal_Decimal>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_Literal_Decimal& from);
  void MergeFrom(const Expression_Literal_Decimal& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_Literal_Decimal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // int32 precision = 2;
  void clear_precision();
  static const int kPrecisionFieldNumber = 2;
  ::google::protobuf::int32 precision() const;
  void set_precision(::google::protobuf::int32 value);

  // int32 scale = 3;
  void clear_scale();
  static const int kScaleFieldNumber = 3;
  ::google::protobuf::int32 scale() const;
  void set_scale(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:substrait.Expression.Literal.Decimal)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::int32 precision_;
  ::google::protobuf::int32 scale_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_Literal_Map_KeyValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.Literal.Map.KeyValue) */ {
 public:
  Expression_Literal_Map_KeyValue();
  virtual ~Expression_Literal_Map_KeyValue();

  Expression_Literal_Map_KeyValue(const Expression_Literal_Map_KeyValue& from);

  inline Expression_Literal_Map_KeyValue& operator=(const Expression_Literal_Map_KeyValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_Literal_Map_KeyValue(Expression_Literal_Map_KeyValue&& from) noexcept
    : Expression_Literal_Map_KeyValue() {
    *this = ::std::move(from);
  }

  inline Expression_Literal_Map_KeyValue& operator=(Expression_Literal_Map_KeyValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_Literal_Map_KeyValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_Literal_Map_KeyValue* internal_default_instance() {
    return reinterpret_cast<const Expression_Literal_Map_KeyValue*>(
               &_Expression_Literal_Map_KeyValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  void Swap(Expression_Literal_Map_KeyValue* other);
  friend void swap(Expression_Literal_Map_KeyValue& a, Expression_Literal_Map_KeyValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_Literal_Map_KeyValue* New() const final {
    return CreateMaybeMessage<Expression_Literal_Map_KeyValue>(NULL);
  }

  Expression_Literal_Map_KeyValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_Literal_Map_KeyValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_Literal_Map_KeyValue& from);
  void MergeFrom(const Expression_Literal_Map_KeyValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_Literal_Map_KeyValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .substrait.Expression.Literal key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  private:
  const ::substrait::Expression_Literal& _internal_key() const;
  public:
  const ::substrait::Expression_Literal& key() const;
  ::substrait::Expression_Literal* release_key();
  ::substrait::Expression_Literal* mutable_key();
  void set_allocated_key(::substrait::Expression_Literal* key);

  // .substrait.Expression.Literal value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  private:
  const ::substrait::Expression_Literal& _internal_value() const;
  public:
  const ::substrait::Expression_Literal& value() const;
  ::substrait::Expression_Literal* release_value();
  ::substrait::Expression_Literal* mutable_value();
  void set_allocated_value(::substrait::Expression_Literal* value);

  // @@protoc_insertion_point(class_scope:substrait.Expression.Literal.Map.KeyValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::substrait::Expression_Literal* key_;
  ::substrait::Expression_Literal* value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_Literal_Map : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.Literal.Map) */ {
 public:
  Expression_Literal_Map();
  virtual ~Expression_Literal_Map();

  Expression_Literal_Map(const Expression_Literal_Map& from);

  inline Expression_Literal_Map& operator=(const Expression_Literal_Map& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_Literal_Map(Expression_Literal_Map&& from) noexcept
    : Expression_Literal_Map() {
    *this = ::std::move(from);
  }

  inline Expression_Literal_Map& operator=(Expression_Literal_Map&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_Literal_Map& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_Literal_Map* internal_default_instance() {
    return reinterpret_cast<const Expression_Literal_Map*>(
               &_Expression_Literal_Map_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  void Swap(Expression_Literal_Map* other);
  friend void swap(Expression_Literal_Map& a, Expression_Literal_Map& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_Literal_Map* New() const final {
    return CreateMaybeMessage<Expression_Literal_Map>(NULL);
  }

  Expression_Literal_Map* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_Literal_Map>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_Literal_Map& from);
  void MergeFrom(const Expression_Literal_Map& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_Literal_Map* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_Literal_Map_KeyValue KeyValue;

  // accessors -------------------------------------------------------

  // repeated .substrait.Expression.Literal.Map.KeyValue key_values = 1;
  int key_values_size() const;
  void clear_key_values();
  static const int kKeyValuesFieldNumber = 1;
  ::substrait::Expression_Literal_Map_KeyValue* mutable_key_values(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression_Literal_Map_KeyValue >*
      mutable_key_values();
  const ::substrait::Expression_Literal_Map_KeyValue& key_values(int index) const;
  ::substrait::Expression_Literal_Map_KeyValue* add_key_values();
  const ::google::protobuf::RepeatedPtrField< ::substrait::Expression_Literal_Map_KeyValue >&
      key_values() const;

  // @@protoc_insertion_point(class_scope:substrait.Expression.Literal.Map)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression_Literal_Map_KeyValue > key_values_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_Literal_IntervalYearToMonth : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.Literal.IntervalYearToMonth) */ {
 public:
  Expression_Literal_IntervalYearToMonth();
  virtual ~Expression_Literal_IntervalYearToMonth();

  Expression_Literal_IntervalYearToMonth(const Expression_Literal_IntervalYearToMonth& from);

  inline Expression_Literal_IntervalYearToMonth& operator=(const Expression_Literal_IntervalYearToMonth& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_Literal_IntervalYearToMonth(Expression_Literal_IntervalYearToMonth&& from) noexcept
    : Expression_Literal_IntervalYearToMonth() {
    *this = ::std::move(from);
  }

  inline Expression_Literal_IntervalYearToMonth& operator=(Expression_Literal_IntervalYearToMonth&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_Literal_IntervalYearToMonth& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_Literal_IntervalYearToMonth* internal_default_instance() {
    return reinterpret_cast<const Expression_Literal_IntervalYearToMonth*>(
               &_Expression_Literal_IntervalYearToMonth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  void Swap(Expression_Literal_IntervalYearToMonth* other);
  friend void swap(Expression_Literal_IntervalYearToMonth& a, Expression_Literal_IntervalYearToMonth& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_Literal_IntervalYearToMonth* New() const final {
    return CreateMaybeMessage<Expression_Literal_IntervalYearToMonth>(NULL);
  }

  Expression_Literal_IntervalYearToMonth* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_Literal_IntervalYearToMonth>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_Literal_IntervalYearToMonth& from);
  void MergeFrom(const Expression_Literal_IntervalYearToMonth& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_Literal_IntervalYearToMonth* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 years = 1;
  void clear_years();
  static const int kYearsFieldNumber = 1;
  ::google::protobuf::int32 years() const;
  void set_years(::google::protobuf::int32 value);

  // int32 months = 2;
  void clear_months();
  static const int kMonthsFieldNumber = 2;
  ::google::protobuf::int32 months() const;
  void set_months(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:substrait.Expression.Literal.IntervalYearToMonth)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 years_;
  ::google::protobuf::int32 months_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_Literal_IntervalDayToSecond : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.Literal.IntervalDayToSecond) */ {
 public:
  Expression_Literal_IntervalDayToSecond();
  virtual ~Expression_Literal_IntervalDayToSecond();

  Expression_Literal_IntervalDayToSecond(const Expression_Literal_IntervalDayToSecond& from);

  inline Expression_Literal_IntervalDayToSecond& operator=(const Expression_Literal_IntervalDayToSecond& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_Literal_IntervalDayToSecond(Expression_Literal_IntervalDayToSecond&& from) noexcept
    : Expression_Literal_IntervalDayToSecond() {
    *this = ::std::move(from);
  }

  inline Expression_Literal_IntervalDayToSecond& operator=(Expression_Literal_IntervalDayToSecond&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_Literal_IntervalDayToSecond& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_Literal_IntervalDayToSecond* internal_default_instance() {
    return reinterpret_cast<const Expression_Literal_IntervalDayToSecond*>(
               &_Expression_Literal_IntervalDayToSecond_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  void Swap(Expression_Literal_IntervalDayToSecond* other);
  friend void swap(Expression_Literal_IntervalDayToSecond& a, Expression_Literal_IntervalDayToSecond& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_Literal_IntervalDayToSecond* New() const final {
    return CreateMaybeMessage<Expression_Literal_IntervalDayToSecond>(NULL);
  }

  Expression_Literal_IntervalDayToSecond* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_Literal_IntervalDayToSecond>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_Literal_IntervalDayToSecond& from);
  void MergeFrom(const Expression_Literal_IntervalDayToSecond& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_Literal_IntervalDayToSecond* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 days = 1;
  void clear_days();
  static const int kDaysFieldNumber = 1;
  ::google::protobuf::int32 days() const;
  void set_days(::google::protobuf::int32 value);

  // int32 seconds = 2;
  void clear_seconds();
  static const int kSecondsFieldNumber = 2;
  ::google::protobuf::int32 seconds() const;
  void set_seconds(::google::protobuf::int32 value);

  // int32 microseconds = 3;
  void clear_microseconds();
  static const int kMicrosecondsFieldNumber = 3;
  ::google::protobuf::int32 microseconds() const;
  void set_microseconds(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:substrait.Expression.Literal.IntervalDayToSecond)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 days_;
  ::google::protobuf::int32 seconds_;
  ::google::protobuf::int32 microseconds_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_Literal_Struct : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.Literal.Struct) */ {
 public:
  Expression_Literal_Struct();
  virtual ~Expression_Literal_Struct();

  Expression_Literal_Struct(const Expression_Literal_Struct& from);

  inline Expression_Literal_Struct& operator=(const Expression_Literal_Struct& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_Literal_Struct(Expression_Literal_Struct&& from) noexcept
    : Expression_Literal_Struct() {
    *this = ::std::move(from);
  }

  inline Expression_Literal_Struct& operator=(Expression_Literal_Struct&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_Literal_Struct& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_Literal_Struct* internal_default_instance() {
    return reinterpret_cast<const Expression_Literal_Struct*>(
               &_Expression_Literal_Struct_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  void Swap(Expression_Literal_Struct* other);
  friend void swap(Expression_Literal_Struct& a, Expression_Literal_Struct& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_Literal_Struct* New() const final {
    return CreateMaybeMessage<Expression_Literal_Struct>(NULL);
  }

  Expression_Literal_Struct* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_Literal_Struct>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_Literal_Struct& from);
  void MergeFrom(const Expression_Literal_Struct& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_Literal_Struct* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .substrait.Expression.Literal fields = 1;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 1;
  ::substrait::Expression_Literal* mutable_fields(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression_Literal >*
      mutable_fields();
  const ::substrait::Expression_Literal& fields(int index) const;
  ::substrait::Expression_Literal* add_fields();
  const ::google::protobuf::RepeatedPtrField< ::substrait::Expression_Literal >&
      fields() const;

  // @@protoc_insertion_point(class_scope:substrait.Expression.Literal.Struct)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression_Literal > fields_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_Literal_List : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.Literal.List) */ {
 public:
  Expression_Literal_List();
  virtual ~Expression_Literal_List();

  Expression_Literal_List(const Expression_Literal_List& from);

  inline Expression_Literal_List& operator=(const Expression_Literal_List& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_Literal_List(Expression_Literal_List&& from) noexcept
    : Expression_Literal_List() {
    *this = ::std::move(from);
  }

  inline Expression_Literal_List& operator=(Expression_Literal_List&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_Literal_List& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_Literal_List* internal_default_instance() {
    return reinterpret_cast<const Expression_Literal_List*>(
               &_Expression_Literal_List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  void Swap(Expression_Literal_List* other);
  friend void swap(Expression_Literal_List& a, Expression_Literal_List& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_Literal_List* New() const final {
    return CreateMaybeMessage<Expression_Literal_List>(NULL);
  }

  Expression_Literal_List* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_Literal_List>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_Literal_List& from);
  void MergeFrom(const Expression_Literal_List& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_Literal_List* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .substrait.Expression.Literal values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  ::substrait::Expression_Literal* mutable_values(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression_Literal >*
      mutable_values();
  const ::substrait::Expression_Literal& values(int index) const;
  ::substrait::Expression_Literal* add_values();
  const ::google::protobuf::RepeatedPtrField< ::substrait::Expression_Literal >&
      values() const;

  // @@protoc_insertion_point(class_scope:substrait.Expression.Literal.List)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression_Literal > values_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_Literal_UserDefined : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.Literal.UserDefined) */ {
 public:
  Expression_Literal_UserDefined();
  virtual ~Expression_Literal_UserDefined();

  Expression_Literal_UserDefined(const Expression_Literal_UserDefined& from);

  inline Expression_Literal_UserDefined& operator=(const Expression_Literal_UserDefined& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_Literal_UserDefined(Expression_Literal_UserDefined&& from) noexcept
    : Expression_Literal_UserDefined() {
    *this = ::std::move(from);
  }

  inline Expression_Literal_UserDefined& operator=(Expression_Literal_UserDefined&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_Literal_UserDefined& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_Literal_UserDefined* internal_default_instance() {
    return reinterpret_cast<const Expression_Literal_UserDefined*>(
               &_Expression_Literal_UserDefined_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  void Swap(Expression_Literal_UserDefined* other);
  friend void swap(Expression_Literal_UserDefined& a, Expression_Literal_UserDefined& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_Literal_UserDefined* New() const final {
    return CreateMaybeMessage<Expression_Literal_UserDefined>(NULL);
  }

  Expression_Literal_UserDefined* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_Literal_UserDefined>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_Literal_UserDefined& from);
  void MergeFrom(const Expression_Literal_UserDefined& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_Literal_UserDefined* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .substrait.Type.Parameter type_parameters = 3;
  int type_parameters_size() const;
  void clear_type_parameters();
  static const int kTypeParametersFieldNumber = 3;
  ::substrait::Type_Parameter* mutable_type_parameters(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::Type_Parameter >*
      mutable_type_parameters();
  const ::substrait::Type_Parameter& type_parameters(int index) const;
  ::substrait::Type_Parameter* add_type_parameters();
  const ::google::protobuf::RepeatedPtrField< ::substrait::Type_Parameter >&
      type_parameters() const;

  // .google.protobuf.Any value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  private:
  const ::google::protobuf::Any& _internal_value() const;
  public:
  const ::google::protobuf::Any& value() const;
  ::google::protobuf::Any* release_value();
  ::google::protobuf::Any* mutable_value();
  void set_allocated_value(::google::protobuf::Any* value);

  // uint32 type_reference = 1;
  void clear_type_reference();
  static const int kTypeReferenceFieldNumber = 1;
  ::google::protobuf::uint32 type_reference() const;
  void set_type_reference(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:substrait.Expression.Literal.UserDefined)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::substrait::Type_Parameter > type_parameters_;
  ::google::protobuf::Any* value_;
  ::google::protobuf::uint32 type_reference_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_Literal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.Literal) */ {
 public:
  Expression_Literal();
  virtual ~Expression_Literal();

  Expression_Literal(const Expression_Literal& from);

  inline Expression_Literal& operator=(const Expression_Literal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_Literal(Expression_Literal&& from) noexcept
    : Expression_Literal() {
    *this = ::std::move(from);
  }

  inline Expression_Literal& operator=(Expression_Literal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_Literal& default_instance();

  enum LiteralTypeCase {
    kBoolean = 1,
    kI8 = 2,
    kI16 = 3,
    kI32 = 5,
    kI64 = 7,
    kFp32 = 10,
    kFp64 = 11,
    kString = 12,
    kBinary = 13,
    kTimestamp = 14,
    kDate = 16,
    kTime = 17,
    kIntervalYearToMonth = 19,
    kIntervalDayToSecond = 20,
    kFixedChar = 21,
    kVarChar = 22,
    kFixedBinary = 23,
    kDecimal = 24,
    kStruct = 25,
    kMap = 26,
    kTimestampTz = 27,
    kUuid = 28,
    kNull = 29,
    kList = 30,
    kEmptyList = 31,
    kEmptyMap = 32,
    kUserDefined = 33,
    LITERAL_TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_Literal* internal_default_instance() {
    return reinterpret_cast<const Expression_Literal*>(
               &_Expression_Literal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  void Swap(Expression_Literal* other);
  friend void swap(Expression_Literal& a, Expression_Literal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_Literal* New() const final {
    return CreateMaybeMessage<Expression_Literal>(NULL);
  }

  Expression_Literal* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_Literal>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_Literal& from);
  void MergeFrom(const Expression_Literal& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_Literal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_Literal_VarChar VarChar;
  typedef Expression_Literal_Decimal Decimal;
  typedef Expression_Literal_Map Map;
  typedef Expression_Literal_IntervalYearToMonth IntervalYearToMonth;
  typedef Expression_Literal_IntervalDayToSecond IntervalDayToSecond;
  typedef Expression_Literal_Struct Struct;
  typedef Expression_Literal_List List;
  typedef Expression_Literal_UserDefined UserDefined;

  // accessors -------------------------------------------------------

  // bool nullable = 50;
  void clear_nullable();
  static const int kNullableFieldNumber = 50;
  bool nullable() const;
  void set_nullable(bool value);

  // uint32 type_variation_reference = 51;
  void clear_type_variation_reference();
  static const int kTypeVariationReferenceFieldNumber = 51;
  ::google::protobuf::uint32 type_variation_reference() const;
  void set_type_variation_reference(::google::protobuf::uint32 value);

  // bool boolean = 1;
  private:
  bool has_boolean() const;
  public:
  void clear_boolean();
  static const int kBooleanFieldNumber = 1;
  bool boolean() const;
  void set_boolean(bool value);

  // int32 i8 = 2;
  private:
  bool has_i8() const;
  public:
  void clear_i8();
  static const int kI8FieldNumber = 2;
  ::google::protobuf::int32 i8() const;
  void set_i8(::google::protobuf::int32 value);

  // int32 i16 = 3;
  private:
  bool has_i16() const;
  public:
  void clear_i16();
  static const int kI16FieldNumber = 3;
  ::google::protobuf::int32 i16() const;
  void set_i16(::google::protobuf::int32 value);

  // int32 i32 = 5;
  private:
  bool has_i32() const;
  public:
  void clear_i32();
  static const int kI32FieldNumber = 5;
  ::google::protobuf::int32 i32() const;
  void set_i32(::google::protobuf::int32 value);

  // int64 i64 = 7;
  private:
  bool has_i64() const;
  public:
  void clear_i64();
  static const int kI64FieldNumber = 7;
  ::google::protobuf::int64 i64() const;
  void set_i64(::google::protobuf::int64 value);

  // float fp32 = 10;
  private:
  bool has_fp32() const;
  public:
  void clear_fp32();
  static const int kFp32FieldNumber = 10;
  float fp32() const;
  void set_fp32(float value);

  // double fp64 = 11;
  private:
  bool has_fp64() const;
  public:
  void clear_fp64();
  static const int kFp64FieldNumber = 11;
  double fp64() const;
  void set_fp64(double value);

  // string string = 12;
  private:
  bool has_string() const;
  public:
  void clear_string();
  static const int kStringFieldNumber = 12;
  const ::std::string& string() const;
  void set_string(const ::std::string& value);
  #if LANG_CXX11
  void set_string(::std::string&& value);
  #endif
  void set_string(const char* value);
  void set_string(const char* value, size_t size);
  ::std::string* mutable_string();
  ::std::string* release_string();
  void set_allocated_string(::std::string* string);

  // bytes binary = 13;
  private:
  bool has_binary() const;
  public:
  void clear_binary();
  static const int kBinaryFieldNumber = 13;
  const ::std::string& binary() const;
  void set_binary(const ::std::string& value);
  #if LANG_CXX11
  void set_binary(::std::string&& value);
  #endif
  void set_binary(const char* value);
  void set_binary(const void* value, size_t size);
  ::std::string* mutable_binary();
  ::std::string* release_binary();
  void set_allocated_binary(::std::string* binary);

  // int64 timestamp = 14;
  private:
  bool has_timestamp() const;
  public:
  void clear_timestamp();
  static const int kTimestampFieldNumber = 14;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // int32 date = 16;
  private:
  bool has_date() const;
  public:
  void clear_date();
  static const int kDateFieldNumber = 16;
  ::google::protobuf::int32 date() const;
  void set_date(::google::protobuf::int32 value);

  // int64 time = 17;
  private:
  bool has_time() const;
  public:
  void clear_time();
  static const int kTimeFieldNumber = 17;
  ::google::protobuf::int64 time() const;
  void set_time(::google::protobuf::int64 value);

  // .substrait.Expression.Literal.IntervalYearToMonth interval_year_to_month = 19;
  bool has_interval_year_to_month() const;
  void clear_interval_year_to_month();
  static const int kIntervalYearToMonthFieldNumber = 19;
  private:
  const ::substrait::Expression_Literal_IntervalYearToMonth& _internal_interval_year_to_month() const;
  public:
  const ::substrait::Expression_Literal_IntervalYearToMonth& interval_year_to_month() const;
  ::substrait::Expression_Literal_IntervalYearToMonth* release_interval_year_to_month();
  ::substrait::Expression_Literal_IntervalYearToMonth* mutable_interval_year_to_month();
  void set_allocated_interval_year_to_month(::substrait::Expression_Literal_IntervalYearToMonth* interval_year_to_month);

  // .substrait.Expression.Literal.IntervalDayToSecond interval_day_to_second = 20;
  bool has_interval_day_to_second() const;
  void clear_interval_day_to_second();
  static const int kIntervalDayToSecondFieldNumber = 20;
  private:
  const ::substrait::Expression_Literal_IntervalDayToSecond& _internal_interval_day_to_second() const;
  public:
  const ::substrait::Expression_Literal_IntervalDayToSecond& interval_day_to_second() const;
  ::substrait::Expression_Literal_IntervalDayToSecond* release_interval_day_to_second();
  ::substrait::Expression_Literal_IntervalDayToSecond* mutable_interval_day_to_second();
  void set_allocated_interval_day_to_second(::substrait::Expression_Literal_IntervalDayToSecond* interval_day_to_second);

  // string fixed_char = 21;
  private:
  bool has_fixed_char() const;
  public:
  void clear_fixed_char();
  static const int kFixedCharFieldNumber = 21;
  const ::std::string& fixed_char() const;
  void set_fixed_char(const ::std::string& value);
  #if LANG_CXX11
  void set_fixed_char(::std::string&& value);
  #endif
  void set_fixed_char(const char* value);
  void set_fixed_char(const char* value, size_t size);
  ::std::string* mutable_fixed_char();
  ::std::string* release_fixed_char();
  void set_allocated_fixed_char(::std::string* fixed_char);

  // .substrait.Expression.Literal.VarChar var_char = 22;
  bool has_var_char() const;
  void clear_var_char();
  static const int kVarCharFieldNumber = 22;
  private:
  const ::substrait::Expression_Literal_VarChar& _internal_var_char() const;
  public:
  const ::substrait::Expression_Literal_VarChar& var_char() const;
  ::substrait::Expression_Literal_VarChar* release_var_char();
  ::substrait::Expression_Literal_VarChar* mutable_var_char();
  void set_allocated_var_char(::substrait::Expression_Literal_VarChar* var_char);

  // bytes fixed_binary = 23;
  private:
  bool has_fixed_binary() const;
  public:
  void clear_fixed_binary();
  static const int kFixedBinaryFieldNumber = 23;
  const ::std::string& fixed_binary() const;
  void set_fixed_binary(const ::std::string& value);
  #if LANG_CXX11
  void set_fixed_binary(::std::string&& value);
  #endif
  void set_fixed_binary(const char* value);
  void set_fixed_binary(const void* value, size_t size);
  ::std::string* mutable_fixed_binary();
  ::std::string* release_fixed_binary();
  void set_allocated_fixed_binary(::std::string* fixed_binary);

  // .substrait.Expression.Literal.Decimal decimal = 24;
  bool has_decimal() const;
  void clear_decimal();
  static const int kDecimalFieldNumber = 24;
  private:
  const ::substrait::Expression_Literal_Decimal& _internal_decimal() const;
  public:
  const ::substrait::Expression_Literal_Decimal& decimal() const;
  ::substrait::Expression_Literal_Decimal* release_decimal();
  ::substrait::Expression_Literal_Decimal* mutable_decimal();
  void set_allocated_decimal(::substrait::Expression_Literal_Decimal* decimal);

  // .substrait.Expression.Literal.Struct struct = 25;
  bool has_struct_() const;
  void clear_struct_();
  static const int kStructFieldNumber = 25;
  private:
  const ::substrait::Expression_Literal_Struct& _internal_struct_() const;
  public:
  const ::substrait::Expression_Literal_Struct& struct_() const;
  ::substrait::Expression_Literal_Struct* release_struct_();
  ::substrait::Expression_Literal_Struct* mutable_struct_();
  void set_allocated_struct_(::substrait::Expression_Literal_Struct* struct_);

  // .substrait.Expression.Literal.Map map = 26;
  bool has_map() const;
  void clear_map();
  static const int kMapFieldNumber = 26;
  private:
  const ::substrait::Expression_Literal_Map& _internal_map() const;
  public:
  const ::substrait::Expression_Literal_Map& map() const;
  ::substrait::Expression_Literal_Map* release_map();
  ::substrait::Expression_Literal_Map* mutable_map();
  void set_allocated_map(::substrait::Expression_Literal_Map* map);

  // int64 timestamp_tz = 27;
  private:
  bool has_timestamp_tz() const;
  public:
  void clear_timestamp_tz();
  static const int kTimestampTzFieldNumber = 27;
  ::google::protobuf::int64 timestamp_tz() const;
  void set_timestamp_tz(::google::protobuf::int64 value);

  // bytes uuid = 28;
  private:
  bool has_uuid() const;
  public:
  void clear_uuid();
  static const int kUuidFieldNumber = 28;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const void* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // .substrait.Type null = 29;
  bool has_null() const;
  void clear_null();
  static const int kNullFieldNumber = 29;
  private:
  const ::substrait::Type& _internal_null() const;
  public:
  const ::substrait::Type& null() const;
  ::substrait::Type* release_null();
  ::substrait::Type* mutable_null();
  void set_allocated_null(::substrait::Type* null);

  // .substrait.Expression.Literal.List list = 30;
  bool has_list() const;
  void clear_list();
  static const int kListFieldNumber = 30;
  private:
  const ::substrait::Expression_Literal_List& _internal_list() const;
  public:
  const ::substrait::Expression_Literal_List& list() const;
  ::substrait::Expression_Literal_List* release_list();
  ::substrait::Expression_Literal_List* mutable_list();
  void set_allocated_list(::substrait::Expression_Literal_List* list);

  // .substrait.Type.List empty_list = 31;
  bool has_empty_list() const;
  void clear_empty_list();
  static const int kEmptyListFieldNumber = 31;
  private:
  const ::substrait::Type_List& _internal_empty_list() const;
  public:
  const ::substrait::Type_List& empty_list() const;
  ::substrait::Type_List* release_empty_list();
  ::substrait::Type_List* mutable_empty_list();
  void set_allocated_empty_list(::substrait::Type_List* empty_list);

  // .substrait.Type.Map empty_map = 32;
  bool has_empty_map() const;
  void clear_empty_map();
  static const int kEmptyMapFieldNumber = 32;
  private:
  const ::substrait::Type_Map& _internal_empty_map() const;
  public:
  const ::substrait::Type_Map& empty_map() const;
  ::substrait::Type_Map* release_empty_map();
  ::substrait::Type_Map* mutable_empty_map();
  void set_allocated_empty_map(::substrait::Type_Map* empty_map);

  // .substrait.Expression.Literal.UserDefined user_defined = 33;
  bool has_user_defined() const;
  void clear_user_defined();
  static const int kUserDefinedFieldNumber = 33;
  private:
  const ::substrait::Expression_Literal_UserDefined& _internal_user_defined() const;
  public:
  const ::substrait::Expression_Literal_UserDefined& user_defined() const;
  ::substrait::Expression_Literal_UserDefined* release_user_defined();
  ::substrait::Expression_Literal_UserDefined* mutable_user_defined();
  void set_allocated_user_defined(::substrait::Expression_Literal_UserDefined* user_defined);

  void clear_literal_type();
  LiteralTypeCase literal_type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.Literal)
 private:
  void set_has_boolean();
  void set_has_i8();
  void set_has_i16();
  void set_has_i32();
  void set_has_i64();
  void set_has_fp32();
  void set_has_fp64();
  void set_has_string();
  void set_has_binary();
  void set_has_timestamp();
  void set_has_date();
  void set_has_time();
  void set_has_interval_year_to_month();
  void set_has_interval_day_to_second();
  void set_has_fixed_char();
  void set_has_var_char();
  void set_has_fixed_binary();
  void set_has_decimal();
  void set_has_struct_();
  void set_has_map();
  void set_has_timestamp_tz();
  void set_has_uuid();
  void set_has_null();
  void set_has_list();
  void set_has_empty_list();
  void set_has_empty_map();
  void set_has_user_defined();

  inline bool has_literal_type() const;
  inline void clear_has_literal_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool nullable_;
  ::google::protobuf::uint32 type_variation_reference_;
  union LiteralTypeUnion {
    LiteralTypeUnion() {}
    bool boolean_;
    ::google::protobuf::int32 i8_;
    ::google::protobuf::int32 i16_;
    ::google::protobuf::int32 i32_;
    ::google::protobuf::int64 i64_;
    float fp32_;
    double fp64_;
    ::google::protobuf::internal::ArenaStringPtr string_;
    ::google::protobuf::internal::ArenaStringPtr binary_;
    ::google::protobuf::int64 timestamp_;
    ::google::protobuf::int32 date_;
    ::google::protobuf::int64 time_;
    ::substrait::Expression_Literal_IntervalYearToMonth* interval_year_to_month_;
    ::substrait::Expression_Literal_IntervalDayToSecond* interval_day_to_second_;
    ::google::protobuf::internal::ArenaStringPtr fixed_char_;
    ::substrait::Expression_Literal_VarChar* var_char_;
    ::google::protobuf::internal::ArenaStringPtr fixed_binary_;
    ::substrait::Expression_Literal_Decimal* decimal_;
    ::substrait::Expression_Literal_Struct* struct__;
    ::substrait::Expression_Literal_Map* map_;
    ::google::protobuf::int64 timestamp_tz_;
    ::google::protobuf::internal::ArenaStringPtr uuid_;
    ::substrait::Type* null_;
    ::substrait::Expression_Literal_List* list_;
    ::substrait::Type_List* empty_list_;
    ::substrait::Type_Map* empty_map_;
    ::substrait::Expression_Literal_UserDefined* user_defined_;
  } literal_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_Nested_Map_KeyValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.Nested.Map.KeyValue) */ {
 public:
  Expression_Nested_Map_KeyValue();
  virtual ~Expression_Nested_Map_KeyValue();

  Expression_Nested_Map_KeyValue(const Expression_Nested_Map_KeyValue& from);

  inline Expression_Nested_Map_KeyValue& operator=(const Expression_Nested_Map_KeyValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_Nested_Map_KeyValue(Expression_Nested_Map_KeyValue&& from) noexcept
    : Expression_Nested_Map_KeyValue() {
    *this = ::std::move(from);
  }

  inline Expression_Nested_Map_KeyValue& operator=(Expression_Nested_Map_KeyValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_Nested_Map_KeyValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_Nested_Map_KeyValue* internal_default_instance() {
    return reinterpret_cast<const Expression_Nested_Map_KeyValue*>(
               &_Expression_Nested_Map_KeyValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  void Swap(Expression_Nested_Map_KeyValue* other);
  friend void swap(Expression_Nested_Map_KeyValue& a, Expression_Nested_Map_KeyValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_Nested_Map_KeyValue* New() const final {
    return CreateMaybeMessage<Expression_Nested_Map_KeyValue>(NULL);
  }

  Expression_Nested_Map_KeyValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_Nested_Map_KeyValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_Nested_Map_KeyValue& from);
  void MergeFrom(const Expression_Nested_Map_KeyValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_Nested_Map_KeyValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .substrait.Expression key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  private:
  const ::substrait::Expression& _internal_key() const;
  public:
  const ::substrait::Expression& key() const;
  ::substrait::Expression* release_key();
  ::substrait::Expression* mutable_key();
  void set_allocated_key(::substrait::Expression* key);

  // .substrait.Expression value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  private:
  const ::substrait::Expression& _internal_value() const;
  public:
  const ::substrait::Expression& value() const;
  ::substrait::Expression* release_value();
  ::substrait::Expression* mutable_value();
  void set_allocated_value(::substrait::Expression* value);

  // @@protoc_insertion_point(class_scope:substrait.Expression.Nested.Map.KeyValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::substrait::Expression* key_;
  ::substrait::Expression* value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_Nested_Map : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.Nested.Map) */ {
 public:
  Expression_Nested_Map();
  virtual ~Expression_Nested_Map();

  Expression_Nested_Map(const Expression_Nested_Map& from);

  inline Expression_Nested_Map& operator=(const Expression_Nested_Map& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_Nested_Map(Expression_Nested_Map&& from) noexcept
    : Expression_Nested_Map() {
    *this = ::std::move(from);
  }

  inline Expression_Nested_Map& operator=(Expression_Nested_Map&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_Nested_Map& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_Nested_Map* internal_default_instance() {
    return reinterpret_cast<const Expression_Nested_Map*>(
               &_Expression_Nested_Map_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  void Swap(Expression_Nested_Map* other);
  friend void swap(Expression_Nested_Map& a, Expression_Nested_Map& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_Nested_Map* New() const final {
    return CreateMaybeMessage<Expression_Nested_Map>(NULL);
  }

  Expression_Nested_Map* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_Nested_Map>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_Nested_Map& from);
  void MergeFrom(const Expression_Nested_Map& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_Nested_Map* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_Nested_Map_KeyValue KeyValue;

  // accessors -------------------------------------------------------

  // repeated .substrait.Expression.Nested.Map.KeyValue key_values = 1;
  int key_values_size() const;
  void clear_key_values();
  static const int kKeyValuesFieldNumber = 1;
  ::substrait::Expression_Nested_Map_KeyValue* mutable_key_values(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression_Nested_Map_KeyValue >*
      mutable_key_values();
  const ::substrait::Expression_Nested_Map_KeyValue& key_values(int index) const;
  ::substrait::Expression_Nested_Map_KeyValue* add_key_values();
  const ::google::protobuf::RepeatedPtrField< ::substrait::Expression_Nested_Map_KeyValue >&
      key_values() const;

  // @@protoc_insertion_point(class_scope:substrait.Expression.Nested.Map)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression_Nested_Map_KeyValue > key_values_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_Nested_Struct : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.Nested.Struct) */ {
 public:
  Expression_Nested_Struct();
  virtual ~Expression_Nested_Struct();

  Expression_Nested_Struct(const Expression_Nested_Struct& from);

  inline Expression_Nested_Struct& operator=(const Expression_Nested_Struct& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_Nested_Struct(Expression_Nested_Struct&& from) noexcept
    : Expression_Nested_Struct() {
    *this = ::std::move(from);
  }

  inline Expression_Nested_Struct& operator=(Expression_Nested_Struct&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_Nested_Struct& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_Nested_Struct* internal_default_instance() {
    return reinterpret_cast<const Expression_Nested_Struct*>(
               &_Expression_Nested_Struct_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  void Swap(Expression_Nested_Struct* other);
  friend void swap(Expression_Nested_Struct& a, Expression_Nested_Struct& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_Nested_Struct* New() const final {
    return CreateMaybeMessage<Expression_Nested_Struct>(NULL);
  }

  Expression_Nested_Struct* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_Nested_Struct>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_Nested_Struct& from);
  void MergeFrom(const Expression_Nested_Struct& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_Nested_Struct* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .substrait.Expression fields = 1;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 1;
  ::substrait::Expression* mutable_fields(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression >*
      mutable_fields();
  const ::substrait::Expression& fields(int index) const;
  ::substrait::Expression* add_fields();
  const ::google::protobuf::RepeatedPtrField< ::substrait::Expression >&
      fields() const;

  // @@protoc_insertion_point(class_scope:substrait.Expression.Nested.Struct)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression > fields_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_Nested_List : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.Nested.List) */ {
 public:
  Expression_Nested_List();
  virtual ~Expression_Nested_List();

  Expression_Nested_List(const Expression_Nested_List& from);

  inline Expression_Nested_List& operator=(const Expression_Nested_List& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_Nested_List(Expression_Nested_List&& from) noexcept
    : Expression_Nested_List() {
    *this = ::std::move(from);
  }

  inline Expression_Nested_List& operator=(Expression_Nested_List&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_Nested_List& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_Nested_List* internal_default_instance() {
    return reinterpret_cast<const Expression_Nested_List*>(
               &_Expression_Nested_List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  void Swap(Expression_Nested_List* other);
  friend void swap(Expression_Nested_List& a, Expression_Nested_List& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_Nested_List* New() const final {
    return CreateMaybeMessage<Expression_Nested_List>(NULL);
  }

  Expression_Nested_List* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_Nested_List>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_Nested_List& from);
  void MergeFrom(const Expression_Nested_List& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_Nested_List* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .substrait.Expression values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  ::substrait::Expression* mutable_values(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression >*
      mutable_values();
  const ::substrait::Expression& values(int index) const;
  ::substrait::Expression* add_values();
  const ::google::protobuf::RepeatedPtrField< ::substrait::Expression >&
      values() const;

  // @@protoc_insertion_point(class_scope:substrait.Expression.Nested.List)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression > values_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_Nested : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.Nested) */ {
 public:
  Expression_Nested();
  virtual ~Expression_Nested();

  Expression_Nested(const Expression_Nested& from);

  inline Expression_Nested& operator=(const Expression_Nested& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_Nested(Expression_Nested&& from) noexcept
    : Expression_Nested() {
    *this = ::std::move(from);
  }

  inline Expression_Nested& operator=(Expression_Nested&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_Nested& default_instance();

  enum NestedTypeCase {
    kStruct = 3,
    kList = 4,
    kMap = 5,
    NESTED_TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_Nested* internal_default_instance() {
    return reinterpret_cast<const Expression_Nested*>(
               &_Expression_Nested_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  void Swap(Expression_Nested* other);
  friend void swap(Expression_Nested& a, Expression_Nested& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_Nested* New() const final {
    return CreateMaybeMessage<Expression_Nested>(NULL);
  }

  Expression_Nested* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_Nested>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_Nested& from);
  void MergeFrom(const Expression_Nested& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_Nested* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_Nested_Map Map;
  typedef Expression_Nested_Struct Struct;
  typedef Expression_Nested_List List;

  // accessors -------------------------------------------------------

  // bool nullable = 1;
  void clear_nullable();
  static const int kNullableFieldNumber = 1;
  bool nullable() const;
  void set_nullable(bool value);

  // uint32 type_variation_reference = 2;
  void clear_type_variation_reference();
  static const int kTypeVariationReferenceFieldNumber = 2;
  ::google::protobuf::uint32 type_variation_reference() const;
  void set_type_variation_reference(::google::protobuf::uint32 value);

  // .substrait.Expression.Nested.Struct struct = 3;
  bool has_struct_() const;
  void clear_struct_();
  static const int kStructFieldNumber = 3;
  private:
  const ::substrait::Expression_Nested_Struct& _internal_struct_() const;
  public:
  const ::substrait::Expression_Nested_Struct& struct_() const;
  ::substrait::Expression_Nested_Struct* release_struct_();
  ::substrait::Expression_Nested_Struct* mutable_struct_();
  void set_allocated_struct_(::substrait::Expression_Nested_Struct* struct_);

  // .substrait.Expression.Nested.List list = 4;
  bool has_list() const;
  void clear_list();
  static const int kListFieldNumber = 4;
  private:
  const ::substrait::Expression_Nested_List& _internal_list() const;
  public:
  const ::substrait::Expression_Nested_List& list() const;
  ::substrait::Expression_Nested_List* release_list();
  ::substrait::Expression_Nested_List* mutable_list();
  void set_allocated_list(::substrait::Expression_Nested_List* list);

  // .substrait.Expression.Nested.Map map = 5;
  bool has_map() const;
  void clear_map();
  static const int kMapFieldNumber = 5;
  private:
  const ::substrait::Expression_Nested_Map& _internal_map() const;
  public:
  const ::substrait::Expression_Nested_Map& map() const;
  ::substrait::Expression_Nested_Map* release_map();
  ::substrait::Expression_Nested_Map* mutable_map();
  void set_allocated_map(::substrait::Expression_Nested_Map* map);

  void clear_nested_type();
  NestedTypeCase nested_type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.Nested)
 private:
  void set_has_struct_();
  void set_has_list();
  void set_has_map();

  inline bool has_nested_type() const;
  inline void clear_has_nested_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool nullable_;
  ::google::protobuf::uint32 type_variation_reference_;
  union NestedTypeUnion {
    NestedTypeUnion() {}
    ::substrait::Expression_Nested_Struct* struct__;
    ::substrait::Expression_Nested_List* list_;
    ::substrait::Expression_Nested_Map* map_;
  } nested_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_ScalarFunction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.ScalarFunction) */ {
 public:
  Expression_ScalarFunction();
  virtual ~Expression_ScalarFunction();

  Expression_ScalarFunction(const Expression_ScalarFunction& from);

  inline Expression_ScalarFunction& operator=(const Expression_ScalarFunction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_ScalarFunction(Expression_ScalarFunction&& from) noexcept
    : Expression_ScalarFunction() {
    *this = ::std::move(from);
  }

  inline Expression_ScalarFunction& operator=(Expression_ScalarFunction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_ScalarFunction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_ScalarFunction* internal_default_instance() {
    return reinterpret_cast<const Expression_ScalarFunction*>(
               &_Expression_ScalarFunction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  void Swap(Expression_ScalarFunction* other);
  friend void swap(Expression_ScalarFunction& a, Expression_ScalarFunction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_ScalarFunction* New() const final {
    return CreateMaybeMessage<Expression_ScalarFunction>(NULL);
  }

  Expression_ScalarFunction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_ScalarFunction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_ScalarFunction& from);
  void MergeFrom(const Expression_ScalarFunction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_ScalarFunction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .substrait.Expression args = 2 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR int args_size() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_args();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kArgsFieldNumber = 2;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::substrait::Expression* mutable_args(int index);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::google::protobuf::RepeatedPtrField< ::substrait::Expression >*
      mutable_args();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::substrait::Expression& args(int index) const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::substrait::Expression* add_args();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::google::protobuf::RepeatedPtrField< ::substrait::Expression >&
      args() const;

  // repeated .substrait.FunctionArgument arguments = 4;
  int arguments_size() const;
  void clear_arguments();
  static const int kArgumentsFieldNumber = 4;
  ::substrait::FunctionArgument* mutable_arguments(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::FunctionArgument >*
      mutable_arguments();
  const ::substrait::FunctionArgument& arguments(int index) const;
  ::substrait::FunctionArgument* add_arguments();
  const ::google::protobuf::RepeatedPtrField< ::substrait::FunctionArgument >&
      arguments() const;

  // repeated .substrait.FunctionOption options = 5;
  int options_size() const;
  void clear_options();
  static const int kOptionsFieldNumber = 5;
  ::substrait::FunctionOption* mutable_options(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::FunctionOption >*
      mutable_options();
  const ::substrait::FunctionOption& options(int index) const;
  ::substrait::FunctionOption* add_options();
  const ::google::protobuf::RepeatedPtrField< ::substrait::FunctionOption >&
      options() const;

  // .substrait.Type output_type = 3;
  bool has_output_type() const;
  void clear_output_type();
  static const int kOutputTypeFieldNumber = 3;
  private:
  const ::substrait::Type& _internal_output_type() const;
  public:
  const ::substrait::Type& output_type() const;
  ::substrait::Type* release_output_type();
  ::substrait::Type* mutable_output_type();
  void set_allocated_output_type(::substrait::Type* output_type);

  // uint32 function_reference = 1;
  void clear_function_reference();
  static const int kFunctionReferenceFieldNumber = 1;
  ::google::protobuf::uint32 function_reference() const;
  void set_function_reference(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:substrait.Expression.ScalarFunction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression > args_;
  ::google::protobuf::RepeatedPtrField< ::substrait::FunctionArgument > arguments_;
  ::google::protobuf::RepeatedPtrField< ::substrait::FunctionOption > options_;
  ::substrait::Type* output_type_;
  ::google::protobuf::uint32 function_reference_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_WindowFunction_Bound_Preceding : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.WindowFunction.Bound.Preceding) */ {
 public:
  Expression_WindowFunction_Bound_Preceding();
  virtual ~Expression_WindowFunction_Bound_Preceding();

  Expression_WindowFunction_Bound_Preceding(const Expression_WindowFunction_Bound_Preceding& from);

  inline Expression_WindowFunction_Bound_Preceding& operator=(const Expression_WindowFunction_Bound_Preceding& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_WindowFunction_Bound_Preceding(Expression_WindowFunction_Bound_Preceding&& from) noexcept
    : Expression_WindowFunction_Bound_Preceding() {
    *this = ::std::move(from);
  }

  inline Expression_WindowFunction_Bound_Preceding& operator=(Expression_WindowFunction_Bound_Preceding&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_WindowFunction_Bound_Preceding& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_WindowFunction_Bound_Preceding* internal_default_instance() {
    return reinterpret_cast<const Expression_WindowFunction_Bound_Preceding*>(
               &_Expression_WindowFunction_Bound_Preceding_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  void Swap(Expression_WindowFunction_Bound_Preceding* other);
  friend void swap(Expression_WindowFunction_Bound_Preceding& a, Expression_WindowFunction_Bound_Preceding& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_WindowFunction_Bound_Preceding* New() const final {
    return CreateMaybeMessage<Expression_WindowFunction_Bound_Preceding>(NULL);
  }

  Expression_WindowFunction_Bound_Preceding* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_WindowFunction_Bound_Preceding>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_WindowFunction_Bound_Preceding& from);
  void MergeFrom(const Expression_WindowFunction_Bound_Preceding& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_WindowFunction_Bound_Preceding* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 offset = 1;
  void clear_offset();
  static const int kOffsetFieldNumber = 1;
  ::google::protobuf::int64 offset() const;
  void set_offset(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:substrait.Expression.WindowFunction.Bound.Preceding)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 offset_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_WindowFunction_Bound_Following : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.WindowFunction.Bound.Following) */ {
 public:
  Expression_WindowFunction_Bound_Following();
  virtual ~Expression_WindowFunction_Bound_Following();

  Expression_WindowFunction_Bound_Following(const Expression_WindowFunction_Bound_Following& from);

  inline Expression_WindowFunction_Bound_Following& operator=(const Expression_WindowFunction_Bound_Following& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_WindowFunction_Bound_Following(Expression_WindowFunction_Bound_Following&& from) noexcept
    : Expression_WindowFunction_Bound_Following() {
    *this = ::std::move(from);
  }

  inline Expression_WindowFunction_Bound_Following& operator=(Expression_WindowFunction_Bound_Following&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_WindowFunction_Bound_Following& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_WindowFunction_Bound_Following* internal_default_instance() {
    return reinterpret_cast<const Expression_WindowFunction_Bound_Following*>(
               &_Expression_WindowFunction_Bound_Following_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  void Swap(Expression_WindowFunction_Bound_Following* other);
  friend void swap(Expression_WindowFunction_Bound_Following& a, Expression_WindowFunction_Bound_Following& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_WindowFunction_Bound_Following* New() const final {
    return CreateMaybeMessage<Expression_WindowFunction_Bound_Following>(NULL);
  }

  Expression_WindowFunction_Bound_Following* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_WindowFunction_Bound_Following>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_WindowFunction_Bound_Following& from);
  void MergeFrom(const Expression_WindowFunction_Bound_Following& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_WindowFunction_Bound_Following* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 offset = 1;
  void clear_offset();
  static const int kOffsetFieldNumber = 1;
  ::google::protobuf::int64 offset() const;
  void set_offset(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:substrait.Expression.WindowFunction.Bound.Following)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 offset_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_WindowFunction_Bound_CurrentRow : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.WindowFunction.Bound.CurrentRow) */ {
 public:
  Expression_WindowFunction_Bound_CurrentRow();
  virtual ~Expression_WindowFunction_Bound_CurrentRow();

  Expression_WindowFunction_Bound_CurrentRow(const Expression_WindowFunction_Bound_CurrentRow& from);

  inline Expression_WindowFunction_Bound_CurrentRow& operator=(const Expression_WindowFunction_Bound_CurrentRow& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_WindowFunction_Bound_CurrentRow(Expression_WindowFunction_Bound_CurrentRow&& from) noexcept
    : Expression_WindowFunction_Bound_CurrentRow() {
    *this = ::std::move(from);
  }

  inline Expression_WindowFunction_Bound_CurrentRow& operator=(Expression_WindowFunction_Bound_CurrentRow&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_WindowFunction_Bound_CurrentRow& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_WindowFunction_Bound_CurrentRow* internal_default_instance() {
    return reinterpret_cast<const Expression_WindowFunction_Bound_CurrentRow*>(
               &_Expression_WindowFunction_Bound_CurrentRow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  void Swap(Expression_WindowFunction_Bound_CurrentRow* other);
  friend void swap(Expression_WindowFunction_Bound_CurrentRow& a, Expression_WindowFunction_Bound_CurrentRow& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_WindowFunction_Bound_CurrentRow* New() const final {
    return CreateMaybeMessage<Expression_WindowFunction_Bound_CurrentRow>(NULL);
  }

  Expression_WindowFunction_Bound_CurrentRow* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_WindowFunction_Bound_CurrentRow>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_WindowFunction_Bound_CurrentRow& from);
  void MergeFrom(const Expression_WindowFunction_Bound_CurrentRow& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_WindowFunction_Bound_CurrentRow* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:substrait.Expression.WindowFunction.Bound.CurrentRow)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_WindowFunction_Bound_Unbounded : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.WindowFunction.Bound.Unbounded) */ {
 public:
  Expression_WindowFunction_Bound_Unbounded();
  virtual ~Expression_WindowFunction_Bound_Unbounded();

  Expression_WindowFunction_Bound_Unbounded(const Expression_WindowFunction_Bound_Unbounded& from);

  inline Expression_WindowFunction_Bound_Unbounded& operator=(const Expression_WindowFunction_Bound_Unbounded& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_WindowFunction_Bound_Unbounded(Expression_WindowFunction_Bound_Unbounded&& from) noexcept
    : Expression_WindowFunction_Bound_Unbounded() {
    *this = ::std::move(from);
  }

  inline Expression_WindowFunction_Bound_Unbounded& operator=(Expression_WindowFunction_Bound_Unbounded&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_WindowFunction_Bound_Unbounded& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_WindowFunction_Bound_Unbounded* internal_default_instance() {
    return reinterpret_cast<const Expression_WindowFunction_Bound_Unbounded*>(
               &_Expression_WindowFunction_Bound_Unbounded_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  void Swap(Expression_WindowFunction_Bound_Unbounded* other);
  friend void swap(Expression_WindowFunction_Bound_Unbounded& a, Expression_WindowFunction_Bound_Unbounded& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_WindowFunction_Bound_Unbounded* New() const final {
    return CreateMaybeMessage<Expression_WindowFunction_Bound_Unbounded>(NULL);
  }

  Expression_WindowFunction_Bound_Unbounded* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_WindowFunction_Bound_Unbounded>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_WindowFunction_Bound_Unbounded& from);
  void MergeFrom(const Expression_WindowFunction_Bound_Unbounded& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_WindowFunction_Bound_Unbounded* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:substrait.Expression.WindowFunction.Bound.Unbounded)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_WindowFunction_Bound : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.WindowFunction.Bound) */ {
 public:
  Expression_WindowFunction_Bound();
  virtual ~Expression_WindowFunction_Bound();

  Expression_WindowFunction_Bound(const Expression_WindowFunction_Bound& from);

  inline Expression_WindowFunction_Bound& operator=(const Expression_WindowFunction_Bound& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_WindowFunction_Bound(Expression_WindowFunction_Bound&& from) noexcept
    : Expression_WindowFunction_Bound() {
    *this = ::std::move(from);
  }

  inline Expression_WindowFunction_Bound& operator=(Expression_WindowFunction_Bound&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_WindowFunction_Bound& default_instance();

  enum KindCase {
    kPreceding = 1,
    kFollowing = 2,
    kCurrentRow = 3,
    kUnbounded = 4,
    KIND_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_WindowFunction_Bound* internal_default_instance() {
    return reinterpret_cast<const Expression_WindowFunction_Bound*>(
               &_Expression_WindowFunction_Bound_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  void Swap(Expression_WindowFunction_Bound* other);
  friend void swap(Expression_WindowFunction_Bound& a, Expression_WindowFunction_Bound& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_WindowFunction_Bound* New() const final {
    return CreateMaybeMessage<Expression_WindowFunction_Bound>(NULL);
  }

  Expression_WindowFunction_Bound* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_WindowFunction_Bound>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_WindowFunction_Bound& from);
  void MergeFrom(const Expression_WindowFunction_Bound& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_WindowFunction_Bound* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_WindowFunction_Bound_Preceding Preceding;
  typedef Expression_WindowFunction_Bound_Following Following;
  typedef Expression_WindowFunction_Bound_CurrentRow CurrentRow;
  typedef Expression_WindowFunction_Bound_Unbounded Unbounded;

  // accessors -------------------------------------------------------

  // .substrait.Expression.WindowFunction.Bound.Preceding preceding = 1;
  bool has_preceding() const;
  void clear_preceding();
  static const int kPrecedingFieldNumber = 1;
  private:
  const ::substrait::Expression_WindowFunction_Bound_Preceding& _internal_preceding() const;
  public:
  const ::substrait::Expression_WindowFunction_Bound_Preceding& preceding() const;
  ::substrait::Expression_WindowFunction_Bound_Preceding* release_preceding();
  ::substrait::Expression_WindowFunction_Bound_Preceding* mutable_preceding();
  void set_allocated_preceding(::substrait::Expression_WindowFunction_Bound_Preceding* preceding);

  // .substrait.Expression.WindowFunction.Bound.Following following = 2;
  bool has_following() const;
  void clear_following();
  static const int kFollowingFieldNumber = 2;
  private:
  const ::substrait::Expression_WindowFunction_Bound_Following& _internal_following() const;
  public:
  const ::substrait::Expression_WindowFunction_Bound_Following& following() const;
  ::substrait::Expression_WindowFunction_Bound_Following* release_following();
  ::substrait::Expression_WindowFunction_Bound_Following* mutable_following();
  void set_allocated_following(::substrait::Expression_WindowFunction_Bound_Following* following);

  // .substrait.Expression.WindowFunction.Bound.CurrentRow current_row = 3;
  bool has_current_row() const;
  void clear_current_row();
  static const int kCurrentRowFieldNumber = 3;
  private:
  const ::substrait::Expression_WindowFunction_Bound_CurrentRow& _internal_current_row() const;
  public:
  const ::substrait::Expression_WindowFunction_Bound_CurrentRow& current_row() const;
  ::substrait::Expression_WindowFunction_Bound_CurrentRow* release_current_row();
  ::substrait::Expression_WindowFunction_Bound_CurrentRow* mutable_current_row();
  void set_allocated_current_row(::substrait::Expression_WindowFunction_Bound_CurrentRow* current_row);

  // .substrait.Expression.WindowFunction.Bound.Unbounded unbounded = 4;
  bool has_unbounded() const;
  void clear_unbounded();
  static const int kUnboundedFieldNumber = 4;
  private:
  const ::substrait::Expression_WindowFunction_Bound_Unbounded& _internal_unbounded() const;
  public:
  const ::substrait::Expression_WindowFunction_Bound_Unbounded& unbounded() const;
  ::substrait::Expression_WindowFunction_Bound_Unbounded* release_unbounded();
  ::substrait::Expression_WindowFunction_Bound_Unbounded* mutable_unbounded();
  void set_allocated_unbounded(::substrait::Expression_WindowFunction_Bound_Unbounded* unbounded);

  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.WindowFunction.Bound)
 private:
  void set_has_preceding();
  void set_has_following();
  void set_has_current_row();
  void set_has_unbounded();

  inline bool has_kind() const;
  inline void clear_has_kind();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union KindUnion {
    KindUnion() {}
    ::substrait::Expression_WindowFunction_Bound_Preceding* preceding_;
    ::substrait::Expression_WindowFunction_Bound_Following* following_;
    ::substrait::Expression_WindowFunction_Bound_CurrentRow* current_row_;
    ::substrait::Expression_WindowFunction_Bound_Unbounded* unbounded_;
  } kind_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_WindowFunction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.WindowFunction) */ {
 public:
  Expression_WindowFunction();
  virtual ~Expression_WindowFunction();

  Expression_WindowFunction(const Expression_WindowFunction& from);

  inline Expression_WindowFunction& operator=(const Expression_WindowFunction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_WindowFunction(Expression_WindowFunction&& from) noexcept
    : Expression_WindowFunction() {
    *this = ::std::move(from);
  }

  inline Expression_WindowFunction& operator=(Expression_WindowFunction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_WindowFunction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_WindowFunction* internal_default_instance() {
    return reinterpret_cast<const Expression_WindowFunction*>(
               &_Expression_WindowFunction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  void Swap(Expression_WindowFunction* other);
  friend void swap(Expression_WindowFunction& a, Expression_WindowFunction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_WindowFunction* New() const final {
    return CreateMaybeMessage<Expression_WindowFunction>(NULL);
  }

  Expression_WindowFunction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_WindowFunction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_WindowFunction& from);
  void MergeFrom(const Expression_WindowFunction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_WindowFunction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_WindowFunction_Bound Bound;

  // accessors -------------------------------------------------------

  // repeated .substrait.Expression partitions = 2;
  int partitions_size() const;
  void clear_partitions();
  static const int kPartitionsFieldNumber = 2;
  ::substrait::Expression* mutable_partitions(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression >*
      mutable_partitions();
  const ::substrait::Expression& partitions(int index) const;
  ::substrait::Expression* add_partitions();
  const ::google::protobuf::RepeatedPtrField< ::substrait::Expression >&
      partitions() const;

  // repeated .substrait.SortField sorts = 3;
  int sorts_size() const;
  void clear_sorts();
  static const int kSortsFieldNumber = 3;
  ::substrait::SortField* mutable_sorts(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::SortField >*
      mutable_sorts();
  const ::substrait::SortField& sorts(int index) const;
  ::substrait::SortField* add_sorts();
  const ::google::protobuf::RepeatedPtrField< ::substrait::SortField >&
      sorts() const;

  // repeated .substrait.Expression args = 8 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR int args_size() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_args();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kArgsFieldNumber = 8;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::substrait::Expression* mutable_args(int index);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::google::protobuf::RepeatedPtrField< ::substrait::Expression >*
      mutable_args();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::substrait::Expression& args(int index) const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::substrait::Expression* add_args();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::google::protobuf::RepeatedPtrField< ::substrait::Expression >&
      args() const;

  // repeated .substrait.FunctionArgument arguments = 9;
  int arguments_size() const;
  void clear_arguments();
  static const int kArgumentsFieldNumber = 9;
  ::substrait::FunctionArgument* mutable_arguments(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::FunctionArgument >*
      mutable_arguments();
  const ::substrait::FunctionArgument& arguments(int index) const;
  ::substrait::FunctionArgument* add_arguments();
  const ::google::protobuf::RepeatedPtrField< ::substrait::FunctionArgument >&
      arguments() const;

  // repeated .substrait.FunctionOption options = 11;
  int options_size() const;
  void clear_options();
  static const int kOptionsFieldNumber = 11;
  ::substrait::FunctionOption* mutable_options(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::FunctionOption >*
      mutable_options();
  const ::substrait::FunctionOption& options(int index) const;
  ::substrait::FunctionOption* add_options();
  const ::google::protobuf::RepeatedPtrField< ::substrait::FunctionOption >&
      options() const;

  // .substrait.Expression.WindowFunction.Bound upper_bound = 4;
  bool has_upper_bound() const;
  void clear_upper_bound();
  static const int kUpperBoundFieldNumber = 4;
  private:
  const ::substrait::Expression_WindowFunction_Bound& _internal_upper_bound() const;
  public:
  const ::substrait::Expression_WindowFunction_Bound& upper_bound() const;
  ::substrait::Expression_WindowFunction_Bound* release_upper_bound();
  ::substrait::Expression_WindowFunction_Bound* mutable_upper_bound();
  void set_allocated_upper_bound(::substrait::Expression_WindowFunction_Bound* upper_bound);

  // .substrait.Expression.WindowFunction.Bound lower_bound = 5;
  bool has_lower_bound() const;
  void clear_lower_bound();
  static const int kLowerBoundFieldNumber = 5;
  private:
  const ::substrait::Expression_WindowFunction_Bound& _internal_lower_bound() const;
  public:
  const ::substrait::Expression_WindowFunction_Bound& lower_bound() const;
  ::substrait::Expression_WindowFunction_Bound* release_lower_bound();
  ::substrait::Expression_WindowFunction_Bound* mutable_lower_bound();
  void set_allocated_lower_bound(::substrait::Expression_WindowFunction_Bound* lower_bound);

  // .substrait.Type output_type = 7;
  bool has_output_type() const;
  void clear_output_type();
  static const int kOutputTypeFieldNumber = 7;
  private:
  const ::substrait::Type& _internal_output_type() const;
  public:
  const ::substrait::Type& output_type() const;
  ::substrait::Type* release_output_type();
  ::substrait::Type* mutable_output_type();
  void set_allocated_output_type(::substrait::Type* output_type);

  // uint32 function_reference = 1;
  void clear_function_reference();
  static const int kFunctionReferenceFieldNumber = 1;
  ::google::protobuf::uint32 function_reference() const;
  void set_function_reference(::google::protobuf::uint32 value);

  // .substrait.AggregationPhase phase = 6;
  void clear_phase();
  static const int kPhaseFieldNumber = 6;
  ::substrait::AggregationPhase phase() const;
  void set_phase(::substrait::AggregationPhase value);

  // .substrait.AggregateFunction.AggregationInvocation invocation = 10;
  void clear_invocation();
  static const int kInvocationFieldNumber = 10;
  ::substrait::AggregateFunction_AggregationInvocation invocation() const;
  void set_invocation(::substrait::AggregateFunction_AggregationInvocation value);

  // @@protoc_insertion_point(class_scope:substrait.Expression.WindowFunction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression > partitions_;
  ::google::protobuf::RepeatedPtrField< ::substrait::SortField > sorts_;
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression > args_;
  ::google::protobuf::RepeatedPtrField< ::substrait::FunctionArgument > arguments_;
  ::google::protobuf::RepeatedPtrField< ::substrait::FunctionOption > options_;
  ::substrait::Expression_WindowFunction_Bound* upper_bound_;
  ::substrait::Expression_WindowFunction_Bound* lower_bound_;
  ::substrait::Type* output_type_;
  ::google::protobuf::uint32 function_reference_;
  int phase_;
  int invocation_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_IfThen_IfClause : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.IfThen.IfClause) */ {
 public:
  Expression_IfThen_IfClause();
  virtual ~Expression_IfThen_IfClause();

  Expression_IfThen_IfClause(const Expression_IfThen_IfClause& from);

  inline Expression_IfThen_IfClause& operator=(const Expression_IfThen_IfClause& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_IfThen_IfClause(Expression_IfThen_IfClause&& from) noexcept
    : Expression_IfThen_IfClause() {
    *this = ::std::move(from);
  }

  inline Expression_IfThen_IfClause& operator=(Expression_IfThen_IfClause&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_IfThen_IfClause& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_IfThen_IfClause* internal_default_instance() {
    return reinterpret_cast<const Expression_IfThen_IfClause*>(
               &_Expression_IfThen_IfClause_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  void Swap(Expression_IfThen_IfClause* other);
  friend void swap(Expression_IfThen_IfClause& a, Expression_IfThen_IfClause& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_IfThen_IfClause* New() const final {
    return CreateMaybeMessage<Expression_IfThen_IfClause>(NULL);
  }

  Expression_IfThen_IfClause* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_IfThen_IfClause>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_IfThen_IfClause& from);
  void MergeFrom(const Expression_IfThen_IfClause& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_IfThen_IfClause* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .substrait.Expression if = 1;
  bool has_if_() const;
  void clear_if_();
  static const int kIfFieldNumber = 1;
  private:
  const ::substrait::Expression& _internal_if_() const;
  public:
  const ::substrait::Expression& if_() const;
  ::substrait::Expression* release_if_();
  ::substrait::Expression* mutable_if_();
  void set_allocated_if_(::substrait::Expression* if_);

  // .substrait.Expression then = 2;
  bool has_then() const;
  void clear_then();
  static const int kThenFieldNumber = 2;
  private:
  const ::substrait::Expression& _internal_then() const;
  public:
  const ::substrait::Expression& then() const;
  ::substrait::Expression* release_then();
  ::substrait::Expression* mutable_then();
  void set_allocated_then(::substrait::Expression* then);

  // @@protoc_insertion_point(class_scope:substrait.Expression.IfThen.IfClause)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::substrait::Expression* if__;
  ::substrait::Expression* then_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_IfThen : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.IfThen) */ {
 public:
  Expression_IfThen();
  virtual ~Expression_IfThen();

  Expression_IfThen(const Expression_IfThen& from);

  inline Expression_IfThen& operator=(const Expression_IfThen& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_IfThen(Expression_IfThen&& from) noexcept
    : Expression_IfThen() {
    *this = ::std::move(from);
  }

  inline Expression_IfThen& operator=(Expression_IfThen&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_IfThen& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_IfThen* internal_default_instance() {
    return reinterpret_cast<const Expression_IfThen*>(
               &_Expression_IfThen_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  void Swap(Expression_IfThen* other);
  friend void swap(Expression_IfThen& a, Expression_IfThen& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_IfThen* New() const final {
    return CreateMaybeMessage<Expression_IfThen>(NULL);
  }

  Expression_IfThen* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_IfThen>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_IfThen& from);
  void MergeFrom(const Expression_IfThen& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_IfThen* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_IfThen_IfClause IfClause;

  // accessors -------------------------------------------------------

  // repeated .substrait.Expression.IfThen.IfClause ifs = 1;
  int ifs_size() const;
  void clear_ifs();
  static const int kIfsFieldNumber = 1;
  ::substrait::Expression_IfThen_IfClause* mutable_ifs(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression_IfThen_IfClause >*
      mutable_ifs();
  const ::substrait::Expression_IfThen_IfClause& ifs(int index) const;
  ::substrait::Expression_IfThen_IfClause* add_ifs();
  const ::google::protobuf::RepeatedPtrField< ::substrait::Expression_IfThen_IfClause >&
      ifs() const;

  // .substrait.Expression else = 2;
  bool has_else_() const;
  void clear_else_();
  static const int kElseFieldNumber = 2;
  private:
  const ::substrait::Expression& _internal_else_() const;
  public:
  const ::substrait::Expression& else_() const;
  ::substrait::Expression* release_else_();
  ::substrait::Expression* mutable_else_();
  void set_allocated_else_(::substrait::Expression* else_);

  // @@protoc_insertion_point(class_scope:substrait.Expression.IfThen)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression_IfThen_IfClause > ifs_;
  ::substrait::Expression* else__;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_Cast : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.Cast) */ {
 public:
  Expression_Cast();
  virtual ~Expression_Cast();

  Expression_Cast(const Expression_Cast& from);

  inline Expression_Cast& operator=(const Expression_Cast& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_Cast(Expression_Cast&& from) noexcept
    : Expression_Cast() {
    *this = ::std::move(from);
  }

  inline Expression_Cast& operator=(Expression_Cast&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_Cast& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_Cast* internal_default_instance() {
    return reinterpret_cast<const Expression_Cast*>(
               &_Expression_Cast_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  void Swap(Expression_Cast* other);
  friend void swap(Expression_Cast& a, Expression_Cast& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_Cast* New() const final {
    return CreateMaybeMessage<Expression_Cast>(NULL);
  }

  Expression_Cast* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_Cast>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_Cast& from);
  void MergeFrom(const Expression_Cast& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_Cast* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_Cast_FailureBehavior FailureBehavior;
  static const FailureBehavior FAILURE_BEHAVIOR_UNSPECIFIED =
    Expression_Cast_FailureBehavior_FAILURE_BEHAVIOR_UNSPECIFIED;
  static const FailureBehavior FAILURE_BEHAVIOR_RETURN_NULL =
    Expression_Cast_FailureBehavior_FAILURE_BEHAVIOR_RETURN_NULL;
  static const FailureBehavior FAILURE_BEHAVIOR_THROW_EXCEPTION =
    Expression_Cast_FailureBehavior_FAILURE_BEHAVIOR_THROW_EXCEPTION;
  static inline bool FailureBehavior_IsValid(int value) {
    return Expression_Cast_FailureBehavior_IsValid(value);
  }
  static const FailureBehavior FailureBehavior_MIN =
    Expression_Cast_FailureBehavior_FailureBehavior_MIN;
  static const FailureBehavior FailureBehavior_MAX =
    Expression_Cast_FailureBehavior_FailureBehavior_MAX;
  static const int FailureBehavior_ARRAYSIZE =
    Expression_Cast_FailureBehavior_FailureBehavior_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FailureBehavior_descriptor() {
    return Expression_Cast_FailureBehavior_descriptor();
  }
  static inline const ::std::string& FailureBehavior_Name(FailureBehavior value) {
    return Expression_Cast_FailureBehavior_Name(value);
  }
  static inline bool FailureBehavior_Parse(const ::std::string& name,
      FailureBehavior* value) {
    return Expression_Cast_FailureBehavior_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .substrait.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  private:
  const ::substrait::Type& _internal_type() const;
  public:
  const ::substrait::Type& type() const;
  ::substrait::Type* release_type();
  ::substrait::Type* mutable_type();
  void set_allocated_type(::substrait::Type* type);

  // .substrait.Expression input = 2;
  bool has_input() const;
  void clear_input();
  static const int kInputFieldNumber = 2;
  private:
  const ::substrait::Expression& _internal_input() const;
  public:
  const ::substrait::Expression& input() const;
  ::substrait::Expression* release_input();
  ::substrait::Expression* mutable_input();
  void set_allocated_input(::substrait::Expression* input);

  // .substrait.Expression.Cast.FailureBehavior failure_behavior = 3;
  void clear_failure_behavior();
  static const int kFailureBehaviorFieldNumber = 3;
  ::substrait::Expression_Cast_FailureBehavior failure_behavior() const;
  void set_failure_behavior(::substrait::Expression_Cast_FailureBehavior value);

  // @@protoc_insertion_point(class_scope:substrait.Expression.Cast)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::substrait::Type* type_;
  ::substrait::Expression* input_;
  int failure_behavior_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_SwitchExpression_IfValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.SwitchExpression.IfValue) */ {
 public:
  Expression_SwitchExpression_IfValue();
  virtual ~Expression_SwitchExpression_IfValue();

  Expression_SwitchExpression_IfValue(const Expression_SwitchExpression_IfValue& from);

  inline Expression_SwitchExpression_IfValue& operator=(const Expression_SwitchExpression_IfValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_SwitchExpression_IfValue(Expression_SwitchExpression_IfValue&& from) noexcept
    : Expression_SwitchExpression_IfValue() {
    *this = ::std::move(from);
  }

  inline Expression_SwitchExpression_IfValue& operator=(Expression_SwitchExpression_IfValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_SwitchExpression_IfValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_SwitchExpression_IfValue* internal_default_instance() {
    return reinterpret_cast<const Expression_SwitchExpression_IfValue*>(
               &_Expression_SwitchExpression_IfValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  void Swap(Expression_SwitchExpression_IfValue* other);
  friend void swap(Expression_SwitchExpression_IfValue& a, Expression_SwitchExpression_IfValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_SwitchExpression_IfValue* New() const final {
    return CreateMaybeMessage<Expression_SwitchExpression_IfValue>(NULL);
  }

  Expression_SwitchExpression_IfValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_SwitchExpression_IfValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_SwitchExpression_IfValue& from);
  void MergeFrom(const Expression_SwitchExpression_IfValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_SwitchExpression_IfValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .substrait.Expression.Literal if = 1;
  bool has_if_() const;
  void clear_if_();
  static const int kIfFieldNumber = 1;
  private:
  const ::substrait::Expression_Literal& _internal_if_() const;
  public:
  const ::substrait::Expression_Literal& if_() const;
  ::substrait::Expression_Literal* release_if_();
  ::substrait::Expression_Literal* mutable_if_();
  void set_allocated_if_(::substrait::Expression_Literal* if_);

  // .substrait.Expression then = 2;
  bool has_then() const;
  void clear_then();
  static const int kThenFieldNumber = 2;
  private:
  const ::substrait::Expression& _internal_then() const;
  public:
  const ::substrait::Expression& then() const;
  ::substrait::Expression* release_then();
  ::substrait::Expression* mutable_then();
  void set_allocated_then(::substrait::Expression* then);

  // @@protoc_insertion_point(class_scope:substrait.Expression.SwitchExpression.IfValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::substrait::Expression_Literal* if__;
  ::substrait::Expression* then_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_SwitchExpression : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.SwitchExpression) */ {
 public:
  Expression_SwitchExpression();
  virtual ~Expression_SwitchExpression();

  Expression_SwitchExpression(const Expression_SwitchExpression& from);

  inline Expression_SwitchExpression& operator=(const Expression_SwitchExpression& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_SwitchExpression(Expression_SwitchExpression&& from) noexcept
    : Expression_SwitchExpression() {
    *this = ::std::move(from);
  }

  inline Expression_SwitchExpression& operator=(Expression_SwitchExpression&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_SwitchExpression& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_SwitchExpression* internal_default_instance() {
    return reinterpret_cast<const Expression_SwitchExpression*>(
               &_Expression_SwitchExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  void Swap(Expression_SwitchExpression* other);
  friend void swap(Expression_SwitchExpression& a, Expression_SwitchExpression& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_SwitchExpression* New() const final {
    return CreateMaybeMessage<Expression_SwitchExpression>(NULL);
  }

  Expression_SwitchExpression* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_SwitchExpression>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_SwitchExpression& from);
  void MergeFrom(const Expression_SwitchExpression& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_SwitchExpression* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_SwitchExpression_IfValue IfValue;

  // accessors -------------------------------------------------------

  // repeated .substrait.Expression.SwitchExpression.IfValue ifs = 1;
  int ifs_size() const;
  void clear_ifs();
  static const int kIfsFieldNumber = 1;
  ::substrait::Expression_SwitchExpression_IfValue* mutable_ifs(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression_SwitchExpression_IfValue >*
      mutable_ifs();
  const ::substrait::Expression_SwitchExpression_IfValue& ifs(int index) const;
  ::substrait::Expression_SwitchExpression_IfValue* add_ifs();
  const ::google::protobuf::RepeatedPtrField< ::substrait::Expression_SwitchExpression_IfValue >&
      ifs() const;

  // .substrait.Expression else = 2;
  bool has_else_() const;
  void clear_else_();
  static const int kElseFieldNumber = 2;
  private:
  const ::substrait::Expression& _internal_else_() const;
  public:
  const ::substrait::Expression& else_() const;
  ::substrait::Expression* release_else_();
  ::substrait::Expression* mutable_else_();
  void set_allocated_else_(::substrait::Expression* else_);

  // .substrait.Expression match = 3;
  bool has_match() const;
  void clear_match();
  static const int kMatchFieldNumber = 3;
  private:
  const ::substrait::Expression& _internal_match() const;
  public:
  const ::substrait::Expression& match() const;
  ::substrait::Expression* release_match();
  ::substrait::Expression* mutable_match();
  void set_allocated_match(::substrait::Expression* match);

  // @@protoc_insertion_point(class_scope:substrait.Expression.SwitchExpression)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression_SwitchExpression_IfValue > ifs_;
  ::substrait::Expression* else__;
  ::substrait::Expression* match_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_SingularOrList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.SingularOrList) */ {
 public:
  Expression_SingularOrList();
  virtual ~Expression_SingularOrList();

  Expression_SingularOrList(const Expression_SingularOrList& from);

  inline Expression_SingularOrList& operator=(const Expression_SingularOrList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_SingularOrList(Expression_SingularOrList&& from) noexcept
    : Expression_SingularOrList() {
    *this = ::std::move(from);
  }

  inline Expression_SingularOrList& operator=(Expression_SingularOrList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_SingularOrList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_SingularOrList* internal_default_instance() {
    return reinterpret_cast<const Expression_SingularOrList*>(
               &_Expression_SingularOrList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  void Swap(Expression_SingularOrList* other);
  friend void swap(Expression_SingularOrList& a, Expression_SingularOrList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_SingularOrList* New() const final {
    return CreateMaybeMessage<Expression_SingularOrList>(NULL);
  }

  Expression_SingularOrList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_SingularOrList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_SingularOrList& from);
  void MergeFrom(const Expression_SingularOrList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_SingularOrList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .substrait.Expression options = 2;
  int options_size() const;
  void clear_options();
  static const int kOptionsFieldNumber = 2;
  ::substrait::Expression* mutable_options(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression >*
      mutable_options();
  const ::substrait::Expression& options(int index) const;
  ::substrait::Expression* add_options();
  const ::google::protobuf::RepeatedPtrField< ::substrait::Expression >&
      options() const;

  // .substrait.Expression value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  private:
  const ::substrait::Expression& _internal_value() const;
  public:
  const ::substrait::Expression& value() const;
  ::substrait::Expression* release_value();
  ::substrait::Expression* mutable_value();
  void set_allocated_value(::substrait::Expression* value);

  // @@protoc_insertion_point(class_scope:substrait.Expression.SingularOrList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression > options_;
  ::substrait::Expression* value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_MultiOrList_Record : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.MultiOrList.Record) */ {
 public:
  Expression_MultiOrList_Record();
  virtual ~Expression_MultiOrList_Record();

  Expression_MultiOrList_Record(const Expression_MultiOrList_Record& from);

  inline Expression_MultiOrList_Record& operator=(const Expression_MultiOrList_Record& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_MultiOrList_Record(Expression_MultiOrList_Record&& from) noexcept
    : Expression_MultiOrList_Record() {
    *this = ::std::move(from);
  }

  inline Expression_MultiOrList_Record& operator=(Expression_MultiOrList_Record&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_MultiOrList_Record& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_MultiOrList_Record* internal_default_instance() {
    return reinterpret_cast<const Expression_MultiOrList_Record*>(
               &_Expression_MultiOrList_Record_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  void Swap(Expression_MultiOrList_Record* other);
  friend void swap(Expression_MultiOrList_Record& a, Expression_MultiOrList_Record& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_MultiOrList_Record* New() const final {
    return CreateMaybeMessage<Expression_MultiOrList_Record>(NULL);
  }

  Expression_MultiOrList_Record* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_MultiOrList_Record>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_MultiOrList_Record& from);
  void MergeFrom(const Expression_MultiOrList_Record& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_MultiOrList_Record* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .substrait.Expression fields = 1;
  int fields_size() const;
  void clear_fields();
  static const int kFieldsFieldNumber = 1;
  ::substrait::Expression* mutable_fields(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression >*
      mutable_fields();
  const ::substrait::Expression& fields(int index) const;
  ::substrait::Expression* add_fields();
  const ::google::protobuf::RepeatedPtrField< ::substrait::Expression >&
      fields() const;

  // @@protoc_insertion_point(class_scope:substrait.Expression.MultiOrList.Record)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression > fields_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_MultiOrList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.MultiOrList) */ {
 public:
  Expression_MultiOrList();
  virtual ~Expression_MultiOrList();

  Expression_MultiOrList(const Expression_MultiOrList& from);

  inline Expression_MultiOrList& operator=(const Expression_MultiOrList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_MultiOrList(Expression_MultiOrList&& from) noexcept
    : Expression_MultiOrList() {
    *this = ::std::move(from);
  }

  inline Expression_MultiOrList& operator=(Expression_MultiOrList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_MultiOrList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_MultiOrList* internal_default_instance() {
    return reinterpret_cast<const Expression_MultiOrList*>(
               &_Expression_MultiOrList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  void Swap(Expression_MultiOrList* other);
  friend void swap(Expression_MultiOrList& a, Expression_MultiOrList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_MultiOrList* New() const final {
    return CreateMaybeMessage<Expression_MultiOrList>(NULL);
  }

  Expression_MultiOrList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_MultiOrList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_MultiOrList& from);
  void MergeFrom(const Expression_MultiOrList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_MultiOrList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_MultiOrList_Record Record;

  // accessors -------------------------------------------------------

  // repeated .substrait.Expression value = 1;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::substrait::Expression* mutable_value(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression >*
      mutable_value();
  const ::substrait::Expression& value(int index) const;
  ::substrait::Expression* add_value();
  const ::google::protobuf::RepeatedPtrField< ::substrait::Expression >&
      value() const;

  // repeated .substrait.Expression.MultiOrList.Record options = 2;
  int options_size() const;
  void clear_options();
  static const int kOptionsFieldNumber = 2;
  ::substrait::Expression_MultiOrList_Record* mutable_options(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression_MultiOrList_Record >*
      mutable_options();
  const ::substrait::Expression_MultiOrList_Record& options(int index) const;
  ::substrait::Expression_MultiOrList_Record* add_options();
  const ::google::protobuf::RepeatedPtrField< ::substrait::Expression_MultiOrList_Record >&
      options() const;

  // @@protoc_insertion_point(class_scope:substrait.Expression.MultiOrList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression > value_;
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression_MultiOrList_Record > options_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_EmbeddedFunction_PythonPickleFunction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.EmbeddedFunction.PythonPickleFunction) */ {
 public:
  Expression_EmbeddedFunction_PythonPickleFunction();
  virtual ~Expression_EmbeddedFunction_PythonPickleFunction();

  Expression_EmbeddedFunction_PythonPickleFunction(const Expression_EmbeddedFunction_PythonPickleFunction& from);

  inline Expression_EmbeddedFunction_PythonPickleFunction& operator=(const Expression_EmbeddedFunction_PythonPickleFunction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_EmbeddedFunction_PythonPickleFunction(Expression_EmbeddedFunction_PythonPickleFunction&& from) noexcept
    : Expression_EmbeddedFunction_PythonPickleFunction() {
    *this = ::std::move(from);
  }

  inline Expression_EmbeddedFunction_PythonPickleFunction& operator=(Expression_EmbeddedFunction_PythonPickleFunction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_EmbeddedFunction_PythonPickleFunction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_EmbeddedFunction_PythonPickleFunction* internal_default_instance() {
    return reinterpret_cast<const Expression_EmbeddedFunction_PythonPickleFunction*>(
               &_Expression_EmbeddedFunction_PythonPickleFunction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  void Swap(Expression_EmbeddedFunction_PythonPickleFunction* other);
  friend void swap(Expression_EmbeddedFunction_PythonPickleFunction& a, Expression_EmbeddedFunction_PythonPickleFunction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_EmbeddedFunction_PythonPickleFunction* New() const final {
    return CreateMaybeMessage<Expression_EmbeddedFunction_PythonPickleFunction>(NULL);
  }

  Expression_EmbeddedFunction_PythonPickleFunction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_EmbeddedFunction_PythonPickleFunction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_EmbeddedFunction_PythonPickleFunction& from);
  void MergeFrom(const Expression_EmbeddedFunction_PythonPickleFunction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_EmbeddedFunction_PythonPickleFunction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string prerequisite = 2;
  int prerequisite_size() const;
  void clear_prerequisite();
  static const int kPrerequisiteFieldNumber = 2;
  const ::std::string& prerequisite(int index) const;
  ::std::string* mutable_prerequisite(int index);
  void set_prerequisite(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_prerequisite(int index, ::std::string&& value);
  #endif
  void set_prerequisite(int index, const char* value);
  void set_prerequisite(int index, const char* value, size_t size);
  ::std::string* add_prerequisite();
  void add_prerequisite(const ::std::string& value);
  #if LANG_CXX11
  void add_prerequisite(::std::string&& value);
  #endif
  void add_prerequisite(const char* value);
  void add_prerequisite(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& prerequisite() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_prerequisite();

  // bytes function = 1;
  void clear_function();
  static const int kFunctionFieldNumber = 1;
  const ::std::string& function() const;
  void set_function(const ::std::string& value);
  #if LANG_CXX11
  void set_function(::std::string&& value);
  #endif
  void set_function(const char* value);
  void set_function(const void* value, size_t size);
  ::std::string* mutable_function();
  ::std::string* release_function();
  void set_allocated_function(::std::string* function);

  // @@protoc_insertion_point(class_scope:substrait.Expression.EmbeddedFunction.PythonPickleFunction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> prerequisite_;
  ::google::protobuf::internal::ArenaStringPtr function_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_EmbeddedFunction_WebAssemblyFunction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.EmbeddedFunction.WebAssemblyFunction) */ {
 public:
  Expression_EmbeddedFunction_WebAssemblyFunction();
  virtual ~Expression_EmbeddedFunction_WebAssemblyFunction();

  Expression_EmbeddedFunction_WebAssemblyFunction(const Expression_EmbeddedFunction_WebAssemblyFunction& from);

  inline Expression_EmbeddedFunction_WebAssemblyFunction& operator=(const Expression_EmbeddedFunction_WebAssemblyFunction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_EmbeddedFunction_WebAssemblyFunction(Expression_EmbeddedFunction_WebAssemblyFunction&& from) noexcept
    : Expression_EmbeddedFunction_WebAssemblyFunction() {
    *this = ::std::move(from);
  }

  inline Expression_EmbeddedFunction_WebAssemblyFunction& operator=(Expression_EmbeddedFunction_WebAssemblyFunction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_EmbeddedFunction_WebAssemblyFunction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_EmbeddedFunction_WebAssemblyFunction* internal_default_instance() {
    return reinterpret_cast<const Expression_EmbeddedFunction_WebAssemblyFunction*>(
               &_Expression_EmbeddedFunction_WebAssemblyFunction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  void Swap(Expression_EmbeddedFunction_WebAssemblyFunction* other);
  friend void swap(Expression_EmbeddedFunction_WebAssemblyFunction& a, Expression_EmbeddedFunction_WebAssemblyFunction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_EmbeddedFunction_WebAssemblyFunction* New() const final {
    return CreateMaybeMessage<Expression_EmbeddedFunction_WebAssemblyFunction>(NULL);
  }

  Expression_EmbeddedFunction_WebAssemblyFunction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_EmbeddedFunction_WebAssemblyFunction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_EmbeddedFunction_WebAssemblyFunction& from);
  void MergeFrom(const Expression_EmbeddedFunction_WebAssemblyFunction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_EmbeddedFunction_WebAssemblyFunction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string prerequisite = 2;
  int prerequisite_size() const;
  void clear_prerequisite();
  static const int kPrerequisiteFieldNumber = 2;
  const ::std::string& prerequisite(int index) const;
  ::std::string* mutable_prerequisite(int index);
  void set_prerequisite(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_prerequisite(int index, ::std::string&& value);
  #endif
  void set_prerequisite(int index, const char* value);
  void set_prerequisite(int index, const char* value, size_t size);
  ::std::string* add_prerequisite();
  void add_prerequisite(const ::std::string& value);
  #if LANG_CXX11
  void add_prerequisite(::std::string&& value);
  #endif
  void add_prerequisite(const char* value);
  void add_prerequisite(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& prerequisite() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_prerequisite();

  // bytes script = 1;
  void clear_script();
  static const int kScriptFieldNumber = 1;
  const ::std::string& script() const;
  void set_script(const ::std::string& value);
  #if LANG_CXX11
  void set_script(::std::string&& value);
  #endif
  void set_script(const char* value);
  void set_script(const void* value, size_t size);
  ::std::string* mutable_script();
  ::std::string* release_script();
  void set_allocated_script(::std::string* script);

  // @@protoc_insertion_point(class_scope:substrait.Expression.EmbeddedFunction.WebAssemblyFunction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> prerequisite_;
  ::google::protobuf::internal::ArenaStringPtr script_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_EmbeddedFunction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.EmbeddedFunction) */ {
 public:
  Expression_EmbeddedFunction();
  virtual ~Expression_EmbeddedFunction();

  Expression_EmbeddedFunction(const Expression_EmbeddedFunction& from);

  inline Expression_EmbeddedFunction& operator=(const Expression_EmbeddedFunction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_EmbeddedFunction(Expression_EmbeddedFunction&& from) noexcept
    : Expression_EmbeddedFunction() {
    *this = ::std::move(from);
  }

  inline Expression_EmbeddedFunction& operator=(Expression_EmbeddedFunction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_EmbeddedFunction& default_instance();

  enum KindCase {
    kPythonPickleFunction = 3,
    kWebAssemblyFunction = 4,
    KIND_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_EmbeddedFunction* internal_default_instance() {
    return reinterpret_cast<const Expression_EmbeddedFunction*>(
               &_Expression_EmbeddedFunction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  void Swap(Expression_EmbeddedFunction* other);
  friend void swap(Expression_EmbeddedFunction& a, Expression_EmbeddedFunction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_EmbeddedFunction* New() const final {
    return CreateMaybeMessage<Expression_EmbeddedFunction>(NULL);
  }

  Expression_EmbeddedFunction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_EmbeddedFunction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_EmbeddedFunction& from);
  void MergeFrom(const Expression_EmbeddedFunction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_EmbeddedFunction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_EmbeddedFunction_PythonPickleFunction PythonPickleFunction;
  typedef Expression_EmbeddedFunction_WebAssemblyFunction WebAssemblyFunction;

  // accessors -------------------------------------------------------

  // repeated .substrait.Expression arguments = 1;
  int arguments_size() const;
  void clear_arguments();
  static const int kArgumentsFieldNumber = 1;
  ::substrait::Expression* mutable_arguments(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression >*
      mutable_arguments();
  const ::substrait::Expression& arguments(int index) const;
  ::substrait::Expression* add_arguments();
  const ::google::protobuf::RepeatedPtrField< ::substrait::Expression >&
      arguments() const;

  // .substrait.Type output_type = 2;
  bool has_output_type() const;
  void clear_output_type();
  static const int kOutputTypeFieldNumber = 2;
  private:
  const ::substrait::Type& _internal_output_type() const;
  public:
  const ::substrait::Type& output_type() const;
  ::substrait::Type* release_output_type();
  ::substrait::Type* mutable_output_type();
  void set_allocated_output_type(::substrait::Type* output_type);

  // .substrait.Expression.EmbeddedFunction.PythonPickleFunction python_pickle_function = 3;
  bool has_python_pickle_function() const;
  void clear_python_pickle_function();
  static const int kPythonPickleFunctionFieldNumber = 3;
  private:
  const ::substrait::Expression_EmbeddedFunction_PythonPickleFunction& _internal_python_pickle_function() const;
  public:
  const ::substrait::Expression_EmbeddedFunction_PythonPickleFunction& python_pickle_function() const;
  ::substrait::Expression_EmbeddedFunction_PythonPickleFunction* release_python_pickle_function();
  ::substrait::Expression_EmbeddedFunction_PythonPickleFunction* mutable_python_pickle_function();
  void set_allocated_python_pickle_function(::substrait::Expression_EmbeddedFunction_PythonPickleFunction* python_pickle_function);

  // .substrait.Expression.EmbeddedFunction.WebAssemblyFunction web_assembly_function = 4;
  bool has_web_assembly_function() const;
  void clear_web_assembly_function();
  static const int kWebAssemblyFunctionFieldNumber = 4;
  private:
  const ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction& _internal_web_assembly_function() const;
  public:
  const ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction& web_assembly_function() const;
  ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* release_web_assembly_function();
  ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* mutable_web_assembly_function();
  void set_allocated_web_assembly_function(::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* web_assembly_function);

  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.EmbeddedFunction)
 private:
  void set_has_python_pickle_function();
  void set_has_web_assembly_function();

  inline bool has_kind() const;
  inline void clear_has_kind();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression > arguments_;
  ::substrait::Type* output_type_;
  union KindUnion {
    KindUnion() {}
    ::substrait::Expression_EmbeddedFunction_PythonPickleFunction* python_pickle_function_;
    ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* web_assembly_function_;
  } kind_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_ReferenceSegment_MapKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.ReferenceSegment.MapKey) */ {
 public:
  Expression_ReferenceSegment_MapKey();
  virtual ~Expression_ReferenceSegment_MapKey();

  Expression_ReferenceSegment_MapKey(const Expression_ReferenceSegment_MapKey& from);

  inline Expression_ReferenceSegment_MapKey& operator=(const Expression_ReferenceSegment_MapKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_ReferenceSegment_MapKey(Expression_ReferenceSegment_MapKey&& from) noexcept
    : Expression_ReferenceSegment_MapKey() {
    *this = ::std::move(from);
  }

  inline Expression_ReferenceSegment_MapKey& operator=(Expression_ReferenceSegment_MapKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_ReferenceSegment_MapKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_ReferenceSegment_MapKey* internal_default_instance() {
    return reinterpret_cast<const Expression_ReferenceSegment_MapKey*>(
               &_Expression_ReferenceSegment_MapKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  void Swap(Expression_ReferenceSegment_MapKey* other);
  friend void swap(Expression_ReferenceSegment_MapKey& a, Expression_ReferenceSegment_MapKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_ReferenceSegment_MapKey* New() const final {
    return CreateMaybeMessage<Expression_ReferenceSegment_MapKey>(NULL);
  }

  Expression_ReferenceSegment_MapKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_ReferenceSegment_MapKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_ReferenceSegment_MapKey& from);
  void MergeFrom(const Expression_ReferenceSegment_MapKey& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_ReferenceSegment_MapKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .substrait.Expression.Literal map_key = 1;
  bool has_map_key() const;
  void clear_map_key();
  static const int kMapKeyFieldNumber = 1;
  private:
  const ::substrait::Expression_Literal& _internal_map_key() const;
  public:
  const ::substrait::Expression_Literal& map_key() const;
  ::substrait::Expression_Literal* release_map_key();
  ::substrait::Expression_Literal* mutable_map_key();
  void set_allocated_map_key(::substrait::Expression_Literal* map_key);

  // .substrait.Expression.ReferenceSegment child = 2;
  bool has_child() const;
  void clear_child();
  static const int kChildFieldNumber = 2;
  private:
  const ::substrait::Expression_ReferenceSegment& _internal_child() const;
  public:
  const ::substrait::Expression_ReferenceSegment& child() const;
  ::substrait::Expression_ReferenceSegment* release_child();
  ::substrait::Expression_ReferenceSegment* mutable_child();
  void set_allocated_child(::substrait::Expression_ReferenceSegment* child);

  // @@protoc_insertion_point(class_scope:substrait.Expression.ReferenceSegment.MapKey)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::substrait::Expression_Literal* map_key_;
  ::substrait::Expression_ReferenceSegment* child_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_ReferenceSegment_StructField : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.ReferenceSegment.StructField) */ {
 public:
  Expression_ReferenceSegment_StructField();
  virtual ~Expression_ReferenceSegment_StructField();

  Expression_ReferenceSegment_StructField(const Expression_ReferenceSegment_StructField& from);

  inline Expression_ReferenceSegment_StructField& operator=(const Expression_ReferenceSegment_StructField& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_ReferenceSegment_StructField(Expression_ReferenceSegment_StructField&& from) noexcept
    : Expression_ReferenceSegment_StructField() {
    *this = ::std::move(from);
  }

  inline Expression_ReferenceSegment_StructField& operator=(Expression_ReferenceSegment_StructField&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_ReferenceSegment_StructField& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_ReferenceSegment_StructField* internal_default_instance() {
    return reinterpret_cast<const Expression_ReferenceSegment_StructField*>(
               &_Expression_ReferenceSegment_StructField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  void Swap(Expression_ReferenceSegment_StructField* other);
  friend void swap(Expression_ReferenceSegment_StructField& a, Expression_ReferenceSegment_StructField& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_ReferenceSegment_StructField* New() const final {
    return CreateMaybeMessage<Expression_ReferenceSegment_StructField>(NULL);
  }

  Expression_ReferenceSegment_StructField* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_ReferenceSegment_StructField>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_ReferenceSegment_StructField& from);
  void MergeFrom(const Expression_ReferenceSegment_StructField& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_ReferenceSegment_StructField* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .substrait.Expression.ReferenceSegment child = 2;
  bool has_child() const;
  void clear_child();
  static const int kChildFieldNumber = 2;
  private:
  const ::substrait::Expression_ReferenceSegment& _internal_child() const;
  public:
  const ::substrait::Expression_ReferenceSegment& child() const;
  ::substrait::Expression_ReferenceSegment* release_child();
  ::substrait::Expression_ReferenceSegment* mutable_child();
  void set_allocated_child(::substrait::Expression_ReferenceSegment* child);

  // int32 field = 1;
  void clear_field();
  static const int kFieldFieldNumber = 1;
  ::google::protobuf::int32 field() const;
  void set_field(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:substrait.Expression.ReferenceSegment.StructField)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::substrait::Expression_ReferenceSegment* child_;
  ::google::protobuf::int32 field_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_ReferenceSegment_ListElement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.ReferenceSegment.ListElement) */ {
 public:
  Expression_ReferenceSegment_ListElement();
  virtual ~Expression_ReferenceSegment_ListElement();

  Expression_ReferenceSegment_ListElement(const Expression_ReferenceSegment_ListElement& from);

  inline Expression_ReferenceSegment_ListElement& operator=(const Expression_ReferenceSegment_ListElement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_ReferenceSegment_ListElement(Expression_ReferenceSegment_ListElement&& from) noexcept
    : Expression_ReferenceSegment_ListElement() {
    *this = ::std::move(from);
  }

  inline Expression_ReferenceSegment_ListElement& operator=(Expression_ReferenceSegment_ListElement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_ReferenceSegment_ListElement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_ReferenceSegment_ListElement* internal_default_instance() {
    return reinterpret_cast<const Expression_ReferenceSegment_ListElement*>(
               &_Expression_ReferenceSegment_ListElement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  void Swap(Expression_ReferenceSegment_ListElement* other);
  friend void swap(Expression_ReferenceSegment_ListElement& a, Expression_ReferenceSegment_ListElement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_ReferenceSegment_ListElement* New() const final {
    return CreateMaybeMessage<Expression_ReferenceSegment_ListElement>(NULL);
  }

  Expression_ReferenceSegment_ListElement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_ReferenceSegment_ListElement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_ReferenceSegment_ListElement& from);
  void MergeFrom(const Expression_ReferenceSegment_ListElement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_ReferenceSegment_ListElement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .substrait.Expression.ReferenceSegment child = 2;
  bool has_child() const;
  void clear_child();
  static const int kChildFieldNumber = 2;
  private:
  const ::substrait::Expression_ReferenceSegment& _internal_child() const;
  public:
  const ::substrait::Expression_ReferenceSegment& child() const;
  ::substrait::Expression_ReferenceSegment* release_child();
  ::substrait::Expression_ReferenceSegment* mutable_child();
  void set_allocated_child(::substrait::Expression_ReferenceSegment* child);

  // int32 offset = 1;
  void clear_offset();
  static const int kOffsetFieldNumber = 1;
  ::google::protobuf::int32 offset() const;
  void set_offset(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:substrait.Expression.ReferenceSegment.ListElement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::substrait::Expression_ReferenceSegment* child_;
  ::google::protobuf::int32 offset_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_ReferenceSegment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.ReferenceSegment) */ {
 public:
  Expression_ReferenceSegment();
  virtual ~Expression_ReferenceSegment();

  Expression_ReferenceSegment(const Expression_ReferenceSegment& from);

  inline Expression_ReferenceSegment& operator=(const Expression_ReferenceSegment& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_ReferenceSegment(Expression_ReferenceSegment&& from) noexcept
    : Expression_ReferenceSegment() {
    *this = ::std::move(from);
  }

  inline Expression_ReferenceSegment& operator=(Expression_ReferenceSegment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_ReferenceSegment& default_instance();

  enum ReferenceTypeCase {
    kMapKey = 1,
    kStructField = 2,
    kListElement = 3,
    REFERENCE_TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_ReferenceSegment* internal_default_instance() {
    return reinterpret_cast<const Expression_ReferenceSegment*>(
               &_Expression_ReferenceSegment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  void Swap(Expression_ReferenceSegment* other);
  friend void swap(Expression_ReferenceSegment& a, Expression_ReferenceSegment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_ReferenceSegment* New() const final {
    return CreateMaybeMessage<Expression_ReferenceSegment>(NULL);
  }

  Expression_ReferenceSegment* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_ReferenceSegment>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_ReferenceSegment& from);
  void MergeFrom(const Expression_ReferenceSegment& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_ReferenceSegment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_ReferenceSegment_MapKey MapKey;
  typedef Expression_ReferenceSegment_StructField StructField;
  typedef Expression_ReferenceSegment_ListElement ListElement;

  // accessors -------------------------------------------------------

  // .substrait.Expression.ReferenceSegment.MapKey map_key = 1;
  bool has_map_key() const;
  void clear_map_key();
  static const int kMapKeyFieldNumber = 1;
  private:
  const ::substrait::Expression_ReferenceSegment_MapKey& _internal_map_key() const;
  public:
  const ::substrait::Expression_ReferenceSegment_MapKey& map_key() const;
  ::substrait::Expression_ReferenceSegment_MapKey* release_map_key();
  ::substrait::Expression_ReferenceSegment_MapKey* mutable_map_key();
  void set_allocated_map_key(::substrait::Expression_ReferenceSegment_MapKey* map_key);

  // .substrait.Expression.ReferenceSegment.StructField struct_field = 2;
  bool has_struct_field() const;
  void clear_struct_field();
  static const int kStructFieldFieldNumber = 2;
  private:
  const ::substrait::Expression_ReferenceSegment_StructField& _internal_struct_field() const;
  public:
  const ::substrait::Expression_ReferenceSegment_StructField& struct_field() const;
  ::substrait::Expression_ReferenceSegment_StructField* release_struct_field();
  ::substrait::Expression_ReferenceSegment_StructField* mutable_struct_field();
  void set_allocated_struct_field(::substrait::Expression_ReferenceSegment_StructField* struct_field);

  // .substrait.Expression.ReferenceSegment.ListElement list_element = 3;
  bool has_list_element() const;
  void clear_list_element();
  static const int kListElementFieldNumber = 3;
  private:
  const ::substrait::Expression_ReferenceSegment_ListElement& _internal_list_element() const;
  public:
  const ::substrait::Expression_ReferenceSegment_ListElement& list_element() const;
  ::substrait::Expression_ReferenceSegment_ListElement* release_list_element();
  ::substrait::Expression_ReferenceSegment_ListElement* mutable_list_element();
  void set_allocated_list_element(::substrait::Expression_ReferenceSegment_ListElement* list_element);

  void clear_reference_type();
  ReferenceTypeCase reference_type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.ReferenceSegment)
 private:
  void set_has_map_key();
  void set_has_struct_field();
  void set_has_list_element();

  inline bool has_reference_type() const;
  inline void clear_has_reference_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ReferenceTypeUnion {
    ReferenceTypeUnion() {}
    ::substrait::Expression_ReferenceSegment_MapKey* map_key_;
    ::substrait::Expression_ReferenceSegment_StructField* struct_field_;
    ::substrait::Expression_ReferenceSegment_ListElement* list_element_;
  } reference_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_MaskExpression_Select : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.MaskExpression.Select) */ {
 public:
  Expression_MaskExpression_Select();
  virtual ~Expression_MaskExpression_Select();

  Expression_MaskExpression_Select(const Expression_MaskExpression_Select& from);

  inline Expression_MaskExpression_Select& operator=(const Expression_MaskExpression_Select& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_MaskExpression_Select(Expression_MaskExpression_Select&& from) noexcept
    : Expression_MaskExpression_Select() {
    *this = ::std::move(from);
  }

  inline Expression_MaskExpression_Select& operator=(Expression_MaskExpression_Select&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_MaskExpression_Select& default_instance();

  enum TypeCase {
    kStruct = 1,
    kList = 2,
    kMap = 3,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_MaskExpression_Select* internal_default_instance() {
    return reinterpret_cast<const Expression_MaskExpression_Select*>(
               &_Expression_MaskExpression_Select_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  void Swap(Expression_MaskExpression_Select* other);
  friend void swap(Expression_MaskExpression_Select& a, Expression_MaskExpression_Select& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_MaskExpression_Select* New() const final {
    return CreateMaybeMessage<Expression_MaskExpression_Select>(NULL);
  }

  Expression_MaskExpression_Select* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_MaskExpression_Select>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_MaskExpression_Select& from);
  void MergeFrom(const Expression_MaskExpression_Select& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_MaskExpression_Select* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .substrait.Expression.MaskExpression.StructSelect struct = 1;
  bool has_struct_() const;
  void clear_struct_();
  static const int kStructFieldNumber = 1;
  private:
  const ::substrait::Expression_MaskExpression_StructSelect& _internal_struct_() const;
  public:
  const ::substrait::Expression_MaskExpression_StructSelect& struct_() const;
  ::substrait::Expression_MaskExpression_StructSelect* release_struct_();
  ::substrait::Expression_MaskExpression_StructSelect* mutable_struct_();
  void set_allocated_struct_(::substrait::Expression_MaskExpression_StructSelect* struct_);

  // .substrait.Expression.MaskExpression.ListSelect list = 2;
  bool has_list() const;
  void clear_list();
  static const int kListFieldNumber = 2;
  private:
  const ::substrait::Expression_MaskExpression_ListSelect& _internal_list() const;
  public:
  const ::substrait::Expression_MaskExpression_ListSelect& list() const;
  ::substrait::Expression_MaskExpression_ListSelect* release_list();
  ::substrait::Expression_MaskExpression_ListSelect* mutable_list();
  void set_allocated_list(::substrait::Expression_MaskExpression_ListSelect* list);

  // .substrait.Expression.MaskExpression.MapSelect map = 3;
  bool has_map() const;
  void clear_map();
  static const int kMapFieldNumber = 3;
  private:
  const ::substrait::Expression_MaskExpression_MapSelect& _internal_map() const;
  public:
  const ::substrait::Expression_MaskExpression_MapSelect& map() const;
  ::substrait::Expression_MaskExpression_MapSelect* release_map();
  ::substrait::Expression_MaskExpression_MapSelect* mutable_map();
  void set_allocated_map(::substrait::Expression_MaskExpression_MapSelect* map);

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.MaskExpression.Select)
 private:
  void set_has_struct_();
  void set_has_list();
  void set_has_map();

  inline bool has_type() const;
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union TypeUnion {
    TypeUnion() {}
    ::substrait::Expression_MaskExpression_StructSelect* struct__;
    ::substrait::Expression_MaskExpression_ListSelect* list_;
    ::substrait::Expression_MaskExpression_MapSelect* map_;
  } type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_MaskExpression_StructSelect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.MaskExpression.StructSelect) */ {
 public:
  Expression_MaskExpression_StructSelect();
  virtual ~Expression_MaskExpression_StructSelect();

  Expression_MaskExpression_StructSelect(const Expression_MaskExpression_StructSelect& from);

  inline Expression_MaskExpression_StructSelect& operator=(const Expression_MaskExpression_StructSelect& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_MaskExpression_StructSelect(Expression_MaskExpression_StructSelect&& from) noexcept
    : Expression_MaskExpression_StructSelect() {
    *this = ::std::move(from);
  }

  inline Expression_MaskExpression_StructSelect& operator=(Expression_MaskExpression_StructSelect&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_MaskExpression_StructSelect& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_MaskExpression_StructSelect* internal_default_instance() {
    return reinterpret_cast<const Expression_MaskExpression_StructSelect*>(
               &_Expression_MaskExpression_StructSelect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  void Swap(Expression_MaskExpression_StructSelect* other);
  friend void swap(Expression_MaskExpression_StructSelect& a, Expression_MaskExpression_StructSelect& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_MaskExpression_StructSelect* New() const final {
    return CreateMaybeMessage<Expression_MaskExpression_StructSelect>(NULL);
  }

  Expression_MaskExpression_StructSelect* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_MaskExpression_StructSelect>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_MaskExpression_StructSelect& from);
  void MergeFrom(const Expression_MaskExpression_StructSelect& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_MaskExpression_StructSelect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .substrait.Expression.MaskExpression.StructItem struct_items = 1;
  int struct_items_size() const;
  void clear_struct_items();
  static const int kStructItemsFieldNumber = 1;
  ::substrait::Expression_MaskExpression_StructItem* mutable_struct_items(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression_MaskExpression_StructItem >*
      mutable_struct_items();
  const ::substrait::Expression_MaskExpression_StructItem& struct_items(int index) const;
  ::substrait::Expression_MaskExpression_StructItem* add_struct_items();
  const ::google::protobuf::RepeatedPtrField< ::substrait::Expression_MaskExpression_StructItem >&
      struct_items() const;

  // @@protoc_insertion_point(class_scope:substrait.Expression.MaskExpression.StructSelect)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression_MaskExpression_StructItem > struct_items_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_MaskExpression_StructItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.MaskExpression.StructItem) */ {
 public:
  Expression_MaskExpression_StructItem();
  virtual ~Expression_MaskExpression_StructItem();

  Expression_MaskExpression_StructItem(const Expression_MaskExpression_StructItem& from);

  inline Expression_MaskExpression_StructItem& operator=(const Expression_MaskExpression_StructItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_MaskExpression_StructItem(Expression_MaskExpression_StructItem&& from) noexcept
    : Expression_MaskExpression_StructItem() {
    *this = ::std::move(from);
  }

  inline Expression_MaskExpression_StructItem& operator=(Expression_MaskExpression_StructItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_MaskExpression_StructItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_MaskExpression_StructItem* internal_default_instance() {
    return reinterpret_cast<const Expression_MaskExpression_StructItem*>(
               &_Expression_MaskExpression_StructItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  void Swap(Expression_MaskExpression_StructItem* other);
  friend void swap(Expression_MaskExpression_StructItem& a, Expression_MaskExpression_StructItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_MaskExpression_StructItem* New() const final {
    return CreateMaybeMessage<Expression_MaskExpression_StructItem>(NULL);
  }

  Expression_MaskExpression_StructItem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_MaskExpression_StructItem>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_MaskExpression_StructItem& from);
  void MergeFrom(const Expression_MaskExpression_StructItem& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_MaskExpression_StructItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .substrait.Expression.MaskExpression.Select child = 2;
  bool has_child() const;
  void clear_child();
  static const int kChildFieldNumber = 2;
  private:
  const ::substrait::Expression_MaskExpression_Select& _internal_child() const;
  public:
  const ::substrait::Expression_MaskExpression_Select& child() const;
  ::substrait::Expression_MaskExpression_Select* release_child();
  ::substrait::Expression_MaskExpression_Select* mutable_child();
  void set_allocated_child(::substrait::Expression_MaskExpression_Select* child);

  // int32 field = 1;
  void clear_field();
  static const int kFieldFieldNumber = 1;
  ::google::protobuf::int32 field() const;
  void set_field(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:substrait.Expression.MaskExpression.StructItem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::substrait::Expression_MaskExpression_Select* child_;
  ::google::protobuf::int32 field_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_MaskExpression_ListSelect_ListSelectItem_ListElement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement) */ {
 public:
  Expression_MaskExpression_ListSelect_ListSelectItem_ListElement();
  virtual ~Expression_MaskExpression_ListSelect_ListSelectItem_ListElement();

  Expression_MaskExpression_ListSelect_ListSelectItem_ListElement(const Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& from);

  inline Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& operator=(const Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_MaskExpression_ListSelect_ListSelectItem_ListElement(Expression_MaskExpression_ListSelect_ListSelectItem_ListElement&& from) noexcept
    : Expression_MaskExpression_ListSelect_ListSelectItem_ListElement() {
    *this = ::std::move(from);
  }

  inline Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& operator=(Expression_MaskExpression_ListSelect_ListSelectItem_ListElement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* internal_default_instance() {
    return reinterpret_cast<const Expression_MaskExpression_ListSelect_ListSelectItem_ListElement*>(
               &_Expression_MaskExpression_ListSelect_ListSelectItem_ListElement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  void Swap(Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* other);
  friend void swap(Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& a, Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* New() const final {
    return CreateMaybeMessage<Expression_MaskExpression_ListSelect_ListSelectItem_ListElement>(NULL);
  }

  Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_MaskExpression_ListSelect_ListSelectItem_ListElement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& from);
  void MergeFrom(const Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 field = 1;
  void clear_field();
  static const int kFieldFieldNumber = 1;
  ::google::protobuf::int32 field() const;
  void set_field(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 field_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice) */ {
 public:
  Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice();
  virtual ~Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice();

  Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice(const Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& from);

  inline Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& operator=(const Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice(Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice&& from) noexcept
    : Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice() {
    *this = ::std::move(from);
  }

  inline Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& operator=(Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* internal_default_instance() {
    return reinterpret_cast<const Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice*>(
               &_Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  void Swap(Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* other);
  friend void swap(Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& a, Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* New() const final {
    return CreateMaybeMessage<Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice>(NULL);
  }

  Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& from);
  void MergeFrom(const Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 start = 1;
  void clear_start();
  static const int kStartFieldNumber = 1;
  ::google::protobuf::int32 start() const;
  void set_start(::google::protobuf::int32 value);

  // int32 end = 2;
  void clear_end();
  static const int kEndFieldNumber = 2;
  ::google::protobuf::int32 end() const;
  void set_end(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 start_;
  ::google::protobuf::int32 end_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_MaskExpression_ListSelect_ListSelectItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.MaskExpression.ListSelect.ListSelectItem) */ {
 public:
  Expression_MaskExpression_ListSelect_ListSelectItem();
  virtual ~Expression_MaskExpression_ListSelect_ListSelectItem();

  Expression_MaskExpression_ListSelect_ListSelectItem(const Expression_MaskExpression_ListSelect_ListSelectItem& from);

  inline Expression_MaskExpression_ListSelect_ListSelectItem& operator=(const Expression_MaskExpression_ListSelect_ListSelectItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_MaskExpression_ListSelect_ListSelectItem(Expression_MaskExpression_ListSelect_ListSelectItem&& from) noexcept
    : Expression_MaskExpression_ListSelect_ListSelectItem() {
    *this = ::std::move(from);
  }

  inline Expression_MaskExpression_ListSelect_ListSelectItem& operator=(Expression_MaskExpression_ListSelect_ListSelectItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_MaskExpression_ListSelect_ListSelectItem& default_instance();

  enum TypeCase {
    kItem = 1,
    kSlice = 2,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_MaskExpression_ListSelect_ListSelectItem* internal_default_instance() {
    return reinterpret_cast<const Expression_MaskExpression_ListSelect_ListSelectItem*>(
               &_Expression_MaskExpression_ListSelect_ListSelectItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  void Swap(Expression_MaskExpression_ListSelect_ListSelectItem* other);
  friend void swap(Expression_MaskExpression_ListSelect_ListSelectItem& a, Expression_MaskExpression_ListSelect_ListSelectItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_MaskExpression_ListSelect_ListSelectItem* New() const final {
    return CreateMaybeMessage<Expression_MaskExpression_ListSelect_ListSelectItem>(NULL);
  }

  Expression_MaskExpression_ListSelect_ListSelectItem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_MaskExpression_ListSelect_ListSelectItem>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_MaskExpression_ListSelect_ListSelectItem& from);
  void MergeFrom(const Expression_MaskExpression_ListSelect_ListSelectItem& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_MaskExpression_ListSelect_ListSelectItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_MaskExpression_ListSelect_ListSelectItem_ListElement ListElement;
  typedef Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice ListSlice;

  // accessors -------------------------------------------------------

  // .substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement item = 1;
  bool has_item() const;
  void clear_item();
  static const int kItemFieldNumber = 1;
  private:
  const ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& _internal_item() const;
  public:
  const ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& item() const;
  ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* release_item();
  ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* mutable_item();
  void set_allocated_item(::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* item);

  // .substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice slice = 2;
  bool has_slice() const;
  void clear_slice();
  static const int kSliceFieldNumber = 2;
  private:
  const ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& _internal_slice() const;
  public:
  const ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& slice() const;
  ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* release_slice();
  ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* mutable_slice();
  void set_allocated_slice(::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* slice);

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.MaskExpression.ListSelect.ListSelectItem)
 private:
  void set_has_item();
  void set_has_slice();

  inline bool has_type() const;
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union TypeUnion {
    TypeUnion() {}
    ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* item_;
    ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* slice_;
  } type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_MaskExpression_ListSelect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.MaskExpression.ListSelect) */ {
 public:
  Expression_MaskExpression_ListSelect();
  virtual ~Expression_MaskExpression_ListSelect();

  Expression_MaskExpression_ListSelect(const Expression_MaskExpression_ListSelect& from);

  inline Expression_MaskExpression_ListSelect& operator=(const Expression_MaskExpression_ListSelect& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_MaskExpression_ListSelect(Expression_MaskExpression_ListSelect&& from) noexcept
    : Expression_MaskExpression_ListSelect() {
    *this = ::std::move(from);
  }

  inline Expression_MaskExpression_ListSelect& operator=(Expression_MaskExpression_ListSelect&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_MaskExpression_ListSelect& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_MaskExpression_ListSelect* internal_default_instance() {
    return reinterpret_cast<const Expression_MaskExpression_ListSelect*>(
               &_Expression_MaskExpression_ListSelect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    91;

  void Swap(Expression_MaskExpression_ListSelect* other);
  friend void swap(Expression_MaskExpression_ListSelect& a, Expression_MaskExpression_ListSelect& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_MaskExpression_ListSelect* New() const final {
    return CreateMaybeMessage<Expression_MaskExpression_ListSelect>(NULL);
  }

  Expression_MaskExpression_ListSelect* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_MaskExpression_ListSelect>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_MaskExpression_ListSelect& from);
  void MergeFrom(const Expression_MaskExpression_ListSelect& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_MaskExpression_ListSelect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_MaskExpression_ListSelect_ListSelectItem ListSelectItem;

  // accessors -------------------------------------------------------

  // repeated .substrait.Expression.MaskExpression.ListSelect.ListSelectItem selection = 1;
  int selection_size() const;
  void clear_selection();
  static const int kSelectionFieldNumber = 1;
  ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem* mutable_selection(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem >*
      mutable_selection();
  const ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem& selection(int index) const;
  ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem* add_selection();
  const ::google::protobuf::RepeatedPtrField< ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem >&
      selection() const;

  // .substrait.Expression.MaskExpression.Select child = 2;
  bool has_child() const;
  void clear_child();
  static const int kChildFieldNumber = 2;
  private:
  const ::substrait::Expression_MaskExpression_Select& _internal_child() const;
  public:
  const ::substrait::Expression_MaskExpression_Select& child() const;
  ::substrait::Expression_MaskExpression_Select* release_child();
  ::substrait::Expression_MaskExpression_Select* mutable_child();
  void set_allocated_child(::substrait::Expression_MaskExpression_Select* child);

  // @@protoc_insertion_point(class_scope:substrait.Expression.MaskExpression.ListSelect)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem > selection_;
  ::substrait::Expression_MaskExpression_Select* child_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_MaskExpression_MapSelect_MapKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.MaskExpression.MapSelect.MapKey) */ {
 public:
  Expression_MaskExpression_MapSelect_MapKey();
  virtual ~Expression_MaskExpression_MapSelect_MapKey();

  Expression_MaskExpression_MapSelect_MapKey(const Expression_MaskExpression_MapSelect_MapKey& from);

  inline Expression_MaskExpression_MapSelect_MapKey& operator=(const Expression_MaskExpression_MapSelect_MapKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_MaskExpression_MapSelect_MapKey(Expression_MaskExpression_MapSelect_MapKey&& from) noexcept
    : Expression_MaskExpression_MapSelect_MapKey() {
    *this = ::std::move(from);
  }

  inline Expression_MaskExpression_MapSelect_MapKey& operator=(Expression_MaskExpression_MapSelect_MapKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_MaskExpression_MapSelect_MapKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_MaskExpression_MapSelect_MapKey* internal_default_instance() {
    return reinterpret_cast<const Expression_MaskExpression_MapSelect_MapKey*>(
               &_Expression_MaskExpression_MapSelect_MapKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    92;

  void Swap(Expression_MaskExpression_MapSelect_MapKey* other);
  friend void swap(Expression_MaskExpression_MapSelect_MapKey& a, Expression_MaskExpression_MapSelect_MapKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_MaskExpression_MapSelect_MapKey* New() const final {
    return CreateMaybeMessage<Expression_MaskExpression_MapSelect_MapKey>(NULL);
  }

  Expression_MaskExpression_MapSelect_MapKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_MaskExpression_MapSelect_MapKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_MaskExpression_MapSelect_MapKey& from);
  void MergeFrom(const Expression_MaskExpression_MapSelect_MapKey& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_MaskExpression_MapSelect_MapKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string map_key = 1;
  void clear_map_key();
  static const int kMapKeyFieldNumber = 1;
  const ::std::string& map_key() const;
  void set_map_key(const ::std::string& value);
  #if LANG_CXX11
  void set_map_key(::std::string&& value);
  #endif
  void set_map_key(const char* value);
  void set_map_key(const char* value, size_t size);
  ::std::string* mutable_map_key();
  ::std::string* release_map_key();
  void set_allocated_map_key(::std::string* map_key);

  // @@protoc_insertion_point(class_scope:substrait.Expression.MaskExpression.MapSelect.MapKey)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr map_key_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_MaskExpression_MapSelect_MapKeyExpression : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.MaskExpression.MapSelect.MapKeyExpression) */ {
 public:
  Expression_MaskExpression_MapSelect_MapKeyExpression();
  virtual ~Expression_MaskExpression_MapSelect_MapKeyExpression();

  Expression_MaskExpression_MapSelect_MapKeyExpression(const Expression_MaskExpression_MapSelect_MapKeyExpression& from);

  inline Expression_MaskExpression_MapSelect_MapKeyExpression& operator=(const Expression_MaskExpression_MapSelect_MapKeyExpression& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_MaskExpression_MapSelect_MapKeyExpression(Expression_MaskExpression_MapSelect_MapKeyExpression&& from) noexcept
    : Expression_MaskExpression_MapSelect_MapKeyExpression() {
    *this = ::std::move(from);
  }

  inline Expression_MaskExpression_MapSelect_MapKeyExpression& operator=(Expression_MaskExpression_MapSelect_MapKeyExpression&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_MaskExpression_MapSelect_MapKeyExpression& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_MaskExpression_MapSelect_MapKeyExpression* internal_default_instance() {
    return reinterpret_cast<const Expression_MaskExpression_MapSelect_MapKeyExpression*>(
               &_Expression_MaskExpression_MapSelect_MapKeyExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    93;

  void Swap(Expression_MaskExpression_MapSelect_MapKeyExpression* other);
  friend void swap(Expression_MaskExpression_MapSelect_MapKeyExpression& a, Expression_MaskExpression_MapSelect_MapKeyExpression& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_MaskExpression_MapSelect_MapKeyExpression* New() const final {
    return CreateMaybeMessage<Expression_MaskExpression_MapSelect_MapKeyExpression>(NULL);
  }

  Expression_MaskExpression_MapSelect_MapKeyExpression* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_MaskExpression_MapSelect_MapKeyExpression>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_MaskExpression_MapSelect_MapKeyExpression& from);
  void MergeFrom(const Expression_MaskExpression_MapSelect_MapKeyExpression& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_MaskExpression_MapSelect_MapKeyExpression* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string map_key_expression = 1;
  void clear_map_key_expression();
  static const int kMapKeyExpressionFieldNumber = 1;
  const ::std::string& map_key_expression() const;
  void set_map_key_expression(const ::std::string& value);
  #if LANG_CXX11
  void set_map_key_expression(::std::string&& value);
  #endif
  void set_map_key_expression(const char* value);
  void set_map_key_expression(const char* value, size_t size);
  ::std::string* mutable_map_key_expression();
  ::std::string* release_map_key_expression();
  void set_allocated_map_key_expression(::std::string* map_key_expression);

  // @@protoc_insertion_point(class_scope:substrait.Expression.MaskExpression.MapSelect.MapKeyExpression)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr map_key_expression_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_MaskExpression_MapSelect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.MaskExpression.MapSelect) */ {
 public:
  Expression_MaskExpression_MapSelect();
  virtual ~Expression_MaskExpression_MapSelect();

  Expression_MaskExpression_MapSelect(const Expression_MaskExpression_MapSelect& from);

  inline Expression_MaskExpression_MapSelect& operator=(const Expression_MaskExpression_MapSelect& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_MaskExpression_MapSelect(Expression_MaskExpression_MapSelect&& from) noexcept
    : Expression_MaskExpression_MapSelect() {
    *this = ::std::move(from);
  }

  inline Expression_MaskExpression_MapSelect& operator=(Expression_MaskExpression_MapSelect&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_MaskExpression_MapSelect& default_instance();

  enum SelectCase {
    kKey = 1,
    kExpression = 2,
    SELECT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_MaskExpression_MapSelect* internal_default_instance() {
    return reinterpret_cast<const Expression_MaskExpression_MapSelect*>(
               &_Expression_MaskExpression_MapSelect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    94;

  void Swap(Expression_MaskExpression_MapSelect* other);
  friend void swap(Expression_MaskExpression_MapSelect& a, Expression_MaskExpression_MapSelect& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_MaskExpression_MapSelect* New() const final {
    return CreateMaybeMessage<Expression_MaskExpression_MapSelect>(NULL);
  }

  Expression_MaskExpression_MapSelect* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_MaskExpression_MapSelect>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_MaskExpression_MapSelect& from);
  void MergeFrom(const Expression_MaskExpression_MapSelect& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_MaskExpression_MapSelect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_MaskExpression_MapSelect_MapKey MapKey;
  typedef Expression_MaskExpression_MapSelect_MapKeyExpression MapKeyExpression;

  // accessors -------------------------------------------------------

  // .substrait.Expression.MaskExpression.Select child = 3;
  bool has_child() const;
  void clear_child();
  static const int kChildFieldNumber = 3;
  private:
  const ::substrait::Expression_MaskExpression_Select& _internal_child() const;
  public:
  const ::substrait::Expression_MaskExpression_Select& child() const;
  ::substrait::Expression_MaskExpression_Select* release_child();
  ::substrait::Expression_MaskExpression_Select* mutable_child();
  void set_allocated_child(::substrait::Expression_MaskExpression_Select* child);

  // .substrait.Expression.MaskExpression.MapSelect.MapKey key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  private:
  const ::substrait::Expression_MaskExpression_MapSelect_MapKey& _internal_key() const;
  public:
  const ::substrait::Expression_MaskExpression_MapSelect_MapKey& key() const;
  ::substrait::Expression_MaskExpression_MapSelect_MapKey* release_key();
  ::substrait::Expression_MaskExpression_MapSelect_MapKey* mutable_key();
  void set_allocated_key(::substrait::Expression_MaskExpression_MapSelect_MapKey* key);

  // .substrait.Expression.MaskExpression.MapSelect.MapKeyExpression expression = 2;
  bool has_expression() const;
  void clear_expression();
  static const int kExpressionFieldNumber = 2;
  private:
  const ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression& _internal_expression() const;
  public:
  const ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression& expression() const;
  ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* release_expression();
  ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* mutable_expression();
  void set_allocated_expression(::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* expression);

  void clear_select();
  SelectCase select_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.MaskExpression.MapSelect)
 private:
  void set_has_key();
  void set_has_expression();

  inline bool has_select() const;
  inline void clear_has_select();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::substrait::Expression_MaskExpression_Select* child_;
  union SelectUnion {
    SelectUnion() {}
    ::substrait::Expression_MaskExpression_MapSelect_MapKey* key_;
    ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* expression_;
  } select_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_MaskExpression : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.MaskExpression) */ {
 public:
  Expression_MaskExpression();
  virtual ~Expression_MaskExpression();

  Expression_MaskExpression(const Expression_MaskExpression& from);

  inline Expression_MaskExpression& operator=(const Expression_MaskExpression& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_MaskExpression(Expression_MaskExpression&& from) noexcept
    : Expression_MaskExpression() {
    *this = ::std::move(from);
  }

  inline Expression_MaskExpression& operator=(Expression_MaskExpression&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_MaskExpression& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_MaskExpression* internal_default_instance() {
    return reinterpret_cast<const Expression_MaskExpression*>(
               &_Expression_MaskExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    95;

  void Swap(Expression_MaskExpression* other);
  friend void swap(Expression_MaskExpression& a, Expression_MaskExpression& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_MaskExpression* New() const final {
    return CreateMaybeMessage<Expression_MaskExpression>(NULL);
  }

  Expression_MaskExpression* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_MaskExpression>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_MaskExpression& from);
  void MergeFrom(const Expression_MaskExpression& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_MaskExpression* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_MaskExpression_Select Select;
  typedef Expression_MaskExpression_StructSelect StructSelect;
  typedef Expression_MaskExpression_StructItem StructItem;
  typedef Expression_MaskExpression_ListSelect ListSelect;
  typedef Expression_MaskExpression_MapSelect MapSelect;

  // accessors -------------------------------------------------------

  // .substrait.Expression.MaskExpression.StructSelect select = 1;
  bool has_select() const;
  void clear_select();
  static const int kSelectFieldNumber = 1;
  private:
  const ::substrait::Expression_MaskExpression_StructSelect& _internal_select() const;
  public:
  const ::substrait::Expression_MaskExpression_StructSelect& select() const;
  ::substrait::Expression_MaskExpression_StructSelect* release_select();
  ::substrait::Expression_MaskExpression_StructSelect* mutable_select();
  void set_allocated_select(::substrait::Expression_MaskExpression_StructSelect* select);

  // bool maintain_singular_struct = 2;
  void clear_maintain_singular_struct();
  static const int kMaintainSingularStructFieldNumber = 2;
  bool maintain_singular_struct() const;
  void set_maintain_singular_struct(bool value);

  // @@protoc_insertion_point(class_scope:substrait.Expression.MaskExpression)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::substrait::Expression_MaskExpression_StructSelect* select_;
  bool maintain_singular_struct_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_FieldReference_RootReference : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.FieldReference.RootReference) */ {
 public:
  Expression_FieldReference_RootReference();
  virtual ~Expression_FieldReference_RootReference();

  Expression_FieldReference_RootReference(const Expression_FieldReference_RootReference& from);

  inline Expression_FieldReference_RootReference& operator=(const Expression_FieldReference_RootReference& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_FieldReference_RootReference(Expression_FieldReference_RootReference&& from) noexcept
    : Expression_FieldReference_RootReference() {
    *this = ::std::move(from);
  }

  inline Expression_FieldReference_RootReference& operator=(Expression_FieldReference_RootReference&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_FieldReference_RootReference& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_FieldReference_RootReference* internal_default_instance() {
    return reinterpret_cast<const Expression_FieldReference_RootReference*>(
               &_Expression_FieldReference_RootReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    96;

  void Swap(Expression_FieldReference_RootReference* other);
  friend void swap(Expression_FieldReference_RootReference& a, Expression_FieldReference_RootReference& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_FieldReference_RootReference* New() const final {
    return CreateMaybeMessage<Expression_FieldReference_RootReference>(NULL);
  }

  Expression_FieldReference_RootReference* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_FieldReference_RootReference>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_FieldReference_RootReference& from);
  void MergeFrom(const Expression_FieldReference_RootReference& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_FieldReference_RootReference* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:substrait.Expression.FieldReference.RootReference)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_FieldReference_OuterReference : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.FieldReference.OuterReference) */ {
 public:
  Expression_FieldReference_OuterReference();
  virtual ~Expression_FieldReference_OuterReference();

  Expression_FieldReference_OuterReference(const Expression_FieldReference_OuterReference& from);

  inline Expression_FieldReference_OuterReference& operator=(const Expression_FieldReference_OuterReference& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_FieldReference_OuterReference(Expression_FieldReference_OuterReference&& from) noexcept
    : Expression_FieldReference_OuterReference() {
    *this = ::std::move(from);
  }

  inline Expression_FieldReference_OuterReference& operator=(Expression_FieldReference_OuterReference&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_FieldReference_OuterReference& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_FieldReference_OuterReference* internal_default_instance() {
    return reinterpret_cast<const Expression_FieldReference_OuterReference*>(
               &_Expression_FieldReference_OuterReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    97;

  void Swap(Expression_FieldReference_OuterReference* other);
  friend void swap(Expression_FieldReference_OuterReference& a, Expression_FieldReference_OuterReference& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_FieldReference_OuterReference* New() const final {
    return CreateMaybeMessage<Expression_FieldReference_OuterReference>(NULL);
  }

  Expression_FieldReference_OuterReference* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_FieldReference_OuterReference>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_FieldReference_OuterReference& from);
  void MergeFrom(const Expression_FieldReference_OuterReference& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_FieldReference_OuterReference* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 steps_out = 1;
  void clear_steps_out();
  static const int kStepsOutFieldNumber = 1;
  ::google::protobuf::uint32 steps_out() const;
  void set_steps_out(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:substrait.Expression.FieldReference.OuterReference)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 steps_out_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_FieldReference : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.FieldReference) */ {
 public:
  Expression_FieldReference();
  virtual ~Expression_FieldReference();

  Expression_FieldReference(const Expression_FieldReference& from);

  inline Expression_FieldReference& operator=(const Expression_FieldReference& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_FieldReference(Expression_FieldReference&& from) noexcept
    : Expression_FieldReference() {
    *this = ::std::move(from);
  }

  inline Expression_FieldReference& operator=(Expression_FieldReference&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_FieldReference& default_instance();

  enum ReferenceTypeCase {
    kDirectReference = 1,
    kMaskedReference = 2,
    REFERENCE_TYPE_NOT_SET = 0,
  };

  enum RootTypeCase {
    kExpression = 3,
    kRootReference = 4,
    kOuterReference = 5,
    ROOT_TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_FieldReference* internal_default_instance() {
    return reinterpret_cast<const Expression_FieldReference*>(
               &_Expression_FieldReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    98;

  void Swap(Expression_FieldReference* other);
  friend void swap(Expression_FieldReference& a, Expression_FieldReference& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_FieldReference* New() const final {
    return CreateMaybeMessage<Expression_FieldReference>(NULL);
  }

  Expression_FieldReference* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_FieldReference>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_FieldReference& from);
  void MergeFrom(const Expression_FieldReference& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_FieldReference* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_FieldReference_RootReference RootReference;
  typedef Expression_FieldReference_OuterReference OuterReference;

  // accessors -------------------------------------------------------

  // .substrait.Expression.ReferenceSegment direct_reference = 1;
  bool has_direct_reference() const;
  void clear_direct_reference();
  static const int kDirectReferenceFieldNumber = 1;
  private:
  const ::substrait::Expression_ReferenceSegment& _internal_direct_reference() const;
  public:
  const ::substrait::Expression_ReferenceSegment& direct_reference() const;
  ::substrait::Expression_ReferenceSegment* release_direct_reference();
  ::substrait::Expression_ReferenceSegment* mutable_direct_reference();
  void set_allocated_direct_reference(::substrait::Expression_ReferenceSegment* direct_reference);

  // .substrait.Expression.MaskExpression masked_reference = 2;
  bool has_masked_reference() const;
  void clear_masked_reference();
  static const int kMaskedReferenceFieldNumber = 2;
  private:
  const ::substrait::Expression_MaskExpression& _internal_masked_reference() const;
  public:
  const ::substrait::Expression_MaskExpression& masked_reference() const;
  ::substrait::Expression_MaskExpression* release_masked_reference();
  ::substrait::Expression_MaskExpression* mutable_masked_reference();
  void set_allocated_masked_reference(::substrait::Expression_MaskExpression* masked_reference);

  // .substrait.Expression expression = 3;
  bool has_expression() const;
  void clear_expression();
  static const int kExpressionFieldNumber = 3;
  private:
  const ::substrait::Expression& _internal_expression() const;
  public:
  const ::substrait::Expression& expression() const;
  ::substrait::Expression* release_expression();
  ::substrait::Expression* mutable_expression();
  void set_allocated_expression(::substrait::Expression* expression);

  // .substrait.Expression.FieldReference.RootReference root_reference = 4;
  bool has_root_reference() const;
  void clear_root_reference();
  static const int kRootReferenceFieldNumber = 4;
  private:
  const ::substrait::Expression_FieldReference_RootReference& _internal_root_reference() const;
  public:
  const ::substrait::Expression_FieldReference_RootReference& root_reference() const;
  ::substrait::Expression_FieldReference_RootReference* release_root_reference();
  ::substrait::Expression_FieldReference_RootReference* mutable_root_reference();
  void set_allocated_root_reference(::substrait::Expression_FieldReference_RootReference* root_reference);

  // .substrait.Expression.FieldReference.OuterReference outer_reference = 5;
  bool has_outer_reference() const;
  void clear_outer_reference();
  static const int kOuterReferenceFieldNumber = 5;
  private:
  const ::substrait::Expression_FieldReference_OuterReference& _internal_outer_reference() const;
  public:
  const ::substrait::Expression_FieldReference_OuterReference& outer_reference() const;
  ::substrait::Expression_FieldReference_OuterReference* release_outer_reference();
  ::substrait::Expression_FieldReference_OuterReference* mutable_outer_reference();
  void set_allocated_outer_reference(::substrait::Expression_FieldReference_OuterReference* outer_reference);

  void clear_reference_type();
  ReferenceTypeCase reference_type_case() const;
  void clear_root_type();
  RootTypeCase root_type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.FieldReference)
 private:
  void set_has_direct_reference();
  void set_has_masked_reference();
  void set_has_expression();
  void set_has_root_reference();
  void set_has_outer_reference();

  inline bool has_reference_type() const;
  inline void clear_has_reference_type();

  inline bool has_root_type() const;
  inline void clear_has_root_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ReferenceTypeUnion {
    ReferenceTypeUnion() {}
    ::substrait::Expression_ReferenceSegment* direct_reference_;
    ::substrait::Expression_MaskExpression* masked_reference_;
  } reference_type_;
  union RootTypeUnion {
    RootTypeUnion() {}
    ::substrait::Expression* expression_;
    ::substrait::Expression_FieldReference_RootReference* root_reference_;
    ::substrait::Expression_FieldReference_OuterReference* outer_reference_;
  } root_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[2];

  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_Subquery_Scalar : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.Subquery.Scalar) */ {
 public:
  Expression_Subquery_Scalar();
  virtual ~Expression_Subquery_Scalar();

  Expression_Subquery_Scalar(const Expression_Subquery_Scalar& from);

  inline Expression_Subquery_Scalar& operator=(const Expression_Subquery_Scalar& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_Subquery_Scalar(Expression_Subquery_Scalar&& from) noexcept
    : Expression_Subquery_Scalar() {
    *this = ::std::move(from);
  }

  inline Expression_Subquery_Scalar& operator=(Expression_Subquery_Scalar&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_Subquery_Scalar& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_Subquery_Scalar* internal_default_instance() {
    return reinterpret_cast<const Expression_Subquery_Scalar*>(
               &_Expression_Subquery_Scalar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    99;

  void Swap(Expression_Subquery_Scalar* other);
  friend void swap(Expression_Subquery_Scalar& a, Expression_Subquery_Scalar& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_Subquery_Scalar* New() const final {
    return CreateMaybeMessage<Expression_Subquery_Scalar>(NULL);
  }

  Expression_Subquery_Scalar* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_Subquery_Scalar>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_Subquery_Scalar& from);
  void MergeFrom(const Expression_Subquery_Scalar& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_Subquery_Scalar* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .substrait.Rel input = 1;
  bool has_input() const;
  void clear_input();
  static const int kInputFieldNumber = 1;
  private:
  const ::substrait::Rel& _internal_input() const;
  public:
  const ::substrait::Rel& input() const;
  ::substrait::Rel* release_input();
  ::substrait::Rel* mutable_input();
  void set_allocated_input(::substrait::Rel* input);

  // @@protoc_insertion_point(class_scope:substrait.Expression.Subquery.Scalar)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::substrait::Rel* input_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_Subquery_InPredicate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.Subquery.InPredicate) */ {
 public:
  Expression_Subquery_InPredicate();
  virtual ~Expression_Subquery_InPredicate();

  Expression_Subquery_InPredicate(const Expression_Subquery_InPredicate& from);

  inline Expression_Subquery_InPredicate& operator=(const Expression_Subquery_InPredicate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_Subquery_InPredicate(Expression_Subquery_InPredicate&& from) noexcept
    : Expression_Subquery_InPredicate() {
    *this = ::std::move(from);
  }

  inline Expression_Subquery_InPredicate& operator=(Expression_Subquery_InPredicate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_Subquery_InPredicate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_Subquery_InPredicate* internal_default_instance() {
    return reinterpret_cast<const Expression_Subquery_InPredicate*>(
               &_Expression_Subquery_InPredicate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    100;

  void Swap(Expression_Subquery_InPredicate* other);
  friend void swap(Expression_Subquery_InPredicate& a, Expression_Subquery_InPredicate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_Subquery_InPredicate* New() const final {
    return CreateMaybeMessage<Expression_Subquery_InPredicate>(NULL);
  }

  Expression_Subquery_InPredicate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_Subquery_InPredicate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_Subquery_InPredicate& from);
  void MergeFrom(const Expression_Subquery_InPredicate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_Subquery_InPredicate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .substrait.Expression needles = 1;
  int needles_size() const;
  void clear_needles();
  static const int kNeedlesFieldNumber = 1;
  ::substrait::Expression* mutable_needles(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression >*
      mutable_needles();
  const ::substrait::Expression& needles(int index) const;
  ::substrait::Expression* add_needles();
  const ::google::protobuf::RepeatedPtrField< ::substrait::Expression >&
      needles() const;

  // .substrait.Rel haystack = 2;
  bool has_haystack() const;
  void clear_haystack();
  static const int kHaystackFieldNumber = 2;
  private:
  const ::substrait::Rel& _internal_haystack() const;
  public:
  const ::substrait::Rel& haystack() const;
  ::substrait::Rel* release_haystack();
  ::substrait::Rel* mutable_haystack();
  void set_allocated_haystack(::substrait::Rel* haystack);

  // @@protoc_insertion_point(class_scope:substrait.Expression.Subquery.InPredicate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression > needles_;
  ::substrait::Rel* haystack_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_Subquery_SetPredicate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.Subquery.SetPredicate) */ {
 public:
  Expression_Subquery_SetPredicate();
  virtual ~Expression_Subquery_SetPredicate();

  Expression_Subquery_SetPredicate(const Expression_Subquery_SetPredicate& from);

  inline Expression_Subquery_SetPredicate& operator=(const Expression_Subquery_SetPredicate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_Subquery_SetPredicate(Expression_Subquery_SetPredicate&& from) noexcept
    : Expression_Subquery_SetPredicate() {
    *this = ::std::move(from);
  }

  inline Expression_Subquery_SetPredicate& operator=(Expression_Subquery_SetPredicate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_Subquery_SetPredicate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_Subquery_SetPredicate* internal_default_instance() {
    return reinterpret_cast<const Expression_Subquery_SetPredicate*>(
               &_Expression_Subquery_SetPredicate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    101;

  void Swap(Expression_Subquery_SetPredicate* other);
  friend void swap(Expression_Subquery_SetPredicate& a, Expression_Subquery_SetPredicate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_Subquery_SetPredicate* New() const final {
    return CreateMaybeMessage<Expression_Subquery_SetPredicate>(NULL);
  }

  Expression_Subquery_SetPredicate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_Subquery_SetPredicate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_Subquery_SetPredicate& from);
  void MergeFrom(const Expression_Subquery_SetPredicate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_Subquery_SetPredicate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_Subquery_SetPredicate_PredicateOp PredicateOp;
  static const PredicateOp PREDICATE_OP_UNSPECIFIED =
    Expression_Subquery_SetPredicate_PredicateOp_PREDICATE_OP_UNSPECIFIED;
  static const PredicateOp PREDICATE_OP_EXISTS =
    Expression_Subquery_SetPredicate_PredicateOp_PREDICATE_OP_EXISTS;
  static const PredicateOp PREDICATE_OP_UNIQUE =
    Expression_Subquery_SetPredicate_PredicateOp_PREDICATE_OP_UNIQUE;
  static inline bool PredicateOp_IsValid(int value) {
    return Expression_Subquery_SetPredicate_PredicateOp_IsValid(value);
  }
  static const PredicateOp PredicateOp_MIN =
    Expression_Subquery_SetPredicate_PredicateOp_PredicateOp_MIN;
  static const PredicateOp PredicateOp_MAX =
    Expression_Subquery_SetPredicate_PredicateOp_PredicateOp_MAX;
  static const int PredicateOp_ARRAYSIZE =
    Expression_Subquery_SetPredicate_PredicateOp_PredicateOp_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PredicateOp_descriptor() {
    return Expression_Subquery_SetPredicate_PredicateOp_descriptor();
  }
  static inline const ::std::string& PredicateOp_Name(PredicateOp value) {
    return Expression_Subquery_SetPredicate_PredicateOp_Name(value);
  }
  static inline bool PredicateOp_Parse(const ::std::string& name,
      PredicateOp* value) {
    return Expression_Subquery_SetPredicate_PredicateOp_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .substrait.Rel tuples = 2;
  bool has_tuples() const;
  void clear_tuples();
  static const int kTuplesFieldNumber = 2;
  private:
  const ::substrait::Rel& _internal_tuples() const;
  public:
  const ::substrait::Rel& tuples() const;
  ::substrait::Rel* release_tuples();
  ::substrait::Rel* mutable_tuples();
  void set_allocated_tuples(::substrait::Rel* tuples);

  // .substrait.Expression.Subquery.SetPredicate.PredicateOp predicate_op = 1;
  void clear_predicate_op();
  static const int kPredicateOpFieldNumber = 1;
  ::substrait::Expression_Subquery_SetPredicate_PredicateOp predicate_op() const;
  void set_predicate_op(::substrait::Expression_Subquery_SetPredicate_PredicateOp value);

  // @@protoc_insertion_point(class_scope:substrait.Expression.Subquery.SetPredicate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::substrait::Rel* tuples_;
  int predicate_op_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_Subquery_SetComparison : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.Subquery.SetComparison) */ {
 public:
  Expression_Subquery_SetComparison();
  virtual ~Expression_Subquery_SetComparison();

  Expression_Subquery_SetComparison(const Expression_Subquery_SetComparison& from);

  inline Expression_Subquery_SetComparison& operator=(const Expression_Subquery_SetComparison& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_Subquery_SetComparison(Expression_Subquery_SetComparison&& from) noexcept
    : Expression_Subquery_SetComparison() {
    *this = ::std::move(from);
  }

  inline Expression_Subquery_SetComparison& operator=(Expression_Subquery_SetComparison&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_Subquery_SetComparison& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_Subquery_SetComparison* internal_default_instance() {
    return reinterpret_cast<const Expression_Subquery_SetComparison*>(
               &_Expression_Subquery_SetComparison_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    102;

  void Swap(Expression_Subquery_SetComparison* other);
  friend void swap(Expression_Subquery_SetComparison& a, Expression_Subquery_SetComparison& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_Subquery_SetComparison* New() const final {
    return CreateMaybeMessage<Expression_Subquery_SetComparison>(NULL);
  }

  Expression_Subquery_SetComparison* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_Subquery_SetComparison>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_Subquery_SetComparison& from);
  void MergeFrom(const Expression_Subquery_SetComparison& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_Subquery_SetComparison* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_Subquery_SetComparison_ComparisonOp ComparisonOp;
  static const ComparisonOp COMPARISON_OP_UNSPECIFIED =
    Expression_Subquery_SetComparison_ComparisonOp_COMPARISON_OP_UNSPECIFIED;
  static const ComparisonOp COMPARISON_OP_EQ =
    Expression_Subquery_SetComparison_ComparisonOp_COMPARISON_OP_EQ;
  static const ComparisonOp COMPARISON_OP_NE =
    Expression_Subquery_SetComparison_ComparisonOp_COMPARISON_OP_NE;
  static const ComparisonOp COMPARISON_OP_LT =
    Expression_Subquery_SetComparison_ComparisonOp_COMPARISON_OP_LT;
  static const ComparisonOp COMPARISON_OP_GT =
    Expression_Subquery_SetComparison_ComparisonOp_COMPARISON_OP_GT;
  static const ComparisonOp COMPARISON_OP_LE =
    Expression_Subquery_SetComparison_ComparisonOp_COMPARISON_OP_LE;
  static const ComparisonOp COMPARISON_OP_GE =
    Expression_Subquery_SetComparison_ComparisonOp_COMPARISON_OP_GE;
  static inline bool ComparisonOp_IsValid(int value) {
    return Expression_Subquery_SetComparison_ComparisonOp_IsValid(value);
  }
  static const ComparisonOp ComparisonOp_MIN =
    Expression_Subquery_SetComparison_ComparisonOp_ComparisonOp_MIN;
  static const ComparisonOp ComparisonOp_MAX =
    Expression_Subquery_SetComparison_ComparisonOp_ComparisonOp_MAX;
  static const int ComparisonOp_ARRAYSIZE =
    Expression_Subquery_SetComparison_ComparisonOp_ComparisonOp_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ComparisonOp_descriptor() {
    return Expression_Subquery_SetComparison_ComparisonOp_descriptor();
  }
  static inline const ::std::string& ComparisonOp_Name(ComparisonOp value) {
    return Expression_Subquery_SetComparison_ComparisonOp_Name(value);
  }
  static inline bool ComparisonOp_Parse(const ::std::string& name,
      ComparisonOp* value) {
    return Expression_Subquery_SetComparison_ComparisonOp_Parse(name, value);
  }

  typedef Expression_Subquery_SetComparison_ReductionOp ReductionOp;
  static const ReductionOp REDUCTION_OP_UNSPECIFIED =
    Expression_Subquery_SetComparison_ReductionOp_REDUCTION_OP_UNSPECIFIED;
  static const ReductionOp REDUCTION_OP_ANY =
    Expression_Subquery_SetComparison_ReductionOp_REDUCTION_OP_ANY;
  static const ReductionOp REDUCTION_OP_ALL =
    Expression_Subquery_SetComparison_ReductionOp_REDUCTION_OP_ALL;
  static inline bool ReductionOp_IsValid(int value) {
    return Expression_Subquery_SetComparison_ReductionOp_IsValid(value);
  }
  static const ReductionOp ReductionOp_MIN =
    Expression_Subquery_SetComparison_ReductionOp_ReductionOp_MIN;
  static const ReductionOp ReductionOp_MAX =
    Expression_Subquery_SetComparison_ReductionOp_ReductionOp_MAX;
  static const int ReductionOp_ARRAYSIZE =
    Expression_Subquery_SetComparison_ReductionOp_ReductionOp_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ReductionOp_descriptor() {
    return Expression_Subquery_SetComparison_ReductionOp_descriptor();
  }
  static inline const ::std::string& ReductionOp_Name(ReductionOp value) {
    return Expression_Subquery_SetComparison_ReductionOp_Name(value);
  }
  static inline bool ReductionOp_Parse(const ::std::string& name,
      ReductionOp* value) {
    return Expression_Subquery_SetComparison_ReductionOp_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .substrait.Expression left = 3;
  bool has_left() const;
  void clear_left();
  static const int kLeftFieldNumber = 3;
  private:
  const ::substrait::Expression& _internal_left() const;
  public:
  const ::substrait::Expression& left() const;
  ::substrait::Expression* release_left();
  ::substrait::Expression* mutable_left();
  void set_allocated_left(::substrait::Expression* left);

  // .substrait.Rel right = 4;
  bool has_right() const;
  void clear_right();
  static const int kRightFieldNumber = 4;
  private:
  const ::substrait::Rel& _internal_right() const;
  public:
  const ::substrait::Rel& right() const;
  ::substrait::Rel* release_right();
  ::substrait::Rel* mutable_right();
  void set_allocated_right(::substrait::Rel* right);

  // .substrait.Expression.Subquery.SetComparison.ReductionOp reduction_op = 1;
  void clear_reduction_op();
  static const int kReductionOpFieldNumber = 1;
  ::substrait::Expression_Subquery_SetComparison_ReductionOp reduction_op() const;
  void set_reduction_op(::substrait::Expression_Subquery_SetComparison_ReductionOp value);

  // .substrait.Expression.Subquery.SetComparison.ComparisonOp comparison_op = 2;
  void clear_comparison_op();
  static const int kComparisonOpFieldNumber = 2;
  ::substrait::Expression_Subquery_SetComparison_ComparisonOp comparison_op() const;
  void set_comparison_op(::substrait::Expression_Subquery_SetComparison_ComparisonOp value);

  // @@protoc_insertion_point(class_scope:substrait.Expression.Subquery.SetComparison)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::substrait::Expression* left_;
  ::substrait::Rel* right_;
  int reduction_op_;
  int comparison_op_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression_Subquery : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression.Subquery) */ {
 public:
  Expression_Subquery();
  virtual ~Expression_Subquery();

  Expression_Subquery(const Expression_Subquery& from);

  inline Expression_Subquery& operator=(const Expression_Subquery& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression_Subquery(Expression_Subquery&& from) noexcept
    : Expression_Subquery() {
    *this = ::std::move(from);
  }

  inline Expression_Subquery& operator=(Expression_Subquery&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression_Subquery& default_instance();

  enum SubqueryTypeCase {
    kScalar = 1,
    kInPredicate = 2,
    kSetPredicate = 3,
    kSetComparison = 4,
    SUBQUERY_TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression_Subquery* internal_default_instance() {
    return reinterpret_cast<const Expression_Subquery*>(
               &_Expression_Subquery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    103;

  void Swap(Expression_Subquery* other);
  friend void swap(Expression_Subquery& a, Expression_Subquery& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression_Subquery* New() const final {
    return CreateMaybeMessage<Expression_Subquery>(NULL);
  }

  Expression_Subquery* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression_Subquery>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression_Subquery& from);
  void MergeFrom(const Expression_Subquery& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression_Subquery* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_Subquery_Scalar Scalar;
  typedef Expression_Subquery_InPredicate InPredicate;
  typedef Expression_Subquery_SetPredicate SetPredicate;
  typedef Expression_Subquery_SetComparison SetComparison;

  // accessors -------------------------------------------------------

  // .substrait.Expression.Subquery.Scalar scalar = 1;
  bool has_scalar() const;
  void clear_scalar();
  static const int kScalarFieldNumber = 1;
  private:
  const ::substrait::Expression_Subquery_Scalar& _internal_scalar() const;
  public:
  const ::substrait::Expression_Subquery_Scalar& scalar() const;
  ::substrait::Expression_Subquery_Scalar* release_scalar();
  ::substrait::Expression_Subquery_Scalar* mutable_scalar();
  void set_allocated_scalar(::substrait::Expression_Subquery_Scalar* scalar);

  // .substrait.Expression.Subquery.InPredicate in_predicate = 2;
  bool has_in_predicate() const;
  void clear_in_predicate();
  static const int kInPredicateFieldNumber = 2;
  private:
  const ::substrait::Expression_Subquery_InPredicate& _internal_in_predicate() const;
  public:
  const ::substrait::Expression_Subquery_InPredicate& in_predicate() const;
  ::substrait::Expression_Subquery_InPredicate* release_in_predicate();
  ::substrait::Expression_Subquery_InPredicate* mutable_in_predicate();
  void set_allocated_in_predicate(::substrait::Expression_Subquery_InPredicate* in_predicate);

  // .substrait.Expression.Subquery.SetPredicate set_predicate = 3;
  bool has_set_predicate() const;
  void clear_set_predicate();
  static const int kSetPredicateFieldNumber = 3;
  private:
  const ::substrait::Expression_Subquery_SetPredicate& _internal_set_predicate() const;
  public:
  const ::substrait::Expression_Subquery_SetPredicate& set_predicate() const;
  ::substrait::Expression_Subquery_SetPredicate* release_set_predicate();
  ::substrait::Expression_Subquery_SetPredicate* mutable_set_predicate();
  void set_allocated_set_predicate(::substrait::Expression_Subquery_SetPredicate* set_predicate);

  // .substrait.Expression.Subquery.SetComparison set_comparison = 4;
  bool has_set_comparison() const;
  void clear_set_comparison();
  static const int kSetComparisonFieldNumber = 4;
  private:
  const ::substrait::Expression_Subquery_SetComparison& _internal_set_comparison() const;
  public:
  const ::substrait::Expression_Subquery_SetComparison& set_comparison() const;
  ::substrait::Expression_Subquery_SetComparison* release_set_comparison();
  ::substrait::Expression_Subquery_SetComparison* mutable_set_comparison();
  void set_allocated_set_comparison(::substrait::Expression_Subquery_SetComparison* set_comparison);

  void clear_subquery_type();
  SubqueryTypeCase subquery_type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression.Subquery)
 private:
  void set_has_scalar();
  void set_has_in_predicate();
  void set_has_set_predicate();
  void set_has_set_comparison();

  inline bool has_subquery_type() const;
  inline void clear_has_subquery_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union SubqueryTypeUnion {
    SubqueryTypeUnion() {}
    ::substrait::Expression_Subquery_Scalar* scalar_;
    ::substrait::Expression_Subquery_InPredicate* in_predicate_;
    ::substrait::Expression_Subquery_SetPredicate* set_predicate_;
    ::substrait::Expression_Subquery_SetComparison* set_comparison_;
  } subquery_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.Expression) */ {
 public:
  Expression();
  virtual ~Expression();

  Expression(const Expression& from);

  inline Expression& operator=(const Expression& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression(Expression&& from) noexcept
    : Expression() {
    *this = ::std::move(from);
  }

  inline Expression& operator=(Expression&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression& default_instance();

  enum RexTypeCase {
    kLiteral = 1,
    kSelection = 2,
    kScalarFunction = 3,
    kWindowFunction = 5,
    kIfThen = 6,
    kSwitchExpression = 7,
    kSingularOrList = 8,
    kMultiOrList = 9,
    kCast = 11,
    kSubquery = 12,
    kNested = 13,
    kEnum = 10,
    REX_TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression* internal_default_instance() {
    return reinterpret_cast<const Expression*>(
               &_Expression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    104;

  void Swap(Expression* other);
  friend void swap(Expression& a, Expression& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression* New() const final {
    return CreateMaybeMessage<Expression>(NULL);
  }

  Expression* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression& from);
  void MergeFrom(const Expression& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_Enum Enum;
  typedef Expression_Literal Literal;
  typedef Expression_Nested Nested;
  typedef Expression_ScalarFunction ScalarFunction;
  typedef Expression_WindowFunction WindowFunction;
  typedef Expression_IfThen IfThen;
  typedef Expression_Cast Cast;
  typedef Expression_SwitchExpression SwitchExpression;
  typedef Expression_SingularOrList SingularOrList;
  typedef Expression_MultiOrList MultiOrList;
  typedef Expression_EmbeddedFunction EmbeddedFunction;
  typedef Expression_ReferenceSegment ReferenceSegment;
  typedef Expression_MaskExpression MaskExpression;
  typedef Expression_FieldReference FieldReference;
  typedef Expression_Subquery Subquery;

  // accessors -------------------------------------------------------

  // .substrait.Expression.Literal literal = 1;
  bool has_literal() const;
  void clear_literal();
  static const int kLiteralFieldNumber = 1;
  private:
  const ::substrait::Expression_Literal& _internal_literal() const;
  public:
  const ::substrait::Expression_Literal& literal() const;
  ::substrait::Expression_Literal* release_literal();
  ::substrait::Expression_Literal* mutable_literal();
  void set_allocated_literal(::substrait::Expression_Literal* literal);

  // .substrait.Expression.FieldReference selection = 2;
  bool has_selection() const;
  void clear_selection();
  static const int kSelectionFieldNumber = 2;
  private:
  const ::substrait::Expression_FieldReference& _internal_selection() const;
  public:
  const ::substrait::Expression_FieldReference& selection() const;
  ::substrait::Expression_FieldReference* release_selection();
  ::substrait::Expression_FieldReference* mutable_selection();
  void set_allocated_selection(::substrait::Expression_FieldReference* selection);

  // .substrait.Expression.ScalarFunction scalar_function = 3;
  bool has_scalar_function() const;
  void clear_scalar_function();
  static const int kScalarFunctionFieldNumber = 3;
  private:
  const ::substrait::Expression_ScalarFunction& _internal_scalar_function() const;
  public:
  const ::substrait::Expression_ScalarFunction& scalar_function() const;
  ::substrait::Expression_ScalarFunction* release_scalar_function();
  ::substrait::Expression_ScalarFunction* mutable_scalar_function();
  void set_allocated_scalar_function(::substrait::Expression_ScalarFunction* scalar_function);

  // .substrait.Expression.WindowFunction window_function = 5;
  bool has_window_function() const;
  void clear_window_function();
  static const int kWindowFunctionFieldNumber = 5;
  private:
  const ::substrait::Expression_WindowFunction& _internal_window_function() const;
  public:
  const ::substrait::Expression_WindowFunction& window_function() const;
  ::substrait::Expression_WindowFunction* release_window_function();
  ::substrait::Expression_WindowFunction* mutable_window_function();
  void set_allocated_window_function(::substrait::Expression_WindowFunction* window_function);

  // .substrait.Expression.IfThen if_then = 6;
  bool has_if_then() const;
  void clear_if_then();
  static const int kIfThenFieldNumber = 6;
  private:
  const ::substrait::Expression_IfThen& _internal_if_then() const;
  public:
  const ::substrait::Expression_IfThen& if_then() const;
  ::substrait::Expression_IfThen* release_if_then();
  ::substrait::Expression_IfThen* mutable_if_then();
  void set_allocated_if_then(::substrait::Expression_IfThen* if_then);

  // .substrait.Expression.SwitchExpression switch_expression = 7;
  bool has_switch_expression() const;
  void clear_switch_expression();
  static const int kSwitchExpressionFieldNumber = 7;
  private:
  const ::substrait::Expression_SwitchExpression& _internal_switch_expression() const;
  public:
  const ::substrait::Expression_SwitchExpression& switch_expression() const;
  ::substrait::Expression_SwitchExpression* release_switch_expression();
  ::substrait::Expression_SwitchExpression* mutable_switch_expression();
  void set_allocated_switch_expression(::substrait::Expression_SwitchExpression* switch_expression);

  // .substrait.Expression.SingularOrList singular_or_list = 8;
  bool has_singular_or_list() const;
  void clear_singular_or_list();
  static const int kSingularOrListFieldNumber = 8;
  private:
  const ::substrait::Expression_SingularOrList& _internal_singular_or_list() const;
  public:
  const ::substrait::Expression_SingularOrList& singular_or_list() const;
  ::substrait::Expression_SingularOrList* release_singular_or_list();
  ::substrait::Expression_SingularOrList* mutable_singular_or_list();
  void set_allocated_singular_or_list(::substrait::Expression_SingularOrList* singular_or_list);

  // .substrait.Expression.MultiOrList multi_or_list = 9;
  bool has_multi_or_list() const;
  void clear_multi_or_list();
  static const int kMultiOrListFieldNumber = 9;
  private:
  const ::substrait::Expression_MultiOrList& _internal_multi_or_list() const;
  public:
  const ::substrait::Expression_MultiOrList& multi_or_list() const;
  ::substrait::Expression_MultiOrList* release_multi_or_list();
  ::substrait::Expression_MultiOrList* mutable_multi_or_list();
  void set_allocated_multi_or_list(::substrait::Expression_MultiOrList* multi_or_list);

  // .substrait.Expression.Cast cast = 11;
  bool has_cast() const;
  void clear_cast();
  static const int kCastFieldNumber = 11;
  private:
  const ::substrait::Expression_Cast& _internal_cast() const;
  public:
  const ::substrait::Expression_Cast& cast() const;
  ::substrait::Expression_Cast* release_cast();
  ::substrait::Expression_Cast* mutable_cast();
  void set_allocated_cast(::substrait::Expression_Cast* cast);

  // .substrait.Expression.Subquery subquery = 12;
  bool has_subquery() const;
  void clear_subquery();
  static const int kSubqueryFieldNumber = 12;
  private:
  const ::substrait::Expression_Subquery& _internal_subquery() const;
  public:
  const ::substrait::Expression_Subquery& subquery() const;
  ::substrait::Expression_Subquery* release_subquery();
  ::substrait::Expression_Subquery* mutable_subquery();
  void set_allocated_subquery(::substrait::Expression_Subquery* subquery);

  // .substrait.Expression.Nested nested = 13;
  bool has_nested() const;
  void clear_nested();
  static const int kNestedFieldNumber = 13;
  private:
  const ::substrait::Expression_Nested& _internal_nested() const;
  public:
  const ::substrait::Expression_Nested& nested() const;
  ::substrait::Expression_Nested* release_nested();
  ::substrait::Expression_Nested* mutable_nested();
  void set_allocated_nested(::substrait::Expression_Nested* nested);

  // .substrait.Expression.Enum enum = 10 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_enum_() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_enum_();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kEnumFieldNumber = 10;
  private:
  const ::substrait::Expression_Enum& _internal_enum_() const;
  public:
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::substrait::Expression_Enum& enum_() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::substrait::Expression_Enum* release_enum_();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::substrait::Expression_Enum* mutable_enum_();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_allocated_enum_(::substrait::Expression_Enum* enum_);

  void clear_rex_type();
  RexTypeCase rex_type_case() const;
  // @@protoc_insertion_point(class_scope:substrait.Expression)
 private:
  void set_has_literal();
  void set_has_selection();
  void set_has_scalar_function();
  void set_has_window_function();
  void set_has_if_then();
  void set_has_switch_expression();
  void set_has_singular_or_list();
  void set_has_multi_or_list();
  void set_has_cast();
  void set_has_subquery();
  void set_has_nested();
  void set_has_enum_();

  inline bool has_rex_type() const;
  inline void clear_has_rex_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union RexTypeUnion {
    RexTypeUnion() {}
    ::substrait::Expression_Literal* literal_;
    ::substrait::Expression_FieldReference* selection_;
    ::substrait::Expression_ScalarFunction* scalar_function_;
    ::substrait::Expression_WindowFunction* window_function_;
    ::substrait::Expression_IfThen* if_then_;
    ::substrait::Expression_SwitchExpression* switch_expression_;
    ::substrait::Expression_SingularOrList* singular_or_list_;
    ::substrait::Expression_MultiOrList* multi_or_list_;
    ::substrait::Expression_Cast* cast_;
    ::substrait::Expression_Subquery* subquery_;
    ::substrait::Expression_Nested* nested_;
    ::substrait::Expression_Enum* enum__;
  } rex_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SortField : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.SortField) */ {
 public:
  SortField();
  virtual ~SortField();

  SortField(const SortField& from);

  inline SortField& operator=(const SortField& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SortField(SortField&& from) noexcept
    : SortField() {
    *this = ::std::move(from);
  }

  inline SortField& operator=(SortField&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SortField& default_instance();

  enum SortKindCase {
    kDirection = 2,
    kComparisonFunctionReference = 3,
    SORT_KIND_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SortField* internal_default_instance() {
    return reinterpret_cast<const SortField*>(
               &_SortField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    105;

  void Swap(SortField* other);
  friend void swap(SortField& a, SortField& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SortField* New() const final {
    return CreateMaybeMessage<SortField>(NULL);
  }

  SortField* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SortField>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SortField& from);
  void MergeFrom(const SortField& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SortField* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SortField_SortDirection SortDirection;
  static const SortDirection SORT_DIRECTION_UNSPECIFIED =
    SortField_SortDirection_SORT_DIRECTION_UNSPECIFIED;
  static const SortDirection SORT_DIRECTION_ASC_NULLS_FIRST =
    SortField_SortDirection_SORT_DIRECTION_ASC_NULLS_FIRST;
  static const SortDirection SORT_DIRECTION_ASC_NULLS_LAST =
    SortField_SortDirection_SORT_DIRECTION_ASC_NULLS_LAST;
  static const SortDirection SORT_DIRECTION_DESC_NULLS_FIRST =
    SortField_SortDirection_SORT_DIRECTION_DESC_NULLS_FIRST;
  static const SortDirection SORT_DIRECTION_DESC_NULLS_LAST =
    SortField_SortDirection_SORT_DIRECTION_DESC_NULLS_LAST;
  static const SortDirection SORT_DIRECTION_CLUSTERED =
    SortField_SortDirection_SORT_DIRECTION_CLUSTERED;
  static inline bool SortDirection_IsValid(int value) {
    return SortField_SortDirection_IsValid(value);
  }
  static const SortDirection SortDirection_MIN =
    SortField_SortDirection_SortDirection_MIN;
  static const SortDirection SortDirection_MAX =
    SortField_SortDirection_SortDirection_MAX;
  static const int SortDirection_ARRAYSIZE =
    SortField_SortDirection_SortDirection_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SortDirection_descriptor() {
    return SortField_SortDirection_descriptor();
  }
  static inline const ::std::string& SortDirection_Name(SortDirection value) {
    return SortField_SortDirection_Name(value);
  }
  static inline bool SortDirection_Parse(const ::std::string& name,
      SortDirection* value) {
    return SortField_SortDirection_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .substrait.Expression expr = 1;
  bool has_expr() const;
  void clear_expr();
  static const int kExprFieldNumber = 1;
  private:
  const ::substrait::Expression& _internal_expr() const;
  public:
  const ::substrait::Expression& expr() const;
  ::substrait::Expression* release_expr();
  ::substrait::Expression* mutable_expr();
  void set_allocated_expr(::substrait::Expression* expr);

  // .substrait.SortField.SortDirection direction = 2;
  private:
  bool has_direction() const;
  public:
  void clear_direction();
  static const int kDirectionFieldNumber = 2;
  ::substrait::SortField_SortDirection direction() const;
  void set_direction(::substrait::SortField_SortDirection value);

  // uint32 comparison_function_reference = 3;
  private:
  bool has_comparison_function_reference() const;
  public:
  void clear_comparison_function_reference();
  static const int kComparisonFunctionReferenceFieldNumber = 3;
  ::google::protobuf::uint32 comparison_function_reference() const;
  void set_comparison_function_reference(::google::protobuf::uint32 value);

  void clear_sort_kind();
  SortKindCase sort_kind_case() const;
  // @@protoc_insertion_point(class_scope:substrait.SortField)
 private:
  void set_has_direction();
  void set_has_comparison_function_reference();

  inline bool has_sort_kind() const;
  inline void clear_has_sort_kind();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::substrait::Expression* expr_;
  union SortKindUnion {
    SortKindUnion() {}
    int direction_;
    ::google::protobuf::uint32 comparison_function_reference_;
  } sort_kind_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AggregateFunction_ReferenceRel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.AggregateFunction.ReferenceRel) */ {
 public:
  AggregateFunction_ReferenceRel();
  virtual ~AggregateFunction_ReferenceRel();

  AggregateFunction_ReferenceRel(const AggregateFunction_ReferenceRel& from);

  inline AggregateFunction_ReferenceRel& operator=(const AggregateFunction_ReferenceRel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AggregateFunction_ReferenceRel(AggregateFunction_ReferenceRel&& from) noexcept
    : AggregateFunction_ReferenceRel() {
    *this = ::std::move(from);
  }

  inline AggregateFunction_ReferenceRel& operator=(AggregateFunction_ReferenceRel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AggregateFunction_ReferenceRel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AggregateFunction_ReferenceRel* internal_default_instance() {
    return reinterpret_cast<const AggregateFunction_ReferenceRel*>(
               &_AggregateFunction_ReferenceRel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    106;

  void Swap(AggregateFunction_ReferenceRel* other);
  friend void swap(AggregateFunction_ReferenceRel& a, AggregateFunction_ReferenceRel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AggregateFunction_ReferenceRel* New() const final {
    return CreateMaybeMessage<AggregateFunction_ReferenceRel>(NULL);
  }

  AggregateFunction_ReferenceRel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AggregateFunction_ReferenceRel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AggregateFunction_ReferenceRel& from);
  void MergeFrom(const AggregateFunction_ReferenceRel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AggregateFunction_ReferenceRel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 subtree_ordinal = 1;
  void clear_subtree_ordinal();
  static const int kSubtreeOrdinalFieldNumber = 1;
  ::google::protobuf::int32 subtree_ordinal() const;
  void set_subtree_ordinal(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:substrait.AggregateFunction.ReferenceRel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 subtree_ordinal_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AggregateFunction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.AggregateFunction) */ {
 public:
  AggregateFunction();
  virtual ~AggregateFunction();

  AggregateFunction(const AggregateFunction& from);

  inline AggregateFunction& operator=(const AggregateFunction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AggregateFunction(AggregateFunction&& from) noexcept
    : AggregateFunction() {
    *this = ::std::move(from);
  }

  inline AggregateFunction& operator=(AggregateFunction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AggregateFunction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AggregateFunction* internal_default_instance() {
    return reinterpret_cast<const AggregateFunction*>(
               &_AggregateFunction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    107;

  void Swap(AggregateFunction* other);
  friend void swap(AggregateFunction& a, AggregateFunction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AggregateFunction* New() const final {
    return CreateMaybeMessage<AggregateFunction>(NULL);
  }

  AggregateFunction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AggregateFunction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AggregateFunction& from);
  void MergeFrom(const AggregateFunction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AggregateFunction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AggregateFunction_ReferenceRel ReferenceRel;

  typedef AggregateFunction_AggregationInvocation AggregationInvocation;
  static const AggregationInvocation AGGREGATION_INVOCATION_UNSPECIFIED =
    AggregateFunction_AggregationInvocation_AGGREGATION_INVOCATION_UNSPECIFIED;
  static const AggregationInvocation AGGREGATION_INVOCATION_ALL =
    AggregateFunction_AggregationInvocation_AGGREGATION_INVOCATION_ALL;
  static const AggregationInvocation AGGREGATION_INVOCATION_DISTINCT =
    AggregateFunction_AggregationInvocation_AGGREGATION_INVOCATION_DISTINCT;
  static inline bool AggregationInvocation_IsValid(int value) {
    return AggregateFunction_AggregationInvocation_IsValid(value);
  }
  static const AggregationInvocation AggregationInvocation_MIN =
    AggregateFunction_AggregationInvocation_AggregationInvocation_MIN;
  static const AggregationInvocation AggregationInvocation_MAX =
    AggregateFunction_AggregationInvocation_AggregationInvocation_MAX;
  static const int AggregationInvocation_ARRAYSIZE =
    AggregateFunction_AggregationInvocation_AggregationInvocation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AggregationInvocation_descriptor() {
    return AggregateFunction_AggregationInvocation_descriptor();
  }
  static inline const ::std::string& AggregationInvocation_Name(AggregationInvocation value) {
    return AggregateFunction_AggregationInvocation_Name(value);
  }
  static inline bool AggregationInvocation_Parse(const ::std::string& name,
      AggregationInvocation* value) {
    return AggregateFunction_AggregationInvocation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .substrait.Expression args = 2 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR int args_size() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_args();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kArgsFieldNumber = 2;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::substrait::Expression* mutable_args(int index);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::google::protobuf::RepeatedPtrField< ::substrait::Expression >*
      mutable_args();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::substrait::Expression& args(int index) const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::substrait::Expression* add_args();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::google::protobuf::RepeatedPtrField< ::substrait::Expression >&
      args() const;

  // repeated .substrait.SortField sorts = 3;
  int sorts_size() const;
  void clear_sorts();
  static const int kSortsFieldNumber = 3;
  ::substrait::SortField* mutable_sorts(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::SortField >*
      mutable_sorts();
  const ::substrait::SortField& sorts(int index) const;
  ::substrait::SortField* add_sorts();
  const ::google::protobuf::RepeatedPtrField< ::substrait::SortField >&
      sorts() const;

  // repeated .substrait.FunctionArgument arguments = 7;
  int arguments_size() const;
  void clear_arguments();
  static const int kArgumentsFieldNumber = 7;
  ::substrait::FunctionArgument* mutable_arguments(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::FunctionArgument >*
      mutable_arguments();
  const ::substrait::FunctionArgument& arguments(int index) const;
  ::substrait::FunctionArgument* add_arguments();
  const ::google::protobuf::RepeatedPtrField< ::substrait::FunctionArgument >&
      arguments() const;

  // repeated .substrait.FunctionOption options = 8;
  int options_size() const;
  void clear_options();
  static const int kOptionsFieldNumber = 8;
  ::substrait::FunctionOption* mutable_options(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::FunctionOption >*
      mutable_options();
  const ::substrait::FunctionOption& options(int index) const;
  ::substrait::FunctionOption* add_options();
  const ::google::protobuf::RepeatedPtrField< ::substrait::FunctionOption >&
      options() const;

  // .substrait.Type output_type = 5;
  bool has_output_type() const;
  void clear_output_type();
  static const int kOutputTypeFieldNumber = 5;
  private:
  const ::substrait::Type& _internal_output_type() const;
  public:
  const ::substrait::Type& output_type() const;
  ::substrait::Type* release_output_type();
  ::substrait::Type* mutable_output_type();
  void set_allocated_output_type(::substrait::Type* output_type);

  // uint32 function_reference = 1;
  void clear_function_reference();
  static const int kFunctionReferenceFieldNumber = 1;
  ::google::protobuf::uint32 function_reference() const;
  void set_function_reference(::google::protobuf::uint32 value);

  // .substrait.AggregationPhase phase = 4;
  void clear_phase();
  static const int kPhaseFieldNumber = 4;
  ::substrait::AggregationPhase phase() const;
  void set_phase(::substrait::AggregationPhase value);

  // .substrait.AggregateFunction.AggregationInvocation invocation = 6;
  void clear_invocation();
  static const int kInvocationFieldNumber = 6;
  ::substrait::AggregateFunction_AggregationInvocation invocation() const;
  void set_invocation(::substrait::AggregateFunction_AggregationInvocation value);

  // @@protoc_insertion_point(class_scope:substrait.AggregateFunction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::substrait::Expression > args_;
  ::google::protobuf::RepeatedPtrField< ::substrait::SortField > sorts_;
  ::google::protobuf::RepeatedPtrField< ::substrait::FunctionArgument > arguments_;
  ::google::protobuf::RepeatedPtrField< ::substrait::FunctionOption > options_;
  ::substrait::Type* output_type_;
  ::google::protobuf::uint32 function_reference_;
  int phase_;
  int invocation_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_substrait_2falgebra_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RelCommon_Direct

// -------------------------------------------------------------------

// RelCommon_Emit

// repeated int32 output_mapping = 1;
inline int RelCommon_Emit::output_mapping_size() const {
  return output_mapping_.size();
}
inline void RelCommon_Emit::clear_output_mapping() {
  output_mapping_.Clear();
}
inline ::google::protobuf::int32 RelCommon_Emit::output_mapping(int index) const {
  // @@protoc_insertion_point(field_get:substrait.RelCommon.Emit.output_mapping)
  return output_mapping_.Get(index);
}
inline void RelCommon_Emit::set_output_mapping(int index, ::google::protobuf::int32 value) {
  output_mapping_.Set(index, value);
  // @@protoc_insertion_point(field_set:substrait.RelCommon.Emit.output_mapping)
}
inline void RelCommon_Emit::add_output_mapping(::google::protobuf::int32 value) {
  output_mapping_.Add(value);
  // @@protoc_insertion_point(field_add:substrait.RelCommon.Emit.output_mapping)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
RelCommon_Emit::output_mapping() const {
  // @@protoc_insertion_point(field_list:substrait.RelCommon.Emit.output_mapping)
  return output_mapping_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
RelCommon_Emit::mutable_output_mapping() {
  // @@protoc_insertion_point(field_mutable_list:substrait.RelCommon.Emit.output_mapping)
  return &output_mapping_;
}

// -------------------------------------------------------------------

// RelCommon_Hint_Stats

// double row_count = 1;
inline void RelCommon_Hint_Stats::clear_row_count() {
  row_count_ = 0;
}
inline double RelCommon_Hint_Stats::row_count() const {
  // @@protoc_insertion_point(field_get:substrait.RelCommon.Hint.Stats.row_count)
  return row_count_;
}
inline void RelCommon_Hint_Stats::set_row_count(double value) {
  
  row_count_ = value;
  // @@protoc_insertion_point(field_set:substrait.RelCommon.Hint.Stats.row_count)
}

// double record_size = 2;
inline void RelCommon_Hint_Stats::clear_record_size() {
  record_size_ = 0;
}
inline double RelCommon_Hint_Stats::record_size() const {
  // @@protoc_insertion_point(field_get:substrait.RelCommon.Hint.Stats.record_size)
  return record_size_;
}
inline void RelCommon_Hint_Stats::set_record_size(double value) {
  
  record_size_ = value;
  // @@protoc_insertion_point(field_set:substrait.RelCommon.Hint.Stats.record_size)
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool RelCommon_Hint_Stats::has_advanced_extension() const {
  return this != internal_default_instance() && advanced_extension_ != NULL;
}
inline const ::substrait::extensions::AdvancedExtension& RelCommon_Hint_Stats::_internal_advanced_extension() const {
  return *advanced_extension_;
}
inline const ::substrait::extensions::AdvancedExtension& RelCommon_Hint_Stats::advanced_extension() const {
  const ::substrait::extensions::AdvancedExtension* p = advanced_extension_;
  // @@protoc_insertion_point(field_get:substrait.RelCommon.Hint.Stats.advanced_extension)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::extensions::AdvancedExtension*>(
      &::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline ::substrait::extensions::AdvancedExtension* RelCommon_Hint_Stats::release_advanced_extension() {
  // @@protoc_insertion_point(field_release:substrait.RelCommon.Hint.Stats.advanced_extension)
  
  ::substrait::extensions::AdvancedExtension* temp = advanced_extension_;
  advanced_extension_ = NULL;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* RelCommon_Hint_Stats::mutable_advanced_extension() {
  
  if (advanced_extension_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::extensions::AdvancedExtension>(GetArenaNoVirtual());
    advanced_extension_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.RelCommon.Hint.Stats.advanced_extension)
  return advanced_extension_;
}
inline void RelCommon_Hint_Stats::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(advanced_extension_);
  }
  if (advanced_extension) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      advanced_extension = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, advanced_extension, submessage_arena);
    }
    
  } else {
    
  }
  advanced_extension_ = advanced_extension;
  // @@protoc_insertion_point(field_set_allocated:substrait.RelCommon.Hint.Stats.advanced_extension)
}

// -------------------------------------------------------------------

// RelCommon_Hint_RuntimeConstraint

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool RelCommon_Hint_RuntimeConstraint::has_advanced_extension() const {
  return this != internal_default_instance() && advanced_extension_ != NULL;
}
inline const ::substrait::extensions::AdvancedExtension& RelCommon_Hint_RuntimeConstraint::_internal_advanced_extension() const {
  return *advanced_extension_;
}
inline const ::substrait::extensions::AdvancedExtension& RelCommon_Hint_RuntimeConstraint::advanced_extension() const {
  const ::substrait::extensions::AdvancedExtension* p = advanced_extension_;
  // @@protoc_insertion_point(field_get:substrait.RelCommon.Hint.RuntimeConstraint.advanced_extension)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::extensions::AdvancedExtension*>(
      &::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline ::substrait::extensions::AdvancedExtension* RelCommon_Hint_RuntimeConstraint::release_advanced_extension() {
  // @@protoc_insertion_point(field_release:substrait.RelCommon.Hint.RuntimeConstraint.advanced_extension)
  
  ::substrait::extensions::AdvancedExtension* temp = advanced_extension_;
  advanced_extension_ = NULL;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* RelCommon_Hint_RuntimeConstraint::mutable_advanced_extension() {
  
  if (advanced_extension_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::extensions::AdvancedExtension>(GetArenaNoVirtual());
    advanced_extension_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.RelCommon.Hint.RuntimeConstraint.advanced_extension)
  return advanced_extension_;
}
inline void RelCommon_Hint_RuntimeConstraint::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(advanced_extension_);
  }
  if (advanced_extension) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      advanced_extension = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, advanced_extension, submessage_arena);
    }
    
  } else {
    
  }
  advanced_extension_ = advanced_extension;
  // @@protoc_insertion_point(field_set_allocated:substrait.RelCommon.Hint.RuntimeConstraint.advanced_extension)
}

// -------------------------------------------------------------------

// RelCommon_Hint

// .substrait.RelCommon.Hint.Stats stats = 1;
inline bool RelCommon_Hint::has_stats() const {
  return this != internal_default_instance() && stats_ != NULL;
}
inline void RelCommon_Hint::clear_stats() {
  if (GetArenaNoVirtual() == NULL && stats_ != NULL) {
    delete stats_;
  }
  stats_ = NULL;
}
inline const ::substrait::RelCommon_Hint_Stats& RelCommon_Hint::_internal_stats() const {
  return *stats_;
}
inline const ::substrait::RelCommon_Hint_Stats& RelCommon_Hint::stats() const {
  const ::substrait::RelCommon_Hint_Stats* p = stats_;
  // @@protoc_insertion_point(field_get:substrait.RelCommon.Hint.stats)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::RelCommon_Hint_Stats*>(
      &::substrait::_RelCommon_Hint_Stats_default_instance_);
}
inline ::substrait::RelCommon_Hint_Stats* RelCommon_Hint::release_stats() {
  // @@protoc_insertion_point(field_release:substrait.RelCommon.Hint.stats)
  
  ::substrait::RelCommon_Hint_Stats* temp = stats_;
  stats_ = NULL;
  return temp;
}
inline ::substrait::RelCommon_Hint_Stats* RelCommon_Hint::mutable_stats() {
  
  if (stats_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::RelCommon_Hint_Stats>(GetArenaNoVirtual());
    stats_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.RelCommon.Hint.stats)
  return stats_;
}
inline void RelCommon_Hint::set_allocated_stats(::substrait::RelCommon_Hint_Stats* stats) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stats_;
  }
  if (stats) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      stats = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stats, submessage_arena);
    }
    
  } else {
    
  }
  stats_ = stats;
  // @@protoc_insertion_point(field_set_allocated:substrait.RelCommon.Hint.stats)
}

// .substrait.RelCommon.Hint.RuntimeConstraint constraint = 2;
inline bool RelCommon_Hint::has_constraint() const {
  return this != internal_default_instance() && constraint_ != NULL;
}
inline void RelCommon_Hint::clear_constraint() {
  if (GetArenaNoVirtual() == NULL && constraint_ != NULL) {
    delete constraint_;
  }
  constraint_ = NULL;
}
inline const ::substrait::RelCommon_Hint_RuntimeConstraint& RelCommon_Hint::_internal_constraint() const {
  return *constraint_;
}
inline const ::substrait::RelCommon_Hint_RuntimeConstraint& RelCommon_Hint::constraint() const {
  const ::substrait::RelCommon_Hint_RuntimeConstraint* p = constraint_;
  // @@protoc_insertion_point(field_get:substrait.RelCommon.Hint.constraint)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::RelCommon_Hint_RuntimeConstraint*>(
      &::substrait::_RelCommon_Hint_RuntimeConstraint_default_instance_);
}
inline ::substrait::RelCommon_Hint_RuntimeConstraint* RelCommon_Hint::release_constraint() {
  // @@protoc_insertion_point(field_release:substrait.RelCommon.Hint.constraint)
  
  ::substrait::RelCommon_Hint_RuntimeConstraint* temp = constraint_;
  constraint_ = NULL;
  return temp;
}
inline ::substrait::RelCommon_Hint_RuntimeConstraint* RelCommon_Hint::mutable_constraint() {
  
  if (constraint_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::RelCommon_Hint_RuntimeConstraint>(GetArenaNoVirtual());
    constraint_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.RelCommon.Hint.constraint)
  return constraint_;
}
inline void RelCommon_Hint::set_allocated_constraint(::substrait::RelCommon_Hint_RuntimeConstraint* constraint) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete constraint_;
  }
  if (constraint) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      constraint = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, constraint, submessage_arena);
    }
    
  } else {
    
  }
  constraint_ = constraint;
  // @@protoc_insertion_point(field_set_allocated:substrait.RelCommon.Hint.constraint)
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool RelCommon_Hint::has_advanced_extension() const {
  return this != internal_default_instance() && advanced_extension_ != NULL;
}
inline const ::substrait::extensions::AdvancedExtension& RelCommon_Hint::_internal_advanced_extension() const {
  return *advanced_extension_;
}
inline const ::substrait::extensions::AdvancedExtension& RelCommon_Hint::advanced_extension() const {
  const ::substrait::extensions::AdvancedExtension* p = advanced_extension_;
  // @@protoc_insertion_point(field_get:substrait.RelCommon.Hint.advanced_extension)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::extensions::AdvancedExtension*>(
      &::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline ::substrait::extensions::AdvancedExtension* RelCommon_Hint::release_advanced_extension() {
  // @@protoc_insertion_point(field_release:substrait.RelCommon.Hint.advanced_extension)
  
  ::substrait::extensions::AdvancedExtension* temp = advanced_extension_;
  advanced_extension_ = NULL;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* RelCommon_Hint::mutable_advanced_extension() {
  
  if (advanced_extension_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::extensions::AdvancedExtension>(GetArenaNoVirtual());
    advanced_extension_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.RelCommon.Hint.advanced_extension)
  return advanced_extension_;
}
inline void RelCommon_Hint::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(advanced_extension_);
  }
  if (advanced_extension) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      advanced_extension = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, advanced_extension, submessage_arena);
    }
    
  } else {
    
  }
  advanced_extension_ = advanced_extension;
  // @@protoc_insertion_point(field_set_allocated:substrait.RelCommon.Hint.advanced_extension)
}

// -------------------------------------------------------------------

// RelCommon

// .substrait.RelCommon.Direct direct = 1;
inline bool RelCommon::has_direct() const {
  return emit_kind_case() == kDirect;
}
inline void RelCommon::set_has_direct() {
  _oneof_case_[0] = kDirect;
}
inline void RelCommon::clear_direct() {
  if (has_direct()) {
    delete emit_kind_.direct_;
    clear_has_emit_kind();
  }
}
inline const ::substrait::RelCommon_Direct& RelCommon::_internal_direct() const {
  return *emit_kind_.direct_;
}
inline ::substrait::RelCommon_Direct* RelCommon::release_direct() {
  // @@protoc_insertion_point(field_release:substrait.RelCommon.direct)
  if (has_direct()) {
    clear_has_emit_kind();
      ::substrait::RelCommon_Direct* temp = emit_kind_.direct_;
    emit_kind_.direct_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::RelCommon_Direct& RelCommon::direct() const {
  // @@protoc_insertion_point(field_get:substrait.RelCommon.direct)
  return has_direct()
      ? *emit_kind_.direct_
      : *reinterpret_cast< ::substrait::RelCommon_Direct*>(&::substrait::_RelCommon_Direct_default_instance_);
}
inline ::substrait::RelCommon_Direct* RelCommon::mutable_direct() {
  if (!has_direct()) {
    clear_emit_kind();
    set_has_direct();
    emit_kind_.direct_ = CreateMaybeMessage< ::substrait::RelCommon_Direct >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.RelCommon.direct)
  return emit_kind_.direct_;
}

// .substrait.RelCommon.Emit emit = 2;
inline bool RelCommon::has_emit() const {
  return emit_kind_case() == kEmit;
}
inline void RelCommon::set_has_emit() {
  _oneof_case_[0] = kEmit;
}
inline void RelCommon::clear_emit() {
  if (has_emit()) {
    delete emit_kind_.emit_;
    clear_has_emit_kind();
  }
}
inline const ::substrait::RelCommon_Emit& RelCommon::_internal_emit() const {
  return *emit_kind_.emit_;
}
inline ::substrait::RelCommon_Emit* RelCommon::release_emit() {
  // @@protoc_insertion_point(field_release:substrait.RelCommon.emit)
  if (has_emit()) {
    clear_has_emit_kind();
      ::substrait::RelCommon_Emit* temp = emit_kind_.emit_;
    emit_kind_.emit_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::RelCommon_Emit& RelCommon::emit() const {
  // @@protoc_insertion_point(field_get:substrait.RelCommon.emit)
  return has_emit()
      ? *emit_kind_.emit_
      : *reinterpret_cast< ::substrait::RelCommon_Emit*>(&::substrait::_RelCommon_Emit_default_instance_);
}
inline ::substrait::RelCommon_Emit* RelCommon::mutable_emit() {
  if (!has_emit()) {
    clear_emit_kind();
    set_has_emit();
    emit_kind_.emit_ = CreateMaybeMessage< ::substrait::RelCommon_Emit >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.RelCommon.emit)
  return emit_kind_.emit_;
}

// .substrait.RelCommon.Hint hint = 3;
inline bool RelCommon::has_hint() const {
  return this != internal_default_instance() && hint_ != NULL;
}
inline void RelCommon::clear_hint() {
  if (GetArenaNoVirtual() == NULL && hint_ != NULL) {
    delete hint_;
  }
  hint_ = NULL;
}
inline const ::substrait::RelCommon_Hint& RelCommon::_internal_hint() const {
  return *hint_;
}
inline const ::substrait::RelCommon_Hint& RelCommon::hint() const {
  const ::substrait::RelCommon_Hint* p = hint_;
  // @@protoc_insertion_point(field_get:substrait.RelCommon.hint)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::RelCommon_Hint*>(
      &::substrait::_RelCommon_Hint_default_instance_);
}
inline ::substrait::RelCommon_Hint* RelCommon::release_hint() {
  // @@protoc_insertion_point(field_release:substrait.RelCommon.hint)
  
  ::substrait::RelCommon_Hint* temp = hint_;
  hint_ = NULL;
  return temp;
}
inline ::substrait::RelCommon_Hint* RelCommon::mutable_hint() {
  
  if (hint_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::RelCommon_Hint>(GetArenaNoVirtual());
    hint_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.RelCommon.hint)
  return hint_;
}
inline void RelCommon::set_allocated_hint(::substrait::RelCommon_Hint* hint) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete hint_;
  }
  if (hint) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      hint = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, hint, submessage_arena);
    }
    
  } else {
    
  }
  hint_ = hint;
  // @@protoc_insertion_point(field_set_allocated:substrait.RelCommon.hint)
}

// .substrait.extensions.AdvancedExtension advanced_extension = 4;
inline bool RelCommon::has_advanced_extension() const {
  return this != internal_default_instance() && advanced_extension_ != NULL;
}
inline const ::substrait::extensions::AdvancedExtension& RelCommon::_internal_advanced_extension() const {
  return *advanced_extension_;
}
inline const ::substrait::extensions::AdvancedExtension& RelCommon::advanced_extension() const {
  const ::substrait::extensions::AdvancedExtension* p = advanced_extension_;
  // @@protoc_insertion_point(field_get:substrait.RelCommon.advanced_extension)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::extensions::AdvancedExtension*>(
      &::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline ::substrait::extensions::AdvancedExtension* RelCommon::release_advanced_extension() {
  // @@protoc_insertion_point(field_release:substrait.RelCommon.advanced_extension)
  
  ::substrait::extensions::AdvancedExtension* temp = advanced_extension_;
  advanced_extension_ = NULL;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* RelCommon::mutable_advanced_extension() {
  
  if (advanced_extension_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::extensions::AdvancedExtension>(GetArenaNoVirtual());
    advanced_extension_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.RelCommon.advanced_extension)
  return advanced_extension_;
}
inline void RelCommon::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(advanced_extension_);
  }
  if (advanced_extension) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      advanced_extension = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, advanced_extension, submessage_arena);
    }
    
  } else {
    
  }
  advanced_extension_ = advanced_extension;
  // @@protoc_insertion_point(field_set_allocated:substrait.RelCommon.advanced_extension)
}

inline bool RelCommon::has_emit_kind() const {
  return emit_kind_case() != EMIT_KIND_NOT_SET;
}
inline void RelCommon::clear_has_emit_kind() {
  _oneof_case_[0] = EMIT_KIND_NOT_SET;
}
inline RelCommon::EmitKindCase RelCommon::emit_kind_case() const {
  return RelCommon::EmitKindCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ReadRel_NamedTable

// repeated string names = 1;
inline int ReadRel_NamedTable::names_size() const {
  return names_.size();
}
inline void ReadRel_NamedTable::clear_names() {
  names_.Clear();
}
inline const ::std::string& ReadRel_NamedTable::names(int index) const {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.NamedTable.names)
  return names_.Get(index);
}
inline ::std::string* ReadRel_NamedTable::mutable_names(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.NamedTable.names)
  return names_.Mutable(index);
}
inline void ReadRel_NamedTable::set_names(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:substrait.ReadRel.NamedTable.names)
  names_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ReadRel_NamedTable::set_names(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:substrait.ReadRel.NamedTable.names)
  names_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ReadRel_NamedTable::set_names(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:substrait.ReadRel.NamedTable.names)
}
inline void ReadRel_NamedTable::set_names(int index, const char* value, size_t size) {
  names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:substrait.ReadRel.NamedTable.names)
}
inline ::std::string* ReadRel_NamedTable::add_names() {
  // @@protoc_insertion_point(field_add_mutable:substrait.ReadRel.NamedTable.names)
  return names_.Add();
}
inline void ReadRel_NamedTable::add_names(const ::std::string& value) {
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:substrait.ReadRel.NamedTable.names)
}
#if LANG_CXX11
inline void ReadRel_NamedTable::add_names(::std::string&& value) {
  names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:substrait.ReadRel.NamedTable.names)
}
#endif
inline void ReadRel_NamedTable::add_names(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:substrait.ReadRel.NamedTable.names)
}
inline void ReadRel_NamedTable::add_names(const char* value, size_t size) {
  names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:substrait.ReadRel.NamedTable.names)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ReadRel_NamedTable::names() const {
  // @@protoc_insertion_point(field_list:substrait.ReadRel.NamedTable.names)
  return names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ReadRel_NamedTable::mutable_names() {
  // @@protoc_insertion_point(field_mutable_list:substrait.ReadRel.NamedTable.names)
  return &names_;
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool ReadRel_NamedTable::has_advanced_extension() const {
  return this != internal_default_instance() && advanced_extension_ != NULL;
}
inline const ::substrait::extensions::AdvancedExtension& ReadRel_NamedTable::_internal_advanced_extension() const {
  return *advanced_extension_;
}
inline const ::substrait::extensions::AdvancedExtension& ReadRel_NamedTable::advanced_extension() const {
  const ::substrait::extensions::AdvancedExtension* p = advanced_extension_;
  // @@protoc_insertion_point(field_get:substrait.ReadRel.NamedTable.advanced_extension)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::extensions::AdvancedExtension*>(
      &::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline ::substrait::extensions::AdvancedExtension* ReadRel_NamedTable::release_advanced_extension() {
  // @@protoc_insertion_point(field_release:substrait.ReadRel.NamedTable.advanced_extension)
  
  ::substrait::extensions::AdvancedExtension* temp = advanced_extension_;
  advanced_extension_ = NULL;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* ReadRel_NamedTable::mutable_advanced_extension() {
  
  if (advanced_extension_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::extensions::AdvancedExtension>(GetArenaNoVirtual());
    advanced_extension_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.NamedTable.advanced_extension)
  return advanced_extension_;
}
inline void ReadRel_NamedTable::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(advanced_extension_);
  }
  if (advanced_extension) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      advanced_extension = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, advanced_extension, submessage_arena);
    }
    
  } else {
    
  }
  advanced_extension_ = advanced_extension;
  // @@protoc_insertion_point(field_set_allocated:substrait.ReadRel.NamedTable.advanced_extension)
}

// -------------------------------------------------------------------

// ReadRel_VirtualTable

// repeated .substrait.Expression.Literal.Struct values = 1;
inline int ReadRel_VirtualTable::values_size() const {
  return values_.size();
}
inline void ReadRel_VirtualTable::clear_values() {
  values_.Clear();
}
inline ::substrait::Expression_Literal_Struct* ReadRel_VirtualTable::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.VirtualTable.values)
  return values_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::Expression_Literal_Struct >*
ReadRel_VirtualTable::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:substrait.ReadRel.VirtualTable.values)
  return &values_;
}
inline const ::substrait::Expression_Literal_Struct& ReadRel_VirtualTable::values(int index) const {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.VirtualTable.values)
  return values_.Get(index);
}
inline ::substrait::Expression_Literal_Struct* ReadRel_VirtualTable::add_values() {
  // @@protoc_insertion_point(field_add:substrait.ReadRel.VirtualTable.values)
  return values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::Expression_Literal_Struct >&
ReadRel_VirtualTable::values() const {
  // @@protoc_insertion_point(field_list:substrait.ReadRel.VirtualTable.values)
  return values_;
}

// -------------------------------------------------------------------

// ReadRel_ExtensionTable

// .google.protobuf.Any detail = 1;
inline bool ReadRel_ExtensionTable::has_detail() const {
  return this != internal_default_instance() && detail_ != NULL;
}
inline const ::google::protobuf::Any& ReadRel_ExtensionTable::_internal_detail() const {
  return *detail_;
}
inline const ::google::protobuf::Any& ReadRel_ExtensionTable::detail() const {
  const ::google::protobuf::Any* p = detail_;
  // @@protoc_insertion_point(field_get:substrait.ReadRel.ExtensionTable.detail)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Any*>(
      &::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* ReadRel_ExtensionTable::release_detail() {
  // @@protoc_insertion_point(field_release:substrait.ReadRel.ExtensionTable.detail)
  
  ::google::protobuf::Any* temp = detail_;
  detail_ = NULL;
  return temp;
}
inline ::google::protobuf::Any* ReadRel_ExtensionTable::mutable_detail() {
  
  if (detail_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArenaNoVirtual());
    detail_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.ExtensionTable.detail)
  return detail_;
}
inline void ReadRel_ExtensionTable::set_allocated_detail(::google::protobuf::Any* detail) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(detail_);
  }
  if (detail) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      detail = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, detail, submessage_arena);
    }
    
  } else {
    
  }
  detail_ = detail;
  // @@protoc_insertion_point(field_set_allocated:substrait.ReadRel.ExtensionTable.detail)
}

// -------------------------------------------------------------------

// ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions

// -------------------------------------------------------------------

// ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions

// -------------------------------------------------------------------

// ReadRel_LocalFiles_FileOrFiles_OrcReadOptions

// -------------------------------------------------------------------

// ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions

// -------------------------------------------------------------------

// ReadRel_LocalFiles_FileOrFiles

// string uri_path = 1;
inline bool ReadRel_LocalFiles_FileOrFiles::has_uri_path() const {
  return path_type_case() == kUriPath;
}
inline void ReadRel_LocalFiles_FileOrFiles::set_has_uri_path() {
  _oneof_case_[0] = kUriPath;
}
inline void ReadRel_LocalFiles_FileOrFiles::clear_uri_path() {
  if (has_uri_path()) {
    path_type_.uri_path_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_path_type();
  }
}
inline const ::std::string& ReadRel_LocalFiles_FileOrFiles::uri_path() const {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.LocalFiles.FileOrFiles.uri_path)
  if (has_uri_path()) {
    return path_type_.uri_path_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void ReadRel_LocalFiles_FileOrFiles::set_uri_path(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:substrait.ReadRel.LocalFiles.FileOrFiles.uri_path)
  if (!has_uri_path()) {
    clear_path_type();
    set_has_uri_path();
    path_type_.uri_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  path_type_.uri_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:substrait.ReadRel.LocalFiles.FileOrFiles.uri_path)
}
#if LANG_CXX11
inline void ReadRel_LocalFiles_FileOrFiles::set_uri_path(::std::string&& value) {
  // @@protoc_insertion_point(field_set:substrait.ReadRel.LocalFiles.FileOrFiles.uri_path)
  if (!has_uri_path()) {
    clear_path_type();
    set_has_uri_path();
    path_type_.uri_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  path_type_.uri_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:substrait.ReadRel.LocalFiles.FileOrFiles.uri_path)
}
#endif
inline void ReadRel_LocalFiles_FileOrFiles::set_uri_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_uri_path()) {
    clear_path_type();
    set_has_uri_path();
    path_type_.uri_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  path_type_.uri_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:substrait.ReadRel.LocalFiles.FileOrFiles.uri_path)
}
inline void ReadRel_LocalFiles_FileOrFiles::set_uri_path(const char* value, size_t size) {
  if (!has_uri_path()) {
    clear_path_type();
    set_has_uri_path();
    path_type_.uri_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  path_type_.uri_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:substrait.ReadRel.LocalFiles.FileOrFiles.uri_path)
}
inline ::std::string* ReadRel_LocalFiles_FileOrFiles::mutable_uri_path() {
  if (!has_uri_path()) {
    clear_path_type();
    set_has_uri_path();
    path_type_.uri_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.LocalFiles.FileOrFiles.uri_path)
  return path_type_.uri_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReadRel_LocalFiles_FileOrFiles::release_uri_path() {
  // @@protoc_insertion_point(field_release:substrait.ReadRel.LocalFiles.FileOrFiles.uri_path)
  if (has_uri_path()) {
    clear_has_path_type();
    return path_type_.uri_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void ReadRel_LocalFiles_FileOrFiles::set_allocated_uri_path(::std::string* uri_path) {
  if (!has_uri_path()) {
    path_type_.uri_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_path_type();
  if (uri_path != NULL) {
    set_has_uri_path();
    path_type_.uri_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uri_path);
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.ReadRel.LocalFiles.FileOrFiles.uri_path)
}

// string uri_path_glob = 2;
inline bool ReadRel_LocalFiles_FileOrFiles::has_uri_path_glob() const {
  return path_type_case() == kUriPathGlob;
}
inline void ReadRel_LocalFiles_FileOrFiles::set_has_uri_path_glob() {
  _oneof_case_[0] = kUriPathGlob;
}
inline void ReadRel_LocalFiles_FileOrFiles::clear_uri_path_glob() {
  if (has_uri_path_glob()) {
    path_type_.uri_path_glob_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_path_type();
  }
}
inline const ::std::string& ReadRel_LocalFiles_FileOrFiles::uri_path_glob() const {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.LocalFiles.FileOrFiles.uri_path_glob)
  if (has_uri_path_glob()) {
    return path_type_.uri_path_glob_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void ReadRel_LocalFiles_FileOrFiles::set_uri_path_glob(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:substrait.ReadRel.LocalFiles.FileOrFiles.uri_path_glob)
  if (!has_uri_path_glob()) {
    clear_path_type();
    set_has_uri_path_glob();
    path_type_.uri_path_glob_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  path_type_.uri_path_glob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:substrait.ReadRel.LocalFiles.FileOrFiles.uri_path_glob)
}
#if LANG_CXX11
inline void ReadRel_LocalFiles_FileOrFiles::set_uri_path_glob(::std::string&& value) {
  // @@protoc_insertion_point(field_set:substrait.ReadRel.LocalFiles.FileOrFiles.uri_path_glob)
  if (!has_uri_path_glob()) {
    clear_path_type();
    set_has_uri_path_glob();
    path_type_.uri_path_glob_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  path_type_.uri_path_glob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:substrait.ReadRel.LocalFiles.FileOrFiles.uri_path_glob)
}
#endif
inline void ReadRel_LocalFiles_FileOrFiles::set_uri_path_glob(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_uri_path_glob()) {
    clear_path_type();
    set_has_uri_path_glob();
    path_type_.uri_path_glob_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  path_type_.uri_path_glob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:substrait.ReadRel.LocalFiles.FileOrFiles.uri_path_glob)
}
inline void ReadRel_LocalFiles_FileOrFiles::set_uri_path_glob(const char* value, size_t size) {
  if (!has_uri_path_glob()) {
    clear_path_type();
    set_has_uri_path_glob();
    path_type_.uri_path_glob_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  path_type_.uri_path_glob_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:substrait.ReadRel.LocalFiles.FileOrFiles.uri_path_glob)
}
inline ::std::string* ReadRel_LocalFiles_FileOrFiles::mutable_uri_path_glob() {
  if (!has_uri_path_glob()) {
    clear_path_type();
    set_has_uri_path_glob();
    path_type_.uri_path_glob_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.LocalFiles.FileOrFiles.uri_path_glob)
  return path_type_.uri_path_glob_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReadRel_LocalFiles_FileOrFiles::release_uri_path_glob() {
  // @@protoc_insertion_point(field_release:substrait.ReadRel.LocalFiles.FileOrFiles.uri_path_glob)
  if (has_uri_path_glob()) {
    clear_has_path_type();
    return path_type_.uri_path_glob_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void ReadRel_LocalFiles_FileOrFiles::set_allocated_uri_path_glob(::std::string* uri_path_glob) {
  if (!has_uri_path_glob()) {
    path_type_.uri_path_glob_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_path_type();
  if (uri_path_glob != NULL) {
    set_has_uri_path_glob();
    path_type_.uri_path_glob_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uri_path_glob);
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.ReadRel.LocalFiles.FileOrFiles.uri_path_glob)
}

// string uri_file = 3;
inline bool ReadRel_LocalFiles_FileOrFiles::has_uri_file() const {
  return path_type_case() == kUriFile;
}
inline void ReadRel_LocalFiles_FileOrFiles::set_has_uri_file() {
  _oneof_case_[0] = kUriFile;
}
inline void ReadRel_LocalFiles_FileOrFiles::clear_uri_file() {
  if (has_uri_file()) {
    path_type_.uri_file_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_path_type();
  }
}
inline const ::std::string& ReadRel_LocalFiles_FileOrFiles::uri_file() const {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.LocalFiles.FileOrFiles.uri_file)
  if (has_uri_file()) {
    return path_type_.uri_file_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void ReadRel_LocalFiles_FileOrFiles::set_uri_file(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:substrait.ReadRel.LocalFiles.FileOrFiles.uri_file)
  if (!has_uri_file()) {
    clear_path_type();
    set_has_uri_file();
    path_type_.uri_file_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  path_type_.uri_file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:substrait.ReadRel.LocalFiles.FileOrFiles.uri_file)
}
#if LANG_CXX11
inline void ReadRel_LocalFiles_FileOrFiles::set_uri_file(::std::string&& value) {
  // @@protoc_insertion_point(field_set:substrait.ReadRel.LocalFiles.FileOrFiles.uri_file)
  if (!has_uri_file()) {
    clear_path_type();
    set_has_uri_file();
    path_type_.uri_file_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  path_type_.uri_file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:substrait.ReadRel.LocalFiles.FileOrFiles.uri_file)
}
#endif
inline void ReadRel_LocalFiles_FileOrFiles::set_uri_file(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_uri_file()) {
    clear_path_type();
    set_has_uri_file();
    path_type_.uri_file_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  path_type_.uri_file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:substrait.ReadRel.LocalFiles.FileOrFiles.uri_file)
}
inline void ReadRel_LocalFiles_FileOrFiles::set_uri_file(const char* value, size_t size) {
  if (!has_uri_file()) {
    clear_path_type();
    set_has_uri_file();
    path_type_.uri_file_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  path_type_.uri_file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:substrait.ReadRel.LocalFiles.FileOrFiles.uri_file)
}
inline ::std::string* ReadRel_LocalFiles_FileOrFiles::mutable_uri_file() {
  if (!has_uri_file()) {
    clear_path_type();
    set_has_uri_file();
    path_type_.uri_file_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.LocalFiles.FileOrFiles.uri_file)
  return path_type_.uri_file_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReadRel_LocalFiles_FileOrFiles::release_uri_file() {
  // @@protoc_insertion_point(field_release:substrait.ReadRel.LocalFiles.FileOrFiles.uri_file)
  if (has_uri_file()) {
    clear_has_path_type();
    return path_type_.uri_file_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void ReadRel_LocalFiles_FileOrFiles::set_allocated_uri_file(::std::string* uri_file) {
  if (!has_uri_file()) {
    path_type_.uri_file_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_path_type();
  if (uri_file != NULL) {
    set_has_uri_file();
    path_type_.uri_file_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uri_file);
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.ReadRel.LocalFiles.FileOrFiles.uri_file)
}

// string uri_folder = 4;
inline bool ReadRel_LocalFiles_FileOrFiles::has_uri_folder() const {
  return path_type_case() == kUriFolder;
}
inline void ReadRel_LocalFiles_FileOrFiles::set_has_uri_folder() {
  _oneof_case_[0] = kUriFolder;
}
inline void ReadRel_LocalFiles_FileOrFiles::clear_uri_folder() {
  if (has_uri_folder()) {
    path_type_.uri_folder_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_path_type();
  }
}
inline const ::std::string& ReadRel_LocalFiles_FileOrFiles::uri_folder() const {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.LocalFiles.FileOrFiles.uri_folder)
  if (has_uri_folder()) {
    return path_type_.uri_folder_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void ReadRel_LocalFiles_FileOrFiles::set_uri_folder(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:substrait.ReadRel.LocalFiles.FileOrFiles.uri_folder)
  if (!has_uri_folder()) {
    clear_path_type();
    set_has_uri_folder();
    path_type_.uri_folder_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  path_type_.uri_folder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:substrait.ReadRel.LocalFiles.FileOrFiles.uri_folder)
}
#if LANG_CXX11
inline void ReadRel_LocalFiles_FileOrFiles::set_uri_folder(::std::string&& value) {
  // @@protoc_insertion_point(field_set:substrait.ReadRel.LocalFiles.FileOrFiles.uri_folder)
  if (!has_uri_folder()) {
    clear_path_type();
    set_has_uri_folder();
    path_type_.uri_folder_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  path_type_.uri_folder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:substrait.ReadRel.LocalFiles.FileOrFiles.uri_folder)
}
#endif
inline void ReadRel_LocalFiles_FileOrFiles::set_uri_folder(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_uri_folder()) {
    clear_path_type();
    set_has_uri_folder();
    path_type_.uri_folder_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  path_type_.uri_folder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:substrait.ReadRel.LocalFiles.FileOrFiles.uri_folder)
}
inline void ReadRel_LocalFiles_FileOrFiles::set_uri_folder(const char* value, size_t size) {
  if (!has_uri_folder()) {
    clear_path_type();
    set_has_uri_folder();
    path_type_.uri_folder_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  path_type_.uri_folder_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:substrait.ReadRel.LocalFiles.FileOrFiles.uri_folder)
}
inline ::std::string* ReadRel_LocalFiles_FileOrFiles::mutable_uri_folder() {
  if (!has_uri_folder()) {
    clear_path_type();
    set_has_uri_folder();
    path_type_.uri_folder_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.LocalFiles.FileOrFiles.uri_folder)
  return path_type_.uri_folder_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReadRel_LocalFiles_FileOrFiles::release_uri_folder() {
  // @@protoc_insertion_point(field_release:substrait.ReadRel.LocalFiles.FileOrFiles.uri_folder)
  if (has_uri_folder()) {
    clear_has_path_type();
    return path_type_.uri_folder_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void ReadRel_LocalFiles_FileOrFiles::set_allocated_uri_folder(::std::string* uri_folder) {
  if (!has_uri_folder()) {
    path_type_.uri_folder_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_path_type();
  if (uri_folder != NULL) {
    set_has_uri_folder();
    path_type_.uri_folder_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uri_folder);
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.ReadRel.LocalFiles.FileOrFiles.uri_folder)
}

// uint64 partition_index = 6;
inline void ReadRel_LocalFiles_FileOrFiles::clear_partition_index() {
  partition_index_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ReadRel_LocalFiles_FileOrFiles::partition_index() const {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.LocalFiles.FileOrFiles.partition_index)
  return partition_index_;
}
inline void ReadRel_LocalFiles_FileOrFiles::set_partition_index(::google::protobuf::uint64 value) {
  
  partition_index_ = value;
  // @@protoc_insertion_point(field_set:substrait.ReadRel.LocalFiles.FileOrFiles.partition_index)
}

// uint64 start = 7;
inline void ReadRel_LocalFiles_FileOrFiles::clear_start() {
  start_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ReadRel_LocalFiles_FileOrFiles::start() const {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.LocalFiles.FileOrFiles.start)
  return start_;
}
inline void ReadRel_LocalFiles_FileOrFiles::set_start(::google::protobuf::uint64 value) {
  
  start_ = value;
  // @@protoc_insertion_point(field_set:substrait.ReadRel.LocalFiles.FileOrFiles.start)
}

// uint64 length = 8;
inline void ReadRel_LocalFiles_FileOrFiles::clear_length() {
  length_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ReadRel_LocalFiles_FileOrFiles::length() const {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.LocalFiles.FileOrFiles.length)
  return length_;
}
inline void ReadRel_LocalFiles_FileOrFiles::set_length(::google::protobuf::uint64 value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:substrait.ReadRel.LocalFiles.FileOrFiles.length)
}

// .substrait.ReadRel.LocalFiles.FileOrFiles.ParquetReadOptions parquet = 9;
inline bool ReadRel_LocalFiles_FileOrFiles::has_parquet() const {
  return file_format_case() == kParquet;
}
inline void ReadRel_LocalFiles_FileOrFiles::set_has_parquet() {
  _oneof_case_[1] = kParquet;
}
inline void ReadRel_LocalFiles_FileOrFiles::clear_parquet() {
  if (has_parquet()) {
    delete file_format_.parquet_;
    clear_has_file_format();
  }
}
inline const ::substrait::ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions& ReadRel_LocalFiles_FileOrFiles::_internal_parquet() const {
  return *file_format_.parquet_;
}
inline ::substrait::ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions* ReadRel_LocalFiles_FileOrFiles::release_parquet() {
  // @@protoc_insertion_point(field_release:substrait.ReadRel.LocalFiles.FileOrFiles.parquet)
  if (has_parquet()) {
    clear_has_file_format();
      ::substrait::ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions* temp = file_format_.parquet_;
    file_format_.parquet_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions& ReadRel_LocalFiles_FileOrFiles::parquet() const {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.LocalFiles.FileOrFiles.parquet)
  return has_parquet()
      ? *file_format_.parquet_
      : *reinterpret_cast< ::substrait::ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions*>(&::substrait::_ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions_default_instance_);
}
inline ::substrait::ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions* ReadRel_LocalFiles_FileOrFiles::mutable_parquet() {
  if (!has_parquet()) {
    clear_file_format();
    set_has_parquet();
    file_format_.parquet_ = CreateMaybeMessage< ::substrait::ReadRel_LocalFiles_FileOrFiles_ParquetReadOptions >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.LocalFiles.FileOrFiles.parquet)
  return file_format_.parquet_;
}

// .substrait.ReadRel.LocalFiles.FileOrFiles.ArrowReadOptions arrow = 10;
inline bool ReadRel_LocalFiles_FileOrFiles::has_arrow() const {
  return file_format_case() == kArrow;
}
inline void ReadRel_LocalFiles_FileOrFiles::set_has_arrow() {
  _oneof_case_[1] = kArrow;
}
inline void ReadRel_LocalFiles_FileOrFiles::clear_arrow() {
  if (has_arrow()) {
    delete file_format_.arrow_;
    clear_has_file_format();
  }
}
inline const ::substrait::ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions& ReadRel_LocalFiles_FileOrFiles::_internal_arrow() const {
  return *file_format_.arrow_;
}
inline ::substrait::ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions* ReadRel_LocalFiles_FileOrFiles::release_arrow() {
  // @@protoc_insertion_point(field_release:substrait.ReadRel.LocalFiles.FileOrFiles.arrow)
  if (has_arrow()) {
    clear_has_file_format();
      ::substrait::ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions* temp = file_format_.arrow_;
    file_format_.arrow_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions& ReadRel_LocalFiles_FileOrFiles::arrow() const {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.LocalFiles.FileOrFiles.arrow)
  return has_arrow()
      ? *file_format_.arrow_
      : *reinterpret_cast< ::substrait::ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions*>(&::substrait::_ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions_default_instance_);
}
inline ::substrait::ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions* ReadRel_LocalFiles_FileOrFiles::mutable_arrow() {
  if (!has_arrow()) {
    clear_file_format();
    set_has_arrow();
    file_format_.arrow_ = CreateMaybeMessage< ::substrait::ReadRel_LocalFiles_FileOrFiles_ArrowReadOptions >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.LocalFiles.FileOrFiles.arrow)
  return file_format_.arrow_;
}

// .substrait.ReadRel.LocalFiles.FileOrFiles.OrcReadOptions orc = 11;
inline bool ReadRel_LocalFiles_FileOrFiles::has_orc() const {
  return file_format_case() == kOrc;
}
inline void ReadRel_LocalFiles_FileOrFiles::set_has_orc() {
  _oneof_case_[1] = kOrc;
}
inline void ReadRel_LocalFiles_FileOrFiles::clear_orc() {
  if (has_orc()) {
    delete file_format_.orc_;
    clear_has_file_format();
  }
}
inline const ::substrait::ReadRel_LocalFiles_FileOrFiles_OrcReadOptions& ReadRel_LocalFiles_FileOrFiles::_internal_orc() const {
  return *file_format_.orc_;
}
inline ::substrait::ReadRel_LocalFiles_FileOrFiles_OrcReadOptions* ReadRel_LocalFiles_FileOrFiles::release_orc() {
  // @@protoc_insertion_point(field_release:substrait.ReadRel.LocalFiles.FileOrFiles.orc)
  if (has_orc()) {
    clear_has_file_format();
      ::substrait::ReadRel_LocalFiles_FileOrFiles_OrcReadOptions* temp = file_format_.orc_;
    file_format_.orc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::ReadRel_LocalFiles_FileOrFiles_OrcReadOptions& ReadRel_LocalFiles_FileOrFiles::orc() const {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.LocalFiles.FileOrFiles.orc)
  return has_orc()
      ? *file_format_.orc_
      : *reinterpret_cast< ::substrait::ReadRel_LocalFiles_FileOrFiles_OrcReadOptions*>(&::substrait::_ReadRel_LocalFiles_FileOrFiles_OrcReadOptions_default_instance_);
}
inline ::substrait::ReadRel_LocalFiles_FileOrFiles_OrcReadOptions* ReadRel_LocalFiles_FileOrFiles::mutable_orc() {
  if (!has_orc()) {
    clear_file_format();
    set_has_orc();
    file_format_.orc_ = CreateMaybeMessage< ::substrait::ReadRel_LocalFiles_FileOrFiles_OrcReadOptions >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.LocalFiles.FileOrFiles.orc)
  return file_format_.orc_;
}

// .google.protobuf.Any extension = 12;
inline bool ReadRel_LocalFiles_FileOrFiles::has_extension() const {
  return file_format_case() == kExtension;
}
inline void ReadRel_LocalFiles_FileOrFiles::set_has_extension() {
  _oneof_case_[1] = kExtension;
}
inline const ::google::protobuf::Any& ReadRel_LocalFiles_FileOrFiles::_internal_extension() const {
  return *file_format_.extension_;
}
inline ::google::protobuf::Any* ReadRel_LocalFiles_FileOrFiles::release_extension() {
  // @@protoc_insertion_point(field_release:substrait.ReadRel.LocalFiles.FileOrFiles.extension)
  if (has_extension()) {
    clear_has_file_format();
      ::google::protobuf::Any* temp = file_format_.extension_;
    file_format_.extension_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::google::protobuf::Any& ReadRel_LocalFiles_FileOrFiles::extension() const {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.LocalFiles.FileOrFiles.extension)
  return has_extension()
      ? *file_format_.extension_
      : *reinterpret_cast< ::google::protobuf::Any*>(&::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* ReadRel_LocalFiles_FileOrFiles::mutable_extension() {
  if (!has_extension()) {
    clear_file_format();
    set_has_extension();
    file_format_.extension_ = CreateMaybeMessage< ::google::protobuf::Any >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.LocalFiles.FileOrFiles.extension)
  return file_format_.extension_;
}

// .substrait.ReadRel.LocalFiles.FileOrFiles.DwrfReadOptions dwrf = 13;
inline bool ReadRel_LocalFiles_FileOrFiles::has_dwrf() const {
  return file_format_case() == kDwrf;
}
inline void ReadRel_LocalFiles_FileOrFiles::set_has_dwrf() {
  _oneof_case_[1] = kDwrf;
}
inline void ReadRel_LocalFiles_FileOrFiles::clear_dwrf() {
  if (has_dwrf()) {
    delete file_format_.dwrf_;
    clear_has_file_format();
  }
}
inline const ::substrait::ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions& ReadRel_LocalFiles_FileOrFiles::_internal_dwrf() const {
  return *file_format_.dwrf_;
}
inline ::substrait::ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions* ReadRel_LocalFiles_FileOrFiles::release_dwrf() {
  // @@protoc_insertion_point(field_release:substrait.ReadRel.LocalFiles.FileOrFiles.dwrf)
  if (has_dwrf()) {
    clear_has_file_format();
      ::substrait::ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions* temp = file_format_.dwrf_;
    file_format_.dwrf_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions& ReadRel_LocalFiles_FileOrFiles::dwrf() const {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.LocalFiles.FileOrFiles.dwrf)
  return has_dwrf()
      ? *file_format_.dwrf_
      : *reinterpret_cast< ::substrait::ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions*>(&::substrait::_ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions_default_instance_);
}
inline ::substrait::ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions* ReadRel_LocalFiles_FileOrFiles::mutable_dwrf() {
  if (!has_dwrf()) {
    clear_file_format();
    set_has_dwrf();
    file_format_.dwrf_ = CreateMaybeMessage< ::substrait::ReadRel_LocalFiles_FileOrFiles_DwrfReadOptions >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.LocalFiles.FileOrFiles.dwrf)
  return file_format_.dwrf_;
}

inline bool ReadRel_LocalFiles_FileOrFiles::has_path_type() const {
  return path_type_case() != PATH_TYPE_NOT_SET;
}
inline void ReadRel_LocalFiles_FileOrFiles::clear_has_path_type() {
  _oneof_case_[0] = PATH_TYPE_NOT_SET;
}
inline bool ReadRel_LocalFiles_FileOrFiles::has_file_format() const {
  return file_format_case() != FILE_FORMAT_NOT_SET;
}
inline void ReadRel_LocalFiles_FileOrFiles::clear_has_file_format() {
  _oneof_case_[1] = FILE_FORMAT_NOT_SET;
}
inline ReadRel_LocalFiles_FileOrFiles::PathTypeCase ReadRel_LocalFiles_FileOrFiles::path_type_case() const {
  return ReadRel_LocalFiles_FileOrFiles::PathTypeCase(_oneof_case_[0]);
}
inline ReadRel_LocalFiles_FileOrFiles::FileFormatCase ReadRel_LocalFiles_FileOrFiles::file_format_case() const {
  return ReadRel_LocalFiles_FileOrFiles::FileFormatCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// ReadRel_LocalFiles

// repeated .substrait.ReadRel.LocalFiles.FileOrFiles items = 1;
inline int ReadRel_LocalFiles::items_size() const {
  return items_.size();
}
inline void ReadRel_LocalFiles::clear_items() {
  items_.Clear();
}
inline ::substrait::ReadRel_LocalFiles_FileOrFiles* ReadRel_LocalFiles::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.LocalFiles.items)
  return items_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::ReadRel_LocalFiles_FileOrFiles >*
ReadRel_LocalFiles::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:substrait.ReadRel.LocalFiles.items)
  return &items_;
}
inline const ::substrait::ReadRel_LocalFiles_FileOrFiles& ReadRel_LocalFiles::items(int index) const {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.LocalFiles.items)
  return items_.Get(index);
}
inline ::substrait::ReadRel_LocalFiles_FileOrFiles* ReadRel_LocalFiles::add_items() {
  // @@protoc_insertion_point(field_add:substrait.ReadRel.LocalFiles.items)
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::ReadRel_LocalFiles_FileOrFiles >&
ReadRel_LocalFiles::items() const {
  // @@protoc_insertion_point(field_list:substrait.ReadRel.LocalFiles.items)
  return items_;
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool ReadRel_LocalFiles::has_advanced_extension() const {
  return this != internal_default_instance() && advanced_extension_ != NULL;
}
inline const ::substrait::extensions::AdvancedExtension& ReadRel_LocalFiles::_internal_advanced_extension() const {
  return *advanced_extension_;
}
inline const ::substrait::extensions::AdvancedExtension& ReadRel_LocalFiles::advanced_extension() const {
  const ::substrait::extensions::AdvancedExtension* p = advanced_extension_;
  // @@protoc_insertion_point(field_get:substrait.ReadRel.LocalFiles.advanced_extension)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::extensions::AdvancedExtension*>(
      &::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline ::substrait::extensions::AdvancedExtension* ReadRel_LocalFiles::release_advanced_extension() {
  // @@protoc_insertion_point(field_release:substrait.ReadRel.LocalFiles.advanced_extension)
  
  ::substrait::extensions::AdvancedExtension* temp = advanced_extension_;
  advanced_extension_ = NULL;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* ReadRel_LocalFiles::mutable_advanced_extension() {
  
  if (advanced_extension_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::extensions::AdvancedExtension>(GetArenaNoVirtual());
    advanced_extension_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.LocalFiles.advanced_extension)
  return advanced_extension_;
}
inline void ReadRel_LocalFiles::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(advanced_extension_);
  }
  if (advanced_extension) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      advanced_extension = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, advanced_extension, submessage_arena);
    }
    
  } else {
    
  }
  advanced_extension_ = advanced_extension;
  // @@protoc_insertion_point(field_set_allocated:substrait.ReadRel.LocalFiles.advanced_extension)
}

// -------------------------------------------------------------------

// ReadRel

// .substrait.RelCommon common = 1;
inline bool ReadRel::has_common() const {
  return this != internal_default_instance() && common_ != NULL;
}
inline void ReadRel::clear_common() {
  if (GetArenaNoVirtual() == NULL && common_ != NULL) {
    delete common_;
  }
  common_ = NULL;
}
inline const ::substrait::RelCommon& ReadRel::_internal_common() const {
  return *common_;
}
inline const ::substrait::RelCommon& ReadRel::common() const {
  const ::substrait::RelCommon* p = common_;
  // @@protoc_insertion_point(field_get:substrait.ReadRel.common)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::RelCommon*>(
      &::substrait::_RelCommon_default_instance_);
}
inline ::substrait::RelCommon* ReadRel::release_common() {
  // @@protoc_insertion_point(field_release:substrait.ReadRel.common)
  
  ::substrait::RelCommon* temp = common_;
  common_ = NULL;
  return temp;
}
inline ::substrait::RelCommon* ReadRel::mutable_common() {
  
  if (common_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::RelCommon>(GetArenaNoVirtual());
    common_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.common)
  return common_;
}
inline void ReadRel::set_allocated_common(::substrait::RelCommon* common) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete common_;
  }
  if (common) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      common = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, common, submessage_arena);
    }
    
  } else {
    
  }
  common_ = common;
  // @@protoc_insertion_point(field_set_allocated:substrait.ReadRel.common)
}

// .substrait.NamedStruct base_schema = 2;
inline bool ReadRel::has_base_schema() const {
  return this != internal_default_instance() && base_schema_ != NULL;
}
inline const ::substrait::NamedStruct& ReadRel::_internal_base_schema() const {
  return *base_schema_;
}
inline const ::substrait::NamedStruct& ReadRel::base_schema() const {
  const ::substrait::NamedStruct* p = base_schema_;
  // @@protoc_insertion_point(field_get:substrait.ReadRel.base_schema)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::NamedStruct*>(
      &::substrait::_NamedStruct_default_instance_);
}
inline ::substrait::NamedStruct* ReadRel::release_base_schema() {
  // @@protoc_insertion_point(field_release:substrait.ReadRel.base_schema)
  
  ::substrait::NamedStruct* temp = base_schema_;
  base_schema_ = NULL;
  return temp;
}
inline ::substrait::NamedStruct* ReadRel::mutable_base_schema() {
  
  if (base_schema_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::NamedStruct>(GetArenaNoVirtual());
    base_schema_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.base_schema)
  return base_schema_;
}
inline void ReadRel::set_allocated_base_schema(::substrait::NamedStruct* base_schema) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(base_schema_);
  }
  if (base_schema) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      base_schema = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, base_schema, submessage_arena);
    }
    
  } else {
    
  }
  base_schema_ = base_schema;
  // @@protoc_insertion_point(field_set_allocated:substrait.ReadRel.base_schema)
}

// .substrait.Expression filter = 3;
inline bool ReadRel::has_filter() const {
  return this != internal_default_instance() && filter_ != NULL;
}
inline void ReadRel::clear_filter() {
  if (GetArenaNoVirtual() == NULL && filter_ != NULL) {
    delete filter_;
  }
  filter_ = NULL;
}
inline const ::substrait::Expression& ReadRel::_internal_filter() const {
  return *filter_;
}
inline const ::substrait::Expression& ReadRel::filter() const {
  const ::substrait::Expression* p = filter_;
  // @@protoc_insertion_point(field_get:substrait.ReadRel.filter)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression*>(
      &::substrait::_Expression_default_instance_);
}
inline ::substrait::Expression* ReadRel::release_filter() {
  // @@protoc_insertion_point(field_release:substrait.ReadRel.filter)
  
  ::substrait::Expression* temp = filter_;
  filter_ = NULL;
  return temp;
}
inline ::substrait::Expression* ReadRel::mutable_filter() {
  
  if (filter_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression>(GetArenaNoVirtual());
    filter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.filter)
  return filter_;
}
inline void ReadRel::set_allocated_filter(::substrait::Expression* filter) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete filter_;
  }
  if (filter) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      filter = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    
  } else {
    
  }
  filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:substrait.ReadRel.filter)
}

// .substrait.Expression best_effort_filter = 11;
inline bool ReadRel::has_best_effort_filter() const {
  return this != internal_default_instance() && best_effort_filter_ != NULL;
}
inline void ReadRel::clear_best_effort_filter() {
  if (GetArenaNoVirtual() == NULL && best_effort_filter_ != NULL) {
    delete best_effort_filter_;
  }
  best_effort_filter_ = NULL;
}
inline const ::substrait::Expression& ReadRel::_internal_best_effort_filter() const {
  return *best_effort_filter_;
}
inline const ::substrait::Expression& ReadRel::best_effort_filter() const {
  const ::substrait::Expression* p = best_effort_filter_;
  // @@protoc_insertion_point(field_get:substrait.ReadRel.best_effort_filter)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression*>(
      &::substrait::_Expression_default_instance_);
}
inline ::substrait::Expression* ReadRel::release_best_effort_filter() {
  // @@protoc_insertion_point(field_release:substrait.ReadRel.best_effort_filter)
  
  ::substrait::Expression* temp = best_effort_filter_;
  best_effort_filter_ = NULL;
  return temp;
}
inline ::substrait::Expression* ReadRel::mutable_best_effort_filter() {
  
  if (best_effort_filter_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression>(GetArenaNoVirtual());
    best_effort_filter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.best_effort_filter)
  return best_effort_filter_;
}
inline void ReadRel::set_allocated_best_effort_filter(::substrait::Expression* best_effort_filter) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete best_effort_filter_;
  }
  if (best_effort_filter) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      best_effort_filter = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, best_effort_filter, submessage_arena);
    }
    
  } else {
    
  }
  best_effort_filter_ = best_effort_filter;
  // @@protoc_insertion_point(field_set_allocated:substrait.ReadRel.best_effort_filter)
}

// .substrait.Expression.MaskExpression projection = 4;
inline bool ReadRel::has_projection() const {
  return this != internal_default_instance() && projection_ != NULL;
}
inline void ReadRel::clear_projection() {
  if (GetArenaNoVirtual() == NULL && projection_ != NULL) {
    delete projection_;
  }
  projection_ = NULL;
}
inline const ::substrait::Expression_MaskExpression& ReadRel::_internal_projection() const {
  return *projection_;
}
inline const ::substrait::Expression_MaskExpression& ReadRel::projection() const {
  const ::substrait::Expression_MaskExpression* p = projection_;
  // @@protoc_insertion_point(field_get:substrait.ReadRel.projection)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression_MaskExpression*>(
      &::substrait::_Expression_MaskExpression_default_instance_);
}
inline ::substrait::Expression_MaskExpression* ReadRel::release_projection() {
  // @@protoc_insertion_point(field_release:substrait.ReadRel.projection)
  
  ::substrait::Expression_MaskExpression* temp = projection_;
  projection_ = NULL;
  return temp;
}
inline ::substrait::Expression_MaskExpression* ReadRel::mutable_projection() {
  
  if (projection_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression_MaskExpression>(GetArenaNoVirtual());
    projection_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.projection)
  return projection_;
}
inline void ReadRel::set_allocated_projection(::substrait::Expression_MaskExpression* projection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete projection_;
  }
  if (projection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      projection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, projection, submessage_arena);
    }
    
  } else {
    
  }
  projection_ = projection;
  // @@protoc_insertion_point(field_set_allocated:substrait.ReadRel.projection)
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool ReadRel::has_advanced_extension() const {
  return this != internal_default_instance() && advanced_extension_ != NULL;
}
inline const ::substrait::extensions::AdvancedExtension& ReadRel::_internal_advanced_extension() const {
  return *advanced_extension_;
}
inline const ::substrait::extensions::AdvancedExtension& ReadRel::advanced_extension() const {
  const ::substrait::extensions::AdvancedExtension* p = advanced_extension_;
  // @@protoc_insertion_point(field_get:substrait.ReadRel.advanced_extension)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::extensions::AdvancedExtension*>(
      &::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline ::substrait::extensions::AdvancedExtension* ReadRel::release_advanced_extension() {
  // @@protoc_insertion_point(field_release:substrait.ReadRel.advanced_extension)
  
  ::substrait::extensions::AdvancedExtension* temp = advanced_extension_;
  advanced_extension_ = NULL;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* ReadRel::mutable_advanced_extension() {
  
  if (advanced_extension_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::extensions::AdvancedExtension>(GetArenaNoVirtual());
    advanced_extension_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.advanced_extension)
  return advanced_extension_;
}
inline void ReadRel::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(advanced_extension_);
  }
  if (advanced_extension) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      advanced_extension = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, advanced_extension, submessage_arena);
    }
    
  } else {
    
  }
  advanced_extension_ = advanced_extension;
  // @@protoc_insertion_point(field_set_allocated:substrait.ReadRel.advanced_extension)
}

// .substrait.ReadRel.VirtualTable virtual_table = 5;
inline bool ReadRel::has_virtual_table() const {
  return read_type_case() == kVirtualTable;
}
inline void ReadRel::set_has_virtual_table() {
  _oneof_case_[0] = kVirtualTable;
}
inline void ReadRel::clear_virtual_table() {
  if (has_virtual_table()) {
    delete read_type_.virtual_table_;
    clear_has_read_type();
  }
}
inline const ::substrait::ReadRel_VirtualTable& ReadRel::_internal_virtual_table() const {
  return *read_type_.virtual_table_;
}
inline ::substrait::ReadRel_VirtualTable* ReadRel::release_virtual_table() {
  // @@protoc_insertion_point(field_release:substrait.ReadRel.virtual_table)
  if (has_virtual_table()) {
    clear_has_read_type();
      ::substrait::ReadRel_VirtualTable* temp = read_type_.virtual_table_;
    read_type_.virtual_table_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::ReadRel_VirtualTable& ReadRel::virtual_table() const {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.virtual_table)
  return has_virtual_table()
      ? *read_type_.virtual_table_
      : *reinterpret_cast< ::substrait::ReadRel_VirtualTable*>(&::substrait::_ReadRel_VirtualTable_default_instance_);
}
inline ::substrait::ReadRel_VirtualTable* ReadRel::mutable_virtual_table() {
  if (!has_virtual_table()) {
    clear_read_type();
    set_has_virtual_table();
    read_type_.virtual_table_ = CreateMaybeMessage< ::substrait::ReadRel_VirtualTable >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.virtual_table)
  return read_type_.virtual_table_;
}

// .substrait.ReadRel.LocalFiles local_files = 6;
inline bool ReadRel::has_local_files() const {
  return read_type_case() == kLocalFiles;
}
inline void ReadRel::set_has_local_files() {
  _oneof_case_[0] = kLocalFiles;
}
inline void ReadRel::clear_local_files() {
  if (has_local_files()) {
    delete read_type_.local_files_;
    clear_has_read_type();
  }
}
inline const ::substrait::ReadRel_LocalFiles& ReadRel::_internal_local_files() const {
  return *read_type_.local_files_;
}
inline ::substrait::ReadRel_LocalFiles* ReadRel::release_local_files() {
  // @@protoc_insertion_point(field_release:substrait.ReadRel.local_files)
  if (has_local_files()) {
    clear_has_read_type();
      ::substrait::ReadRel_LocalFiles* temp = read_type_.local_files_;
    read_type_.local_files_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::ReadRel_LocalFiles& ReadRel::local_files() const {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.local_files)
  return has_local_files()
      ? *read_type_.local_files_
      : *reinterpret_cast< ::substrait::ReadRel_LocalFiles*>(&::substrait::_ReadRel_LocalFiles_default_instance_);
}
inline ::substrait::ReadRel_LocalFiles* ReadRel::mutable_local_files() {
  if (!has_local_files()) {
    clear_read_type();
    set_has_local_files();
    read_type_.local_files_ = CreateMaybeMessage< ::substrait::ReadRel_LocalFiles >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.local_files)
  return read_type_.local_files_;
}

// .substrait.ReadRel.NamedTable named_table = 7;
inline bool ReadRel::has_named_table() const {
  return read_type_case() == kNamedTable;
}
inline void ReadRel::set_has_named_table() {
  _oneof_case_[0] = kNamedTable;
}
inline void ReadRel::clear_named_table() {
  if (has_named_table()) {
    delete read_type_.named_table_;
    clear_has_read_type();
  }
}
inline const ::substrait::ReadRel_NamedTable& ReadRel::_internal_named_table() const {
  return *read_type_.named_table_;
}
inline ::substrait::ReadRel_NamedTable* ReadRel::release_named_table() {
  // @@protoc_insertion_point(field_release:substrait.ReadRel.named_table)
  if (has_named_table()) {
    clear_has_read_type();
      ::substrait::ReadRel_NamedTable* temp = read_type_.named_table_;
    read_type_.named_table_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::ReadRel_NamedTable& ReadRel::named_table() const {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.named_table)
  return has_named_table()
      ? *read_type_.named_table_
      : *reinterpret_cast< ::substrait::ReadRel_NamedTable*>(&::substrait::_ReadRel_NamedTable_default_instance_);
}
inline ::substrait::ReadRel_NamedTable* ReadRel::mutable_named_table() {
  if (!has_named_table()) {
    clear_read_type();
    set_has_named_table();
    read_type_.named_table_ = CreateMaybeMessage< ::substrait::ReadRel_NamedTable >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.named_table)
  return read_type_.named_table_;
}

// .substrait.ReadRel.ExtensionTable extension_table = 8;
inline bool ReadRel::has_extension_table() const {
  return read_type_case() == kExtensionTable;
}
inline void ReadRel::set_has_extension_table() {
  _oneof_case_[0] = kExtensionTable;
}
inline void ReadRel::clear_extension_table() {
  if (has_extension_table()) {
    delete read_type_.extension_table_;
    clear_has_read_type();
  }
}
inline const ::substrait::ReadRel_ExtensionTable& ReadRel::_internal_extension_table() const {
  return *read_type_.extension_table_;
}
inline ::substrait::ReadRel_ExtensionTable* ReadRel::release_extension_table() {
  // @@protoc_insertion_point(field_release:substrait.ReadRel.extension_table)
  if (has_extension_table()) {
    clear_has_read_type();
      ::substrait::ReadRel_ExtensionTable* temp = read_type_.extension_table_;
    read_type_.extension_table_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::ReadRel_ExtensionTable& ReadRel::extension_table() const {
  // @@protoc_insertion_point(field_get:substrait.ReadRel.extension_table)
  return has_extension_table()
      ? *read_type_.extension_table_
      : *reinterpret_cast< ::substrait::ReadRel_ExtensionTable*>(&::substrait::_ReadRel_ExtensionTable_default_instance_);
}
inline ::substrait::ReadRel_ExtensionTable* ReadRel::mutable_extension_table() {
  if (!has_extension_table()) {
    clear_read_type();
    set_has_extension_table();
    read_type_.extension_table_ = CreateMaybeMessage< ::substrait::ReadRel_ExtensionTable >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.ReadRel.extension_table)
  return read_type_.extension_table_;
}

inline bool ReadRel::has_read_type() const {
  return read_type_case() != READ_TYPE_NOT_SET;
}
inline void ReadRel::clear_has_read_type() {
  _oneof_case_[0] = READ_TYPE_NOT_SET;
}
inline ReadRel::ReadTypeCase ReadRel::read_type_case() const {
  return ReadRel::ReadTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ProjectRel

// .substrait.RelCommon common = 1;
inline bool ProjectRel::has_common() const {
  return this != internal_default_instance() && common_ != NULL;
}
inline void ProjectRel::clear_common() {
  if (GetArenaNoVirtual() == NULL && common_ != NULL) {
    delete common_;
  }
  common_ = NULL;
}
inline const ::substrait::RelCommon& ProjectRel::_internal_common() const {
  return *common_;
}
inline const ::substrait::RelCommon& ProjectRel::common() const {
  const ::substrait::RelCommon* p = common_;
  // @@protoc_insertion_point(field_get:substrait.ProjectRel.common)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::RelCommon*>(
      &::substrait::_RelCommon_default_instance_);
}
inline ::substrait::RelCommon* ProjectRel::release_common() {
  // @@protoc_insertion_point(field_release:substrait.ProjectRel.common)
  
  ::substrait::RelCommon* temp = common_;
  common_ = NULL;
  return temp;
}
inline ::substrait::RelCommon* ProjectRel::mutable_common() {
  
  if (common_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::RelCommon>(GetArenaNoVirtual());
    common_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.ProjectRel.common)
  return common_;
}
inline void ProjectRel::set_allocated_common(::substrait::RelCommon* common) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete common_;
  }
  if (common) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      common = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, common, submessage_arena);
    }
    
  } else {
    
  }
  common_ = common;
  // @@protoc_insertion_point(field_set_allocated:substrait.ProjectRel.common)
}

// .substrait.Rel input = 2;
inline bool ProjectRel::has_input() const {
  return this != internal_default_instance() && input_ != NULL;
}
inline void ProjectRel::clear_input() {
  if (GetArenaNoVirtual() == NULL && input_ != NULL) {
    delete input_;
  }
  input_ = NULL;
}
inline const ::substrait::Rel& ProjectRel::_internal_input() const {
  return *input_;
}
inline const ::substrait::Rel& ProjectRel::input() const {
  const ::substrait::Rel* p = input_;
  // @@protoc_insertion_point(field_get:substrait.ProjectRel.input)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Rel*>(
      &::substrait::_Rel_default_instance_);
}
inline ::substrait::Rel* ProjectRel::release_input() {
  // @@protoc_insertion_point(field_release:substrait.ProjectRel.input)
  
  ::substrait::Rel* temp = input_;
  input_ = NULL;
  return temp;
}
inline ::substrait::Rel* ProjectRel::mutable_input() {
  
  if (input_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Rel>(GetArenaNoVirtual());
    input_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.ProjectRel.input)
  return input_;
}
inline void ProjectRel::set_allocated_input(::substrait::Rel* input) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete input_;
  }
  if (input) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      input = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, input, submessage_arena);
    }
    
  } else {
    
  }
  input_ = input;
  // @@protoc_insertion_point(field_set_allocated:substrait.ProjectRel.input)
}

// repeated .substrait.Expression expressions = 3;
inline int ProjectRel::expressions_size() const {
  return expressions_.size();
}
inline void ProjectRel::clear_expressions() {
  expressions_.Clear();
}
inline ::substrait::Expression* ProjectRel::mutable_expressions(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.ProjectRel.expressions)
  return expressions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::Expression >*
ProjectRel::mutable_expressions() {
  // @@protoc_insertion_point(field_mutable_list:substrait.ProjectRel.expressions)
  return &expressions_;
}
inline const ::substrait::Expression& ProjectRel::expressions(int index) const {
  // @@protoc_insertion_point(field_get:substrait.ProjectRel.expressions)
  return expressions_.Get(index);
}
inline ::substrait::Expression* ProjectRel::add_expressions() {
  // @@protoc_insertion_point(field_add:substrait.ProjectRel.expressions)
  return expressions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::Expression >&
ProjectRel::expressions() const {
  // @@protoc_insertion_point(field_list:substrait.ProjectRel.expressions)
  return expressions_;
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool ProjectRel::has_advanced_extension() const {
  return this != internal_default_instance() && advanced_extension_ != NULL;
}
inline const ::substrait::extensions::AdvancedExtension& ProjectRel::_internal_advanced_extension() const {
  return *advanced_extension_;
}
inline const ::substrait::extensions::AdvancedExtension& ProjectRel::advanced_extension() const {
  const ::substrait::extensions::AdvancedExtension* p = advanced_extension_;
  // @@protoc_insertion_point(field_get:substrait.ProjectRel.advanced_extension)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::extensions::AdvancedExtension*>(
      &::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline ::substrait::extensions::AdvancedExtension* ProjectRel::release_advanced_extension() {
  // @@protoc_insertion_point(field_release:substrait.ProjectRel.advanced_extension)
  
  ::substrait::extensions::AdvancedExtension* temp = advanced_extension_;
  advanced_extension_ = NULL;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* ProjectRel::mutable_advanced_extension() {
  
  if (advanced_extension_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::extensions::AdvancedExtension>(GetArenaNoVirtual());
    advanced_extension_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.ProjectRel.advanced_extension)
  return advanced_extension_;
}
inline void ProjectRel::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(advanced_extension_);
  }
  if (advanced_extension) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      advanced_extension = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, advanced_extension, submessage_arena);
    }
    
  } else {
    
  }
  advanced_extension_ = advanced_extension;
  // @@protoc_insertion_point(field_set_allocated:substrait.ProjectRel.advanced_extension)
}

// -------------------------------------------------------------------

// JoinRel

// .substrait.RelCommon common = 1;
inline bool JoinRel::has_common() const {
  return this != internal_default_instance() && common_ != NULL;
}
inline void JoinRel::clear_common() {
  if (GetArenaNoVirtual() == NULL && common_ != NULL) {
    delete common_;
  }
  common_ = NULL;
}
inline const ::substrait::RelCommon& JoinRel::_internal_common() const {
  return *common_;
}
inline const ::substrait::RelCommon& JoinRel::common() const {
  const ::substrait::RelCommon* p = common_;
  // @@protoc_insertion_point(field_get:substrait.JoinRel.common)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::RelCommon*>(
      &::substrait::_RelCommon_default_instance_);
}
inline ::substrait::RelCommon* JoinRel::release_common() {
  // @@protoc_insertion_point(field_release:substrait.JoinRel.common)
  
  ::substrait::RelCommon* temp = common_;
  common_ = NULL;
  return temp;
}
inline ::substrait::RelCommon* JoinRel::mutable_common() {
  
  if (common_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::RelCommon>(GetArenaNoVirtual());
    common_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.JoinRel.common)
  return common_;
}
inline void JoinRel::set_allocated_common(::substrait::RelCommon* common) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete common_;
  }
  if (common) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      common = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, common, submessage_arena);
    }
    
  } else {
    
  }
  common_ = common;
  // @@protoc_insertion_point(field_set_allocated:substrait.JoinRel.common)
}

// .substrait.Rel left = 2;
inline bool JoinRel::has_left() const {
  return this != internal_default_instance() && left_ != NULL;
}
inline void JoinRel::clear_left() {
  if (GetArenaNoVirtual() == NULL && left_ != NULL) {
    delete left_;
  }
  left_ = NULL;
}
inline const ::substrait::Rel& JoinRel::_internal_left() const {
  return *left_;
}
inline const ::substrait::Rel& JoinRel::left() const {
  const ::substrait::Rel* p = left_;
  // @@protoc_insertion_point(field_get:substrait.JoinRel.left)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Rel*>(
      &::substrait::_Rel_default_instance_);
}
inline ::substrait::Rel* JoinRel::release_left() {
  // @@protoc_insertion_point(field_release:substrait.JoinRel.left)
  
  ::substrait::Rel* temp = left_;
  left_ = NULL;
  return temp;
}
inline ::substrait::Rel* JoinRel::mutable_left() {
  
  if (left_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Rel>(GetArenaNoVirtual());
    left_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.JoinRel.left)
  return left_;
}
inline void JoinRel::set_allocated_left(::substrait::Rel* left) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete left_;
  }
  if (left) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      left = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, left, submessage_arena);
    }
    
  } else {
    
  }
  left_ = left;
  // @@protoc_insertion_point(field_set_allocated:substrait.JoinRel.left)
}

// .substrait.Rel right = 3;
inline bool JoinRel::has_right() const {
  return this != internal_default_instance() && right_ != NULL;
}
inline void JoinRel::clear_right() {
  if (GetArenaNoVirtual() == NULL && right_ != NULL) {
    delete right_;
  }
  right_ = NULL;
}
inline const ::substrait::Rel& JoinRel::_internal_right() const {
  return *right_;
}
inline const ::substrait::Rel& JoinRel::right() const {
  const ::substrait::Rel* p = right_;
  // @@protoc_insertion_point(field_get:substrait.JoinRel.right)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Rel*>(
      &::substrait::_Rel_default_instance_);
}
inline ::substrait::Rel* JoinRel::release_right() {
  // @@protoc_insertion_point(field_release:substrait.JoinRel.right)
  
  ::substrait::Rel* temp = right_;
  right_ = NULL;
  return temp;
}
inline ::substrait::Rel* JoinRel::mutable_right() {
  
  if (right_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Rel>(GetArenaNoVirtual());
    right_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.JoinRel.right)
  return right_;
}
inline void JoinRel::set_allocated_right(::substrait::Rel* right) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete right_;
  }
  if (right) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      right = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, right, submessage_arena);
    }
    
  } else {
    
  }
  right_ = right;
  // @@protoc_insertion_point(field_set_allocated:substrait.JoinRel.right)
}

// .substrait.Expression expression = 4;
inline bool JoinRel::has_expression() const {
  return this != internal_default_instance() && expression_ != NULL;
}
inline void JoinRel::clear_expression() {
  if (GetArenaNoVirtual() == NULL && expression_ != NULL) {
    delete expression_;
  }
  expression_ = NULL;
}
inline const ::substrait::Expression& JoinRel::_internal_expression() const {
  return *expression_;
}
inline const ::substrait::Expression& JoinRel::expression() const {
  const ::substrait::Expression* p = expression_;
  // @@protoc_insertion_point(field_get:substrait.JoinRel.expression)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression*>(
      &::substrait::_Expression_default_instance_);
}
inline ::substrait::Expression* JoinRel::release_expression() {
  // @@protoc_insertion_point(field_release:substrait.JoinRel.expression)
  
  ::substrait::Expression* temp = expression_;
  expression_ = NULL;
  return temp;
}
inline ::substrait::Expression* JoinRel::mutable_expression() {
  
  if (expression_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression>(GetArenaNoVirtual());
    expression_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.JoinRel.expression)
  return expression_;
}
inline void JoinRel::set_allocated_expression(::substrait::Expression* expression) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete expression_;
  }
  if (expression) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      expression = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, expression, submessage_arena);
    }
    
  } else {
    
  }
  expression_ = expression;
  // @@protoc_insertion_point(field_set_allocated:substrait.JoinRel.expression)
}

// .substrait.Expression post_join_filter = 5;
inline bool JoinRel::has_post_join_filter() const {
  return this != internal_default_instance() && post_join_filter_ != NULL;
}
inline void JoinRel::clear_post_join_filter() {
  if (GetArenaNoVirtual() == NULL && post_join_filter_ != NULL) {
    delete post_join_filter_;
  }
  post_join_filter_ = NULL;
}
inline const ::substrait::Expression& JoinRel::_internal_post_join_filter() const {
  return *post_join_filter_;
}
inline const ::substrait::Expression& JoinRel::post_join_filter() const {
  const ::substrait::Expression* p = post_join_filter_;
  // @@protoc_insertion_point(field_get:substrait.JoinRel.post_join_filter)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression*>(
      &::substrait::_Expression_default_instance_);
}
inline ::substrait::Expression* JoinRel::release_post_join_filter() {
  // @@protoc_insertion_point(field_release:substrait.JoinRel.post_join_filter)
  
  ::substrait::Expression* temp = post_join_filter_;
  post_join_filter_ = NULL;
  return temp;
}
inline ::substrait::Expression* JoinRel::mutable_post_join_filter() {
  
  if (post_join_filter_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression>(GetArenaNoVirtual());
    post_join_filter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.JoinRel.post_join_filter)
  return post_join_filter_;
}
inline void JoinRel::set_allocated_post_join_filter(::substrait::Expression* post_join_filter) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete post_join_filter_;
  }
  if (post_join_filter) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      post_join_filter = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, post_join_filter, submessage_arena);
    }
    
  } else {
    
  }
  post_join_filter_ = post_join_filter;
  // @@protoc_insertion_point(field_set_allocated:substrait.JoinRel.post_join_filter)
}

// .substrait.JoinRel.JoinType type = 6;
inline void JoinRel::clear_type() {
  type_ = 0;
}
inline ::substrait::JoinRel_JoinType JoinRel::type() const {
  // @@protoc_insertion_point(field_get:substrait.JoinRel.type)
  return static_cast< ::substrait::JoinRel_JoinType >(type_);
}
inline void JoinRel::set_type(::substrait::JoinRel_JoinType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:substrait.JoinRel.type)
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool JoinRel::has_advanced_extension() const {
  return this != internal_default_instance() && advanced_extension_ != NULL;
}
inline const ::substrait::extensions::AdvancedExtension& JoinRel::_internal_advanced_extension() const {
  return *advanced_extension_;
}
inline const ::substrait::extensions::AdvancedExtension& JoinRel::advanced_extension() const {
  const ::substrait::extensions::AdvancedExtension* p = advanced_extension_;
  // @@protoc_insertion_point(field_get:substrait.JoinRel.advanced_extension)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::extensions::AdvancedExtension*>(
      &::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline ::substrait::extensions::AdvancedExtension* JoinRel::release_advanced_extension() {
  // @@protoc_insertion_point(field_release:substrait.JoinRel.advanced_extension)
  
  ::substrait::extensions::AdvancedExtension* temp = advanced_extension_;
  advanced_extension_ = NULL;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* JoinRel::mutable_advanced_extension() {
  
  if (advanced_extension_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::extensions::AdvancedExtension>(GetArenaNoVirtual());
    advanced_extension_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.JoinRel.advanced_extension)
  return advanced_extension_;
}
inline void JoinRel::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(advanced_extension_);
  }
  if (advanced_extension) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      advanced_extension = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, advanced_extension, submessage_arena);
    }
    
  } else {
    
  }
  advanced_extension_ = advanced_extension;
  // @@protoc_insertion_point(field_set_allocated:substrait.JoinRel.advanced_extension)
}

// -------------------------------------------------------------------

// CrossRel

// .substrait.RelCommon common = 1;
inline bool CrossRel::has_common() const {
  return this != internal_default_instance() && common_ != NULL;
}
inline void CrossRel::clear_common() {
  if (GetArenaNoVirtual() == NULL && common_ != NULL) {
    delete common_;
  }
  common_ = NULL;
}
inline const ::substrait::RelCommon& CrossRel::_internal_common() const {
  return *common_;
}
inline const ::substrait::RelCommon& CrossRel::common() const {
  const ::substrait::RelCommon* p = common_;
  // @@protoc_insertion_point(field_get:substrait.CrossRel.common)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::RelCommon*>(
      &::substrait::_RelCommon_default_instance_);
}
inline ::substrait::RelCommon* CrossRel::release_common() {
  // @@protoc_insertion_point(field_release:substrait.CrossRel.common)
  
  ::substrait::RelCommon* temp = common_;
  common_ = NULL;
  return temp;
}
inline ::substrait::RelCommon* CrossRel::mutable_common() {
  
  if (common_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::RelCommon>(GetArenaNoVirtual());
    common_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.CrossRel.common)
  return common_;
}
inline void CrossRel::set_allocated_common(::substrait::RelCommon* common) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete common_;
  }
  if (common) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      common = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, common, submessage_arena);
    }
    
  } else {
    
  }
  common_ = common;
  // @@protoc_insertion_point(field_set_allocated:substrait.CrossRel.common)
}

// .substrait.Rel left = 2;
inline bool CrossRel::has_left() const {
  return this != internal_default_instance() && left_ != NULL;
}
inline void CrossRel::clear_left() {
  if (GetArenaNoVirtual() == NULL && left_ != NULL) {
    delete left_;
  }
  left_ = NULL;
}
inline const ::substrait::Rel& CrossRel::_internal_left() const {
  return *left_;
}
inline const ::substrait::Rel& CrossRel::left() const {
  const ::substrait::Rel* p = left_;
  // @@protoc_insertion_point(field_get:substrait.CrossRel.left)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Rel*>(
      &::substrait::_Rel_default_instance_);
}
inline ::substrait::Rel* CrossRel::release_left() {
  // @@protoc_insertion_point(field_release:substrait.CrossRel.left)
  
  ::substrait::Rel* temp = left_;
  left_ = NULL;
  return temp;
}
inline ::substrait::Rel* CrossRel::mutable_left() {
  
  if (left_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Rel>(GetArenaNoVirtual());
    left_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.CrossRel.left)
  return left_;
}
inline void CrossRel::set_allocated_left(::substrait::Rel* left) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete left_;
  }
  if (left) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      left = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, left, submessage_arena);
    }
    
  } else {
    
  }
  left_ = left;
  // @@protoc_insertion_point(field_set_allocated:substrait.CrossRel.left)
}

// .substrait.Rel right = 3;
inline bool CrossRel::has_right() const {
  return this != internal_default_instance() && right_ != NULL;
}
inline void CrossRel::clear_right() {
  if (GetArenaNoVirtual() == NULL && right_ != NULL) {
    delete right_;
  }
  right_ = NULL;
}
inline const ::substrait::Rel& CrossRel::_internal_right() const {
  return *right_;
}
inline const ::substrait::Rel& CrossRel::right() const {
  const ::substrait::Rel* p = right_;
  // @@protoc_insertion_point(field_get:substrait.CrossRel.right)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Rel*>(
      &::substrait::_Rel_default_instance_);
}
inline ::substrait::Rel* CrossRel::release_right() {
  // @@protoc_insertion_point(field_release:substrait.CrossRel.right)
  
  ::substrait::Rel* temp = right_;
  right_ = NULL;
  return temp;
}
inline ::substrait::Rel* CrossRel::mutable_right() {
  
  if (right_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Rel>(GetArenaNoVirtual());
    right_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.CrossRel.right)
  return right_;
}
inline void CrossRel::set_allocated_right(::substrait::Rel* right) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete right_;
  }
  if (right) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      right = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, right, submessage_arena);
    }
    
  } else {
    
  }
  right_ = right;
  // @@protoc_insertion_point(field_set_allocated:substrait.CrossRel.right)
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool CrossRel::has_advanced_extension() const {
  return this != internal_default_instance() && advanced_extension_ != NULL;
}
inline const ::substrait::extensions::AdvancedExtension& CrossRel::_internal_advanced_extension() const {
  return *advanced_extension_;
}
inline const ::substrait::extensions::AdvancedExtension& CrossRel::advanced_extension() const {
  const ::substrait::extensions::AdvancedExtension* p = advanced_extension_;
  // @@protoc_insertion_point(field_get:substrait.CrossRel.advanced_extension)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::extensions::AdvancedExtension*>(
      &::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline ::substrait::extensions::AdvancedExtension* CrossRel::release_advanced_extension() {
  // @@protoc_insertion_point(field_release:substrait.CrossRel.advanced_extension)
  
  ::substrait::extensions::AdvancedExtension* temp = advanced_extension_;
  advanced_extension_ = NULL;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* CrossRel::mutable_advanced_extension() {
  
  if (advanced_extension_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::extensions::AdvancedExtension>(GetArenaNoVirtual());
    advanced_extension_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.CrossRel.advanced_extension)
  return advanced_extension_;
}
inline void CrossRel::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(advanced_extension_);
  }
  if (advanced_extension) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      advanced_extension = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, advanced_extension, submessage_arena);
    }
    
  } else {
    
  }
  advanced_extension_ = advanced_extension;
  // @@protoc_insertion_point(field_set_allocated:substrait.CrossRel.advanced_extension)
}

// -------------------------------------------------------------------

// FetchRel

// .substrait.RelCommon common = 1;
inline bool FetchRel::has_common() const {
  return this != internal_default_instance() && common_ != NULL;
}
inline void FetchRel::clear_common() {
  if (GetArenaNoVirtual() == NULL && common_ != NULL) {
    delete common_;
  }
  common_ = NULL;
}
inline const ::substrait::RelCommon& FetchRel::_internal_common() const {
  return *common_;
}
inline const ::substrait::RelCommon& FetchRel::common() const {
  const ::substrait::RelCommon* p = common_;
  // @@protoc_insertion_point(field_get:substrait.FetchRel.common)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::RelCommon*>(
      &::substrait::_RelCommon_default_instance_);
}
inline ::substrait::RelCommon* FetchRel::release_common() {
  // @@protoc_insertion_point(field_release:substrait.FetchRel.common)
  
  ::substrait::RelCommon* temp = common_;
  common_ = NULL;
  return temp;
}
inline ::substrait::RelCommon* FetchRel::mutable_common() {
  
  if (common_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::RelCommon>(GetArenaNoVirtual());
    common_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.FetchRel.common)
  return common_;
}
inline void FetchRel::set_allocated_common(::substrait::RelCommon* common) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete common_;
  }
  if (common) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      common = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, common, submessage_arena);
    }
    
  } else {
    
  }
  common_ = common;
  // @@protoc_insertion_point(field_set_allocated:substrait.FetchRel.common)
}

// .substrait.Rel input = 2;
inline bool FetchRel::has_input() const {
  return this != internal_default_instance() && input_ != NULL;
}
inline void FetchRel::clear_input() {
  if (GetArenaNoVirtual() == NULL && input_ != NULL) {
    delete input_;
  }
  input_ = NULL;
}
inline const ::substrait::Rel& FetchRel::_internal_input() const {
  return *input_;
}
inline const ::substrait::Rel& FetchRel::input() const {
  const ::substrait::Rel* p = input_;
  // @@protoc_insertion_point(field_get:substrait.FetchRel.input)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Rel*>(
      &::substrait::_Rel_default_instance_);
}
inline ::substrait::Rel* FetchRel::release_input() {
  // @@protoc_insertion_point(field_release:substrait.FetchRel.input)
  
  ::substrait::Rel* temp = input_;
  input_ = NULL;
  return temp;
}
inline ::substrait::Rel* FetchRel::mutable_input() {
  
  if (input_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Rel>(GetArenaNoVirtual());
    input_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.FetchRel.input)
  return input_;
}
inline void FetchRel::set_allocated_input(::substrait::Rel* input) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete input_;
  }
  if (input) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      input = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, input, submessage_arena);
    }
    
  } else {
    
  }
  input_ = input;
  // @@protoc_insertion_point(field_set_allocated:substrait.FetchRel.input)
}

// int64 offset = 3;
inline void FetchRel::clear_offset() {
  offset_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 FetchRel::offset() const {
  // @@protoc_insertion_point(field_get:substrait.FetchRel.offset)
  return offset_;
}
inline void FetchRel::set_offset(::google::protobuf::int64 value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:substrait.FetchRel.offset)
}

// int64 count = 4;
inline void FetchRel::clear_count() {
  count_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 FetchRel::count() const {
  // @@protoc_insertion_point(field_get:substrait.FetchRel.count)
  return count_;
}
inline void FetchRel::set_count(::google::protobuf::int64 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:substrait.FetchRel.count)
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool FetchRel::has_advanced_extension() const {
  return this != internal_default_instance() && advanced_extension_ != NULL;
}
inline const ::substrait::extensions::AdvancedExtension& FetchRel::_internal_advanced_extension() const {
  return *advanced_extension_;
}
inline const ::substrait::extensions::AdvancedExtension& FetchRel::advanced_extension() const {
  const ::substrait::extensions::AdvancedExtension* p = advanced_extension_;
  // @@protoc_insertion_point(field_get:substrait.FetchRel.advanced_extension)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::extensions::AdvancedExtension*>(
      &::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline ::substrait::extensions::AdvancedExtension* FetchRel::release_advanced_extension() {
  // @@protoc_insertion_point(field_release:substrait.FetchRel.advanced_extension)
  
  ::substrait::extensions::AdvancedExtension* temp = advanced_extension_;
  advanced_extension_ = NULL;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* FetchRel::mutable_advanced_extension() {
  
  if (advanced_extension_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::extensions::AdvancedExtension>(GetArenaNoVirtual());
    advanced_extension_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.FetchRel.advanced_extension)
  return advanced_extension_;
}
inline void FetchRel::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(advanced_extension_);
  }
  if (advanced_extension) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      advanced_extension = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, advanced_extension, submessage_arena);
    }
    
  } else {
    
  }
  advanced_extension_ = advanced_extension;
  // @@protoc_insertion_point(field_set_allocated:substrait.FetchRel.advanced_extension)
}

// -------------------------------------------------------------------

// AggregateRel_Grouping

// repeated .substrait.Expression grouping_expressions = 1;
inline int AggregateRel_Grouping::grouping_expressions_size() const {
  return grouping_expressions_.size();
}
inline void AggregateRel_Grouping::clear_grouping_expressions() {
  grouping_expressions_.Clear();
}
inline ::substrait::Expression* AggregateRel_Grouping::mutable_grouping_expressions(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.AggregateRel.Grouping.grouping_expressions)
  return grouping_expressions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::Expression >*
AggregateRel_Grouping::mutable_grouping_expressions() {
  // @@protoc_insertion_point(field_mutable_list:substrait.AggregateRel.Grouping.grouping_expressions)
  return &grouping_expressions_;
}
inline const ::substrait::Expression& AggregateRel_Grouping::grouping_expressions(int index) const {
  // @@protoc_insertion_point(field_get:substrait.AggregateRel.Grouping.grouping_expressions)
  return grouping_expressions_.Get(index);
}
inline ::substrait::Expression* AggregateRel_Grouping::add_grouping_expressions() {
  // @@protoc_insertion_point(field_add:substrait.AggregateRel.Grouping.grouping_expressions)
  return grouping_expressions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::Expression >&
AggregateRel_Grouping::grouping_expressions() const {
  // @@protoc_insertion_point(field_list:substrait.AggregateRel.Grouping.grouping_expressions)
  return grouping_expressions_;
}

// -------------------------------------------------------------------

// AggregateRel_Measure

// .substrait.AggregateFunction measure = 1;
inline bool AggregateRel_Measure::has_measure() const {
  return this != internal_default_instance() && measure_ != NULL;
}
inline void AggregateRel_Measure::clear_measure() {
  if (GetArenaNoVirtual() == NULL && measure_ != NULL) {
    delete measure_;
  }
  measure_ = NULL;
}
inline const ::substrait::AggregateFunction& AggregateRel_Measure::_internal_measure() const {
  return *measure_;
}
inline const ::substrait::AggregateFunction& AggregateRel_Measure::measure() const {
  const ::substrait::AggregateFunction* p = measure_;
  // @@protoc_insertion_point(field_get:substrait.AggregateRel.Measure.measure)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::AggregateFunction*>(
      &::substrait::_AggregateFunction_default_instance_);
}
inline ::substrait::AggregateFunction* AggregateRel_Measure::release_measure() {
  // @@protoc_insertion_point(field_release:substrait.AggregateRel.Measure.measure)
  
  ::substrait::AggregateFunction* temp = measure_;
  measure_ = NULL;
  return temp;
}
inline ::substrait::AggregateFunction* AggregateRel_Measure::mutable_measure() {
  
  if (measure_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::AggregateFunction>(GetArenaNoVirtual());
    measure_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.AggregateRel.Measure.measure)
  return measure_;
}
inline void AggregateRel_Measure::set_allocated_measure(::substrait::AggregateFunction* measure) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete measure_;
  }
  if (measure) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      measure = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, measure, submessage_arena);
    }
    
  } else {
    
  }
  measure_ = measure;
  // @@protoc_insertion_point(field_set_allocated:substrait.AggregateRel.Measure.measure)
}

// .substrait.Expression filter = 2;
inline bool AggregateRel_Measure::has_filter() const {
  return this != internal_default_instance() && filter_ != NULL;
}
inline void AggregateRel_Measure::clear_filter() {
  if (GetArenaNoVirtual() == NULL && filter_ != NULL) {
    delete filter_;
  }
  filter_ = NULL;
}
inline const ::substrait::Expression& AggregateRel_Measure::_internal_filter() const {
  return *filter_;
}
inline const ::substrait::Expression& AggregateRel_Measure::filter() const {
  const ::substrait::Expression* p = filter_;
  // @@protoc_insertion_point(field_get:substrait.AggregateRel.Measure.filter)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression*>(
      &::substrait::_Expression_default_instance_);
}
inline ::substrait::Expression* AggregateRel_Measure::release_filter() {
  // @@protoc_insertion_point(field_release:substrait.AggregateRel.Measure.filter)
  
  ::substrait::Expression* temp = filter_;
  filter_ = NULL;
  return temp;
}
inline ::substrait::Expression* AggregateRel_Measure::mutable_filter() {
  
  if (filter_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression>(GetArenaNoVirtual());
    filter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.AggregateRel.Measure.filter)
  return filter_;
}
inline void AggregateRel_Measure::set_allocated_filter(::substrait::Expression* filter) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete filter_;
  }
  if (filter) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      filter = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    
  } else {
    
  }
  filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:substrait.AggregateRel.Measure.filter)
}

// -------------------------------------------------------------------

// AggregateRel

// .substrait.RelCommon common = 1;
inline bool AggregateRel::has_common() const {
  return this != internal_default_instance() && common_ != NULL;
}
inline void AggregateRel::clear_common() {
  if (GetArenaNoVirtual() == NULL && common_ != NULL) {
    delete common_;
  }
  common_ = NULL;
}
inline const ::substrait::RelCommon& AggregateRel::_internal_common() const {
  return *common_;
}
inline const ::substrait::RelCommon& AggregateRel::common() const {
  const ::substrait::RelCommon* p = common_;
  // @@protoc_insertion_point(field_get:substrait.AggregateRel.common)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::RelCommon*>(
      &::substrait::_RelCommon_default_instance_);
}
inline ::substrait::RelCommon* AggregateRel::release_common() {
  // @@protoc_insertion_point(field_release:substrait.AggregateRel.common)
  
  ::substrait::RelCommon* temp = common_;
  common_ = NULL;
  return temp;
}
inline ::substrait::RelCommon* AggregateRel::mutable_common() {
  
  if (common_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::RelCommon>(GetArenaNoVirtual());
    common_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.AggregateRel.common)
  return common_;
}
inline void AggregateRel::set_allocated_common(::substrait::RelCommon* common) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete common_;
  }
  if (common) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      common = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, common, submessage_arena);
    }
    
  } else {
    
  }
  common_ = common;
  // @@protoc_insertion_point(field_set_allocated:substrait.AggregateRel.common)
}

// .substrait.Rel input = 2;
inline bool AggregateRel::has_input() const {
  return this != internal_default_instance() && input_ != NULL;
}
inline void AggregateRel::clear_input() {
  if (GetArenaNoVirtual() == NULL && input_ != NULL) {
    delete input_;
  }
  input_ = NULL;
}
inline const ::substrait::Rel& AggregateRel::_internal_input() const {
  return *input_;
}
inline const ::substrait::Rel& AggregateRel::input() const {
  const ::substrait::Rel* p = input_;
  // @@protoc_insertion_point(field_get:substrait.AggregateRel.input)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Rel*>(
      &::substrait::_Rel_default_instance_);
}
inline ::substrait::Rel* AggregateRel::release_input() {
  // @@protoc_insertion_point(field_release:substrait.AggregateRel.input)
  
  ::substrait::Rel* temp = input_;
  input_ = NULL;
  return temp;
}
inline ::substrait::Rel* AggregateRel::mutable_input() {
  
  if (input_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Rel>(GetArenaNoVirtual());
    input_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.AggregateRel.input)
  return input_;
}
inline void AggregateRel::set_allocated_input(::substrait::Rel* input) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete input_;
  }
  if (input) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      input = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, input, submessage_arena);
    }
    
  } else {
    
  }
  input_ = input;
  // @@protoc_insertion_point(field_set_allocated:substrait.AggregateRel.input)
}

// repeated .substrait.AggregateRel.Grouping groupings = 3;
inline int AggregateRel::groupings_size() const {
  return groupings_.size();
}
inline void AggregateRel::clear_groupings() {
  groupings_.Clear();
}
inline ::substrait::AggregateRel_Grouping* AggregateRel::mutable_groupings(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.AggregateRel.groupings)
  return groupings_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::AggregateRel_Grouping >*
AggregateRel::mutable_groupings() {
  // @@protoc_insertion_point(field_mutable_list:substrait.AggregateRel.groupings)
  return &groupings_;
}
inline const ::substrait::AggregateRel_Grouping& AggregateRel::groupings(int index) const {
  // @@protoc_insertion_point(field_get:substrait.AggregateRel.groupings)
  return groupings_.Get(index);
}
inline ::substrait::AggregateRel_Grouping* AggregateRel::add_groupings() {
  // @@protoc_insertion_point(field_add:substrait.AggregateRel.groupings)
  return groupings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::AggregateRel_Grouping >&
AggregateRel::groupings() const {
  // @@protoc_insertion_point(field_list:substrait.AggregateRel.groupings)
  return groupings_;
}

// repeated .substrait.AggregateRel.Measure measures = 4;
inline int AggregateRel::measures_size() const {
  return measures_.size();
}
inline void AggregateRel::clear_measures() {
  measures_.Clear();
}
inline ::substrait::AggregateRel_Measure* AggregateRel::mutable_measures(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.AggregateRel.measures)
  return measures_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::AggregateRel_Measure >*
AggregateRel::mutable_measures() {
  // @@protoc_insertion_point(field_mutable_list:substrait.AggregateRel.measures)
  return &measures_;
}
inline const ::substrait::AggregateRel_Measure& AggregateRel::measures(int index) const {
  // @@protoc_insertion_point(field_get:substrait.AggregateRel.measures)
  return measures_.Get(index);
}
inline ::substrait::AggregateRel_Measure* AggregateRel::add_measures() {
  // @@protoc_insertion_point(field_add:substrait.AggregateRel.measures)
  return measures_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::AggregateRel_Measure >&
AggregateRel::measures() const {
  // @@protoc_insertion_point(field_list:substrait.AggregateRel.measures)
  return measures_;
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool AggregateRel::has_advanced_extension() const {
  return this != internal_default_instance() && advanced_extension_ != NULL;
}
inline const ::substrait::extensions::AdvancedExtension& AggregateRel::_internal_advanced_extension() const {
  return *advanced_extension_;
}
inline const ::substrait::extensions::AdvancedExtension& AggregateRel::advanced_extension() const {
  const ::substrait::extensions::AdvancedExtension* p = advanced_extension_;
  // @@protoc_insertion_point(field_get:substrait.AggregateRel.advanced_extension)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::extensions::AdvancedExtension*>(
      &::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline ::substrait::extensions::AdvancedExtension* AggregateRel::release_advanced_extension() {
  // @@protoc_insertion_point(field_release:substrait.AggregateRel.advanced_extension)
  
  ::substrait::extensions::AdvancedExtension* temp = advanced_extension_;
  advanced_extension_ = NULL;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* AggregateRel::mutable_advanced_extension() {
  
  if (advanced_extension_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::extensions::AdvancedExtension>(GetArenaNoVirtual());
    advanced_extension_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.AggregateRel.advanced_extension)
  return advanced_extension_;
}
inline void AggregateRel::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(advanced_extension_);
  }
  if (advanced_extension) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      advanced_extension = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, advanced_extension, submessage_arena);
    }
    
  } else {
    
  }
  advanced_extension_ = advanced_extension;
  // @@protoc_insertion_point(field_set_allocated:substrait.AggregateRel.advanced_extension)
}

// -------------------------------------------------------------------

// SortRel

// .substrait.RelCommon common = 1;
inline bool SortRel::has_common() const {
  return this != internal_default_instance() && common_ != NULL;
}
inline void SortRel::clear_common() {
  if (GetArenaNoVirtual() == NULL && common_ != NULL) {
    delete common_;
  }
  common_ = NULL;
}
inline const ::substrait::RelCommon& SortRel::_internal_common() const {
  return *common_;
}
inline const ::substrait::RelCommon& SortRel::common() const {
  const ::substrait::RelCommon* p = common_;
  // @@protoc_insertion_point(field_get:substrait.SortRel.common)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::RelCommon*>(
      &::substrait::_RelCommon_default_instance_);
}
inline ::substrait::RelCommon* SortRel::release_common() {
  // @@protoc_insertion_point(field_release:substrait.SortRel.common)
  
  ::substrait::RelCommon* temp = common_;
  common_ = NULL;
  return temp;
}
inline ::substrait::RelCommon* SortRel::mutable_common() {
  
  if (common_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::RelCommon>(GetArenaNoVirtual());
    common_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.SortRel.common)
  return common_;
}
inline void SortRel::set_allocated_common(::substrait::RelCommon* common) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete common_;
  }
  if (common) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      common = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, common, submessage_arena);
    }
    
  } else {
    
  }
  common_ = common;
  // @@protoc_insertion_point(field_set_allocated:substrait.SortRel.common)
}

// .substrait.Rel input = 2;
inline bool SortRel::has_input() const {
  return this != internal_default_instance() && input_ != NULL;
}
inline void SortRel::clear_input() {
  if (GetArenaNoVirtual() == NULL && input_ != NULL) {
    delete input_;
  }
  input_ = NULL;
}
inline const ::substrait::Rel& SortRel::_internal_input() const {
  return *input_;
}
inline const ::substrait::Rel& SortRel::input() const {
  const ::substrait::Rel* p = input_;
  // @@protoc_insertion_point(field_get:substrait.SortRel.input)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Rel*>(
      &::substrait::_Rel_default_instance_);
}
inline ::substrait::Rel* SortRel::release_input() {
  // @@protoc_insertion_point(field_release:substrait.SortRel.input)
  
  ::substrait::Rel* temp = input_;
  input_ = NULL;
  return temp;
}
inline ::substrait::Rel* SortRel::mutable_input() {
  
  if (input_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Rel>(GetArenaNoVirtual());
    input_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.SortRel.input)
  return input_;
}
inline void SortRel::set_allocated_input(::substrait::Rel* input) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete input_;
  }
  if (input) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      input = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, input, submessage_arena);
    }
    
  } else {
    
  }
  input_ = input;
  // @@protoc_insertion_point(field_set_allocated:substrait.SortRel.input)
}

// repeated .substrait.SortField sorts = 3;
inline int SortRel::sorts_size() const {
  return sorts_.size();
}
inline void SortRel::clear_sorts() {
  sorts_.Clear();
}
inline ::substrait::SortField* SortRel::mutable_sorts(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.SortRel.sorts)
  return sorts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::SortField >*
SortRel::mutable_sorts() {
  // @@protoc_insertion_point(field_mutable_list:substrait.SortRel.sorts)
  return &sorts_;
}
inline const ::substrait::SortField& SortRel::sorts(int index) const {
  // @@protoc_insertion_point(field_get:substrait.SortRel.sorts)
  return sorts_.Get(index);
}
inline ::substrait::SortField* SortRel::add_sorts() {
  // @@protoc_insertion_point(field_add:substrait.SortRel.sorts)
  return sorts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::SortField >&
SortRel::sorts() const {
  // @@protoc_insertion_point(field_list:substrait.SortRel.sorts)
  return sorts_;
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool SortRel::has_advanced_extension() const {
  return this != internal_default_instance() && advanced_extension_ != NULL;
}
inline const ::substrait::extensions::AdvancedExtension& SortRel::_internal_advanced_extension() const {
  return *advanced_extension_;
}
inline const ::substrait::extensions::AdvancedExtension& SortRel::advanced_extension() const {
  const ::substrait::extensions::AdvancedExtension* p = advanced_extension_;
  // @@protoc_insertion_point(field_get:substrait.SortRel.advanced_extension)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::extensions::AdvancedExtension*>(
      &::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline ::substrait::extensions::AdvancedExtension* SortRel::release_advanced_extension() {
  // @@protoc_insertion_point(field_release:substrait.SortRel.advanced_extension)
  
  ::substrait::extensions::AdvancedExtension* temp = advanced_extension_;
  advanced_extension_ = NULL;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* SortRel::mutable_advanced_extension() {
  
  if (advanced_extension_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::extensions::AdvancedExtension>(GetArenaNoVirtual());
    advanced_extension_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.SortRel.advanced_extension)
  return advanced_extension_;
}
inline void SortRel::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(advanced_extension_);
  }
  if (advanced_extension) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      advanced_extension = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, advanced_extension, submessage_arena);
    }
    
  } else {
    
  }
  advanced_extension_ = advanced_extension;
  // @@protoc_insertion_point(field_set_allocated:substrait.SortRel.advanced_extension)
}

// -------------------------------------------------------------------

// FilterRel

// .substrait.RelCommon common = 1;
inline bool FilterRel::has_common() const {
  return this != internal_default_instance() && common_ != NULL;
}
inline void FilterRel::clear_common() {
  if (GetArenaNoVirtual() == NULL && common_ != NULL) {
    delete common_;
  }
  common_ = NULL;
}
inline const ::substrait::RelCommon& FilterRel::_internal_common() const {
  return *common_;
}
inline const ::substrait::RelCommon& FilterRel::common() const {
  const ::substrait::RelCommon* p = common_;
  // @@protoc_insertion_point(field_get:substrait.FilterRel.common)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::RelCommon*>(
      &::substrait::_RelCommon_default_instance_);
}
inline ::substrait::RelCommon* FilterRel::release_common() {
  // @@protoc_insertion_point(field_release:substrait.FilterRel.common)
  
  ::substrait::RelCommon* temp = common_;
  common_ = NULL;
  return temp;
}
inline ::substrait::RelCommon* FilterRel::mutable_common() {
  
  if (common_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::RelCommon>(GetArenaNoVirtual());
    common_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.FilterRel.common)
  return common_;
}
inline void FilterRel::set_allocated_common(::substrait::RelCommon* common) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete common_;
  }
  if (common) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      common = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, common, submessage_arena);
    }
    
  } else {
    
  }
  common_ = common;
  // @@protoc_insertion_point(field_set_allocated:substrait.FilterRel.common)
}

// .substrait.Rel input = 2;
inline bool FilterRel::has_input() const {
  return this != internal_default_instance() && input_ != NULL;
}
inline void FilterRel::clear_input() {
  if (GetArenaNoVirtual() == NULL && input_ != NULL) {
    delete input_;
  }
  input_ = NULL;
}
inline const ::substrait::Rel& FilterRel::_internal_input() const {
  return *input_;
}
inline const ::substrait::Rel& FilterRel::input() const {
  const ::substrait::Rel* p = input_;
  // @@protoc_insertion_point(field_get:substrait.FilterRel.input)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Rel*>(
      &::substrait::_Rel_default_instance_);
}
inline ::substrait::Rel* FilterRel::release_input() {
  // @@protoc_insertion_point(field_release:substrait.FilterRel.input)
  
  ::substrait::Rel* temp = input_;
  input_ = NULL;
  return temp;
}
inline ::substrait::Rel* FilterRel::mutable_input() {
  
  if (input_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Rel>(GetArenaNoVirtual());
    input_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.FilterRel.input)
  return input_;
}
inline void FilterRel::set_allocated_input(::substrait::Rel* input) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete input_;
  }
  if (input) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      input = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, input, submessage_arena);
    }
    
  } else {
    
  }
  input_ = input;
  // @@protoc_insertion_point(field_set_allocated:substrait.FilterRel.input)
}

// .substrait.Expression condition = 3;
inline bool FilterRel::has_condition() const {
  return this != internal_default_instance() && condition_ != NULL;
}
inline void FilterRel::clear_condition() {
  if (GetArenaNoVirtual() == NULL && condition_ != NULL) {
    delete condition_;
  }
  condition_ = NULL;
}
inline const ::substrait::Expression& FilterRel::_internal_condition() const {
  return *condition_;
}
inline const ::substrait::Expression& FilterRel::condition() const {
  const ::substrait::Expression* p = condition_;
  // @@protoc_insertion_point(field_get:substrait.FilterRel.condition)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression*>(
      &::substrait::_Expression_default_instance_);
}
inline ::substrait::Expression* FilterRel::release_condition() {
  // @@protoc_insertion_point(field_release:substrait.FilterRel.condition)
  
  ::substrait::Expression* temp = condition_;
  condition_ = NULL;
  return temp;
}
inline ::substrait::Expression* FilterRel::mutable_condition() {
  
  if (condition_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression>(GetArenaNoVirtual());
    condition_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.FilterRel.condition)
  return condition_;
}
inline void FilterRel::set_allocated_condition(::substrait::Expression* condition) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete condition_;
  }
  if (condition) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      condition = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, condition, submessage_arena);
    }
    
  } else {
    
  }
  condition_ = condition;
  // @@protoc_insertion_point(field_set_allocated:substrait.FilterRel.condition)
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool FilterRel::has_advanced_extension() const {
  return this != internal_default_instance() && advanced_extension_ != NULL;
}
inline const ::substrait::extensions::AdvancedExtension& FilterRel::_internal_advanced_extension() const {
  return *advanced_extension_;
}
inline const ::substrait::extensions::AdvancedExtension& FilterRel::advanced_extension() const {
  const ::substrait::extensions::AdvancedExtension* p = advanced_extension_;
  // @@protoc_insertion_point(field_get:substrait.FilterRel.advanced_extension)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::extensions::AdvancedExtension*>(
      &::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline ::substrait::extensions::AdvancedExtension* FilterRel::release_advanced_extension() {
  // @@protoc_insertion_point(field_release:substrait.FilterRel.advanced_extension)
  
  ::substrait::extensions::AdvancedExtension* temp = advanced_extension_;
  advanced_extension_ = NULL;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* FilterRel::mutable_advanced_extension() {
  
  if (advanced_extension_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::extensions::AdvancedExtension>(GetArenaNoVirtual());
    advanced_extension_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.FilterRel.advanced_extension)
  return advanced_extension_;
}
inline void FilterRel::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(advanced_extension_);
  }
  if (advanced_extension) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      advanced_extension = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, advanced_extension, submessage_arena);
    }
    
  } else {
    
  }
  advanced_extension_ = advanced_extension;
  // @@protoc_insertion_point(field_set_allocated:substrait.FilterRel.advanced_extension)
}

// -------------------------------------------------------------------

// SetRel

// .substrait.RelCommon common = 1;
inline bool SetRel::has_common() const {
  return this != internal_default_instance() && common_ != NULL;
}
inline void SetRel::clear_common() {
  if (GetArenaNoVirtual() == NULL && common_ != NULL) {
    delete common_;
  }
  common_ = NULL;
}
inline const ::substrait::RelCommon& SetRel::_internal_common() const {
  return *common_;
}
inline const ::substrait::RelCommon& SetRel::common() const {
  const ::substrait::RelCommon* p = common_;
  // @@protoc_insertion_point(field_get:substrait.SetRel.common)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::RelCommon*>(
      &::substrait::_RelCommon_default_instance_);
}
inline ::substrait::RelCommon* SetRel::release_common() {
  // @@protoc_insertion_point(field_release:substrait.SetRel.common)
  
  ::substrait::RelCommon* temp = common_;
  common_ = NULL;
  return temp;
}
inline ::substrait::RelCommon* SetRel::mutable_common() {
  
  if (common_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::RelCommon>(GetArenaNoVirtual());
    common_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.SetRel.common)
  return common_;
}
inline void SetRel::set_allocated_common(::substrait::RelCommon* common) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete common_;
  }
  if (common) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      common = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, common, submessage_arena);
    }
    
  } else {
    
  }
  common_ = common;
  // @@protoc_insertion_point(field_set_allocated:substrait.SetRel.common)
}

// repeated .substrait.Rel inputs = 2;
inline int SetRel::inputs_size() const {
  return inputs_.size();
}
inline void SetRel::clear_inputs() {
  inputs_.Clear();
}
inline ::substrait::Rel* SetRel::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.SetRel.inputs)
  return inputs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::Rel >*
SetRel::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:substrait.SetRel.inputs)
  return &inputs_;
}
inline const ::substrait::Rel& SetRel::inputs(int index) const {
  // @@protoc_insertion_point(field_get:substrait.SetRel.inputs)
  return inputs_.Get(index);
}
inline ::substrait::Rel* SetRel::add_inputs() {
  // @@protoc_insertion_point(field_add:substrait.SetRel.inputs)
  return inputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::Rel >&
SetRel::inputs() const {
  // @@protoc_insertion_point(field_list:substrait.SetRel.inputs)
  return inputs_;
}

// .substrait.SetRel.SetOp op = 3;
inline void SetRel::clear_op() {
  op_ = 0;
}
inline ::substrait::SetRel_SetOp SetRel::op() const {
  // @@protoc_insertion_point(field_get:substrait.SetRel.op)
  return static_cast< ::substrait::SetRel_SetOp >(op_);
}
inline void SetRel::set_op(::substrait::SetRel_SetOp value) {
  
  op_ = value;
  // @@protoc_insertion_point(field_set:substrait.SetRel.op)
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool SetRel::has_advanced_extension() const {
  return this != internal_default_instance() && advanced_extension_ != NULL;
}
inline const ::substrait::extensions::AdvancedExtension& SetRel::_internal_advanced_extension() const {
  return *advanced_extension_;
}
inline const ::substrait::extensions::AdvancedExtension& SetRel::advanced_extension() const {
  const ::substrait::extensions::AdvancedExtension* p = advanced_extension_;
  // @@protoc_insertion_point(field_get:substrait.SetRel.advanced_extension)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::extensions::AdvancedExtension*>(
      &::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline ::substrait::extensions::AdvancedExtension* SetRel::release_advanced_extension() {
  // @@protoc_insertion_point(field_release:substrait.SetRel.advanced_extension)
  
  ::substrait::extensions::AdvancedExtension* temp = advanced_extension_;
  advanced_extension_ = NULL;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* SetRel::mutable_advanced_extension() {
  
  if (advanced_extension_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::extensions::AdvancedExtension>(GetArenaNoVirtual());
    advanced_extension_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.SetRel.advanced_extension)
  return advanced_extension_;
}
inline void SetRel::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(advanced_extension_);
  }
  if (advanced_extension) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      advanced_extension = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, advanced_extension, submessage_arena);
    }
    
  } else {
    
  }
  advanced_extension_ = advanced_extension;
  // @@protoc_insertion_point(field_set_allocated:substrait.SetRel.advanced_extension)
}

// -------------------------------------------------------------------

// ExtensionSingleRel

// .substrait.RelCommon common = 1;
inline bool ExtensionSingleRel::has_common() const {
  return this != internal_default_instance() && common_ != NULL;
}
inline void ExtensionSingleRel::clear_common() {
  if (GetArenaNoVirtual() == NULL && common_ != NULL) {
    delete common_;
  }
  common_ = NULL;
}
inline const ::substrait::RelCommon& ExtensionSingleRel::_internal_common() const {
  return *common_;
}
inline const ::substrait::RelCommon& ExtensionSingleRel::common() const {
  const ::substrait::RelCommon* p = common_;
  // @@protoc_insertion_point(field_get:substrait.ExtensionSingleRel.common)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::RelCommon*>(
      &::substrait::_RelCommon_default_instance_);
}
inline ::substrait::RelCommon* ExtensionSingleRel::release_common() {
  // @@protoc_insertion_point(field_release:substrait.ExtensionSingleRel.common)
  
  ::substrait::RelCommon* temp = common_;
  common_ = NULL;
  return temp;
}
inline ::substrait::RelCommon* ExtensionSingleRel::mutable_common() {
  
  if (common_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::RelCommon>(GetArenaNoVirtual());
    common_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.ExtensionSingleRel.common)
  return common_;
}
inline void ExtensionSingleRel::set_allocated_common(::substrait::RelCommon* common) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete common_;
  }
  if (common) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      common = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, common, submessage_arena);
    }
    
  } else {
    
  }
  common_ = common;
  // @@protoc_insertion_point(field_set_allocated:substrait.ExtensionSingleRel.common)
}

// .substrait.Rel input = 2;
inline bool ExtensionSingleRel::has_input() const {
  return this != internal_default_instance() && input_ != NULL;
}
inline void ExtensionSingleRel::clear_input() {
  if (GetArenaNoVirtual() == NULL && input_ != NULL) {
    delete input_;
  }
  input_ = NULL;
}
inline const ::substrait::Rel& ExtensionSingleRel::_internal_input() const {
  return *input_;
}
inline const ::substrait::Rel& ExtensionSingleRel::input() const {
  const ::substrait::Rel* p = input_;
  // @@protoc_insertion_point(field_get:substrait.ExtensionSingleRel.input)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Rel*>(
      &::substrait::_Rel_default_instance_);
}
inline ::substrait::Rel* ExtensionSingleRel::release_input() {
  // @@protoc_insertion_point(field_release:substrait.ExtensionSingleRel.input)
  
  ::substrait::Rel* temp = input_;
  input_ = NULL;
  return temp;
}
inline ::substrait::Rel* ExtensionSingleRel::mutable_input() {
  
  if (input_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Rel>(GetArenaNoVirtual());
    input_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.ExtensionSingleRel.input)
  return input_;
}
inline void ExtensionSingleRel::set_allocated_input(::substrait::Rel* input) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete input_;
  }
  if (input) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      input = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, input, submessage_arena);
    }
    
  } else {
    
  }
  input_ = input;
  // @@protoc_insertion_point(field_set_allocated:substrait.ExtensionSingleRel.input)
}

// .google.protobuf.Any detail = 3;
inline bool ExtensionSingleRel::has_detail() const {
  return this != internal_default_instance() && detail_ != NULL;
}
inline const ::google::protobuf::Any& ExtensionSingleRel::_internal_detail() const {
  return *detail_;
}
inline const ::google::protobuf::Any& ExtensionSingleRel::detail() const {
  const ::google::protobuf::Any* p = detail_;
  // @@protoc_insertion_point(field_get:substrait.ExtensionSingleRel.detail)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Any*>(
      &::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* ExtensionSingleRel::release_detail() {
  // @@protoc_insertion_point(field_release:substrait.ExtensionSingleRel.detail)
  
  ::google::protobuf::Any* temp = detail_;
  detail_ = NULL;
  return temp;
}
inline ::google::protobuf::Any* ExtensionSingleRel::mutable_detail() {
  
  if (detail_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArenaNoVirtual());
    detail_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.ExtensionSingleRel.detail)
  return detail_;
}
inline void ExtensionSingleRel::set_allocated_detail(::google::protobuf::Any* detail) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(detail_);
  }
  if (detail) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      detail = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, detail, submessage_arena);
    }
    
  } else {
    
  }
  detail_ = detail;
  // @@protoc_insertion_point(field_set_allocated:substrait.ExtensionSingleRel.detail)
}

// -------------------------------------------------------------------

// ExtensionLeafRel

// .substrait.RelCommon common = 1;
inline bool ExtensionLeafRel::has_common() const {
  return this != internal_default_instance() && common_ != NULL;
}
inline void ExtensionLeafRel::clear_common() {
  if (GetArenaNoVirtual() == NULL && common_ != NULL) {
    delete common_;
  }
  common_ = NULL;
}
inline const ::substrait::RelCommon& ExtensionLeafRel::_internal_common() const {
  return *common_;
}
inline const ::substrait::RelCommon& ExtensionLeafRel::common() const {
  const ::substrait::RelCommon* p = common_;
  // @@protoc_insertion_point(field_get:substrait.ExtensionLeafRel.common)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::RelCommon*>(
      &::substrait::_RelCommon_default_instance_);
}
inline ::substrait::RelCommon* ExtensionLeafRel::release_common() {
  // @@protoc_insertion_point(field_release:substrait.ExtensionLeafRel.common)
  
  ::substrait::RelCommon* temp = common_;
  common_ = NULL;
  return temp;
}
inline ::substrait::RelCommon* ExtensionLeafRel::mutable_common() {
  
  if (common_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::RelCommon>(GetArenaNoVirtual());
    common_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.ExtensionLeafRel.common)
  return common_;
}
inline void ExtensionLeafRel::set_allocated_common(::substrait::RelCommon* common) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete common_;
  }
  if (common) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      common = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, common, submessage_arena);
    }
    
  } else {
    
  }
  common_ = common;
  // @@protoc_insertion_point(field_set_allocated:substrait.ExtensionLeafRel.common)
}

// .google.protobuf.Any detail = 2;
inline bool ExtensionLeafRel::has_detail() const {
  return this != internal_default_instance() && detail_ != NULL;
}
inline const ::google::protobuf::Any& ExtensionLeafRel::_internal_detail() const {
  return *detail_;
}
inline const ::google::protobuf::Any& ExtensionLeafRel::detail() const {
  const ::google::protobuf::Any* p = detail_;
  // @@protoc_insertion_point(field_get:substrait.ExtensionLeafRel.detail)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Any*>(
      &::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* ExtensionLeafRel::release_detail() {
  // @@protoc_insertion_point(field_release:substrait.ExtensionLeafRel.detail)
  
  ::google::protobuf::Any* temp = detail_;
  detail_ = NULL;
  return temp;
}
inline ::google::protobuf::Any* ExtensionLeafRel::mutable_detail() {
  
  if (detail_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArenaNoVirtual());
    detail_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.ExtensionLeafRel.detail)
  return detail_;
}
inline void ExtensionLeafRel::set_allocated_detail(::google::protobuf::Any* detail) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(detail_);
  }
  if (detail) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      detail = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, detail, submessage_arena);
    }
    
  } else {
    
  }
  detail_ = detail;
  // @@protoc_insertion_point(field_set_allocated:substrait.ExtensionLeafRel.detail)
}

// -------------------------------------------------------------------

// ExtensionMultiRel

// .substrait.RelCommon common = 1;
inline bool ExtensionMultiRel::has_common() const {
  return this != internal_default_instance() && common_ != NULL;
}
inline void ExtensionMultiRel::clear_common() {
  if (GetArenaNoVirtual() == NULL && common_ != NULL) {
    delete common_;
  }
  common_ = NULL;
}
inline const ::substrait::RelCommon& ExtensionMultiRel::_internal_common() const {
  return *common_;
}
inline const ::substrait::RelCommon& ExtensionMultiRel::common() const {
  const ::substrait::RelCommon* p = common_;
  // @@protoc_insertion_point(field_get:substrait.ExtensionMultiRel.common)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::RelCommon*>(
      &::substrait::_RelCommon_default_instance_);
}
inline ::substrait::RelCommon* ExtensionMultiRel::release_common() {
  // @@protoc_insertion_point(field_release:substrait.ExtensionMultiRel.common)
  
  ::substrait::RelCommon* temp = common_;
  common_ = NULL;
  return temp;
}
inline ::substrait::RelCommon* ExtensionMultiRel::mutable_common() {
  
  if (common_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::RelCommon>(GetArenaNoVirtual());
    common_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.ExtensionMultiRel.common)
  return common_;
}
inline void ExtensionMultiRel::set_allocated_common(::substrait::RelCommon* common) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete common_;
  }
  if (common) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      common = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, common, submessage_arena);
    }
    
  } else {
    
  }
  common_ = common;
  // @@protoc_insertion_point(field_set_allocated:substrait.ExtensionMultiRel.common)
}

// repeated .substrait.Rel inputs = 2;
inline int ExtensionMultiRel::inputs_size() const {
  return inputs_.size();
}
inline void ExtensionMultiRel::clear_inputs() {
  inputs_.Clear();
}
inline ::substrait::Rel* ExtensionMultiRel::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.ExtensionMultiRel.inputs)
  return inputs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::Rel >*
ExtensionMultiRel::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:substrait.ExtensionMultiRel.inputs)
  return &inputs_;
}
inline const ::substrait::Rel& ExtensionMultiRel::inputs(int index) const {
  // @@protoc_insertion_point(field_get:substrait.ExtensionMultiRel.inputs)
  return inputs_.Get(index);
}
inline ::substrait::Rel* ExtensionMultiRel::add_inputs() {
  // @@protoc_insertion_point(field_add:substrait.ExtensionMultiRel.inputs)
  return inputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::Rel >&
ExtensionMultiRel::inputs() const {
  // @@protoc_insertion_point(field_list:substrait.ExtensionMultiRel.inputs)
  return inputs_;
}

// .google.protobuf.Any detail = 3;
inline bool ExtensionMultiRel::has_detail() const {
  return this != internal_default_instance() && detail_ != NULL;
}
inline const ::google::protobuf::Any& ExtensionMultiRel::_internal_detail() const {
  return *detail_;
}
inline const ::google::protobuf::Any& ExtensionMultiRel::detail() const {
  const ::google::protobuf::Any* p = detail_;
  // @@protoc_insertion_point(field_get:substrait.ExtensionMultiRel.detail)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Any*>(
      &::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* ExtensionMultiRel::release_detail() {
  // @@protoc_insertion_point(field_release:substrait.ExtensionMultiRel.detail)
  
  ::google::protobuf::Any* temp = detail_;
  detail_ = NULL;
  return temp;
}
inline ::google::protobuf::Any* ExtensionMultiRel::mutable_detail() {
  
  if (detail_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArenaNoVirtual());
    detail_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.ExtensionMultiRel.detail)
  return detail_;
}
inline void ExtensionMultiRel::set_allocated_detail(::google::protobuf::Any* detail) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(detail_);
  }
  if (detail) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      detail = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, detail, submessage_arena);
    }
    
  } else {
    
  }
  detail_ = detail;
  // @@protoc_insertion_point(field_set_allocated:substrait.ExtensionMultiRel.detail)
}

// -------------------------------------------------------------------

// ExchangeRel_ScatterFields

// repeated .substrait.Expression.FieldReference fields = 1;
inline int ExchangeRel_ScatterFields::fields_size() const {
  return fields_.size();
}
inline void ExchangeRel_ScatterFields::clear_fields() {
  fields_.Clear();
}
inline ::substrait::Expression_FieldReference* ExchangeRel_ScatterFields::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.ExchangeRel.ScatterFields.fields)
  return fields_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::Expression_FieldReference >*
ExchangeRel_ScatterFields::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:substrait.ExchangeRel.ScatterFields.fields)
  return &fields_;
}
inline const ::substrait::Expression_FieldReference& ExchangeRel_ScatterFields::fields(int index) const {
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.ScatterFields.fields)
  return fields_.Get(index);
}
inline ::substrait::Expression_FieldReference* ExchangeRel_ScatterFields::add_fields() {
  // @@protoc_insertion_point(field_add:substrait.ExchangeRel.ScatterFields.fields)
  return fields_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::Expression_FieldReference >&
ExchangeRel_ScatterFields::fields() const {
  // @@protoc_insertion_point(field_list:substrait.ExchangeRel.ScatterFields.fields)
  return fields_;
}

// -------------------------------------------------------------------

// ExchangeRel_SingleBucketExpression

// .substrait.Expression expression = 1;
inline bool ExchangeRel_SingleBucketExpression::has_expression() const {
  return this != internal_default_instance() && expression_ != NULL;
}
inline void ExchangeRel_SingleBucketExpression::clear_expression() {
  if (GetArenaNoVirtual() == NULL && expression_ != NULL) {
    delete expression_;
  }
  expression_ = NULL;
}
inline const ::substrait::Expression& ExchangeRel_SingleBucketExpression::_internal_expression() const {
  return *expression_;
}
inline const ::substrait::Expression& ExchangeRel_SingleBucketExpression::expression() const {
  const ::substrait::Expression* p = expression_;
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.SingleBucketExpression.expression)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression*>(
      &::substrait::_Expression_default_instance_);
}
inline ::substrait::Expression* ExchangeRel_SingleBucketExpression::release_expression() {
  // @@protoc_insertion_point(field_release:substrait.ExchangeRel.SingleBucketExpression.expression)
  
  ::substrait::Expression* temp = expression_;
  expression_ = NULL;
  return temp;
}
inline ::substrait::Expression* ExchangeRel_SingleBucketExpression::mutable_expression() {
  
  if (expression_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression>(GetArenaNoVirtual());
    expression_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.ExchangeRel.SingleBucketExpression.expression)
  return expression_;
}
inline void ExchangeRel_SingleBucketExpression::set_allocated_expression(::substrait::Expression* expression) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete expression_;
  }
  if (expression) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      expression = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, expression, submessage_arena);
    }
    
  } else {
    
  }
  expression_ = expression;
  // @@protoc_insertion_point(field_set_allocated:substrait.ExchangeRel.SingleBucketExpression.expression)
}

// -------------------------------------------------------------------

// ExchangeRel_MultiBucketExpression

// .substrait.Expression expression = 1;
inline bool ExchangeRel_MultiBucketExpression::has_expression() const {
  return this != internal_default_instance() && expression_ != NULL;
}
inline void ExchangeRel_MultiBucketExpression::clear_expression() {
  if (GetArenaNoVirtual() == NULL && expression_ != NULL) {
    delete expression_;
  }
  expression_ = NULL;
}
inline const ::substrait::Expression& ExchangeRel_MultiBucketExpression::_internal_expression() const {
  return *expression_;
}
inline const ::substrait::Expression& ExchangeRel_MultiBucketExpression::expression() const {
  const ::substrait::Expression* p = expression_;
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.MultiBucketExpression.expression)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression*>(
      &::substrait::_Expression_default_instance_);
}
inline ::substrait::Expression* ExchangeRel_MultiBucketExpression::release_expression() {
  // @@protoc_insertion_point(field_release:substrait.ExchangeRel.MultiBucketExpression.expression)
  
  ::substrait::Expression* temp = expression_;
  expression_ = NULL;
  return temp;
}
inline ::substrait::Expression* ExchangeRel_MultiBucketExpression::mutable_expression() {
  
  if (expression_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression>(GetArenaNoVirtual());
    expression_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.ExchangeRel.MultiBucketExpression.expression)
  return expression_;
}
inline void ExchangeRel_MultiBucketExpression::set_allocated_expression(::substrait::Expression* expression) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete expression_;
  }
  if (expression) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      expression = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, expression, submessage_arena);
    }
    
  } else {
    
  }
  expression_ = expression;
  // @@protoc_insertion_point(field_set_allocated:substrait.ExchangeRel.MultiBucketExpression.expression)
}

// bool constrained_to_count = 2;
inline void ExchangeRel_MultiBucketExpression::clear_constrained_to_count() {
  constrained_to_count_ = false;
}
inline bool ExchangeRel_MultiBucketExpression::constrained_to_count() const {
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.MultiBucketExpression.constrained_to_count)
  return constrained_to_count_;
}
inline void ExchangeRel_MultiBucketExpression::set_constrained_to_count(bool value) {
  
  constrained_to_count_ = value;
  // @@protoc_insertion_point(field_set:substrait.ExchangeRel.MultiBucketExpression.constrained_to_count)
}

// -------------------------------------------------------------------

// ExchangeRel_Broadcast

// -------------------------------------------------------------------

// ExchangeRel_RoundRobin

// bool exact = 1;
inline void ExchangeRel_RoundRobin::clear_exact() {
  exact_ = false;
}
inline bool ExchangeRel_RoundRobin::exact() const {
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.RoundRobin.exact)
  return exact_;
}
inline void ExchangeRel_RoundRobin::set_exact(bool value) {
  
  exact_ = value;
  // @@protoc_insertion_point(field_set:substrait.ExchangeRel.RoundRobin.exact)
}

// -------------------------------------------------------------------

// ExchangeRel_ExchangeTarget

// repeated int32 partition_id = 1;
inline int ExchangeRel_ExchangeTarget::partition_id_size() const {
  return partition_id_.size();
}
inline void ExchangeRel_ExchangeTarget::clear_partition_id() {
  partition_id_.Clear();
}
inline ::google::protobuf::int32 ExchangeRel_ExchangeTarget::partition_id(int index) const {
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.ExchangeTarget.partition_id)
  return partition_id_.Get(index);
}
inline void ExchangeRel_ExchangeTarget::set_partition_id(int index, ::google::protobuf::int32 value) {
  partition_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:substrait.ExchangeRel.ExchangeTarget.partition_id)
}
inline void ExchangeRel_ExchangeTarget::add_partition_id(::google::protobuf::int32 value) {
  partition_id_.Add(value);
  // @@protoc_insertion_point(field_add:substrait.ExchangeRel.ExchangeTarget.partition_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ExchangeRel_ExchangeTarget::partition_id() const {
  // @@protoc_insertion_point(field_list:substrait.ExchangeRel.ExchangeTarget.partition_id)
  return partition_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ExchangeRel_ExchangeTarget::mutable_partition_id() {
  // @@protoc_insertion_point(field_mutable_list:substrait.ExchangeRel.ExchangeTarget.partition_id)
  return &partition_id_;
}

// string uri = 2;
inline bool ExchangeRel_ExchangeTarget::has_uri() const {
  return target_type_case() == kUri;
}
inline void ExchangeRel_ExchangeTarget::set_has_uri() {
  _oneof_case_[0] = kUri;
}
inline void ExchangeRel_ExchangeTarget::clear_uri() {
  if (has_uri()) {
    target_type_.uri_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_target_type();
  }
}
inline const ::std::string& ExchangeRel_ExchangeTarget::uri() const {
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.ExchangeTarget.uri)
  if (has_uri()) {
    return target_type_.uri_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void ExchangeRel_ExchangeTarget::set_uri(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:substrait.ExchangeRel.ExchangeTarget.uri)
  if (!has_uri()) {
    clear_target_type();
    set_has_uri();
    target_type_.uri_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  target_type_.uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:substrait.ExchangeRel.ExchangeTarget.uri)
}
#if LANG_CXX11
inline void ExchangeRel_ExchangeTarget::set_uri(::std::string&& value) {
  // @@protoc_insertion_point(field_set:substrait.ExchangeRel.ExchangeTarget.uri)
  if (!has_uri()) {
    clear_target_type();
    set_has_uri();
    target_type_.uri_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  target_type_.uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:substrait.ExchangeRel.ExchangeTarget.uri)
}
#endif
inline void ExchangeRel_ExchangeTarget::set_uri(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_uri()) {
    clear_target_type();
    set_has_uri();
    target_type_.uri_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  target_type_.uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:substrait.ExchangeRel.ExchangeTarget.uri)
}
inline void ExchangeRel_ExchangeTarget::set_uri(const char* value, size_t size) {
  if (!has_uri()) {
    clear_target_type();
    set_has_uri();
    target_type_.uri_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  target_type_.uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:substrait.ExchangeRel.ExchangeTarget.uri)
}
inline ::std::string* ExchangeRel_ExchangeTarget::mutable_uri() {
  if (!has_uri()) {
    clear_target_type();
    set_has_uri();
    target_type_.uri_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:substrait.ExchangeRel.ExchangeTarget.uri)
  return target_type_.uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExchangeRel_ExchangeTarget::release_uri() {
  // @@protoc_insertion_point(field_release:substrait.ExchangeRel.ExchangeTarget.uri)
  if (has_uri()) {
    clear_has_target_type();
    return target_type_.uri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void ExchangeRel_ExchangeTarget::set_allocated_uri(::std::string* uri) {
  if (!has_uri()) {
    target_type_.uri_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_target_type();
  if (uri != NULL) {
    set_has_uri();
    target_type_.uri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uri);
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.ExchangeRel.ExchangeTarget.uri)
}

// .google.protobuf.Any extended = 3;
inline bool ExchangeRel_ExchangeTarget::has_extended() const {
  return target_type_case() == kExtended;
}
inline void ExchangeRel_ExchangeTarget::set_has_extended() {
  _oneof_case_[0] = kExtended;
}
inline const ::google::protobuf::Any& ExchangeRel_ExchangeTarget::_internal_extended() const {
  return *target_type_.extended_;
}
inline ::google::protobuf::Any* ExchangeRel_ExchangeTarget::release_extended() {
  // @@protoc_insertion_point(field_release:substrait.ExchangeRel.ExchangeTarget.extended)
  if (has_extended()) {
    clear_has_target_type();
      ::google::protobuf::Any* temp = target_type_.extended_;
    target_type_.extended_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::google::protobuf::Any& ExchangeRel_ExchangeTarget::extended() const {
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.ExchangeTarget.extended)
  return has_extended()
      ? *target_type_.extended_
      : *reinterpret_cast< ::google::protobuf::Any*>(&::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* ExchangeRel_ExchangeTarget::mutable_extended() {
  if (!has_extended()) {
    clear_target_type();
    set_has_extended();
    target_type_.extended_ = CreateMaybeMessage< ::google::protobuf::Any >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.ExchangeRel.ExchangeTarget.extended)
  return target_type_.extended_;
}

inline bool ExchangeRel_ExchangeTarget::has_target_type() const {
  return target_type_case() != TARGET_TYPE_NOT_SET;
}
inline void ExchangeRel_ExchangeTarget::clear_has_target_type() {
  _oneof_case_[0] = TARGET_TYPE_NOT_SET;
}
inline ExchangeRel_ExchangeTarget::TargetTypeCase ExchangeRel_ExchangeTarget::target_type_case() const {
  return ExchangeRel_ExchangeTarget::TargetTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ExchangeRel

// .substrait.RelCommon common = 1;
inline bool ExchangeRel::has_common() const {
  return this != internal_default_instance() && common_ != NULL;
}
inline void ExchangeRel::clear_common() {
  if (GetArenaNoVirtual() == NULL && common_ != NULL) {
    delete common_;
  }
  common_ = NULL;
}
inline const ::substrait::RelCommon& ExchangeRel::_internal_common() const {
  return *common_;
}
inline const ::substrait::RelCommon& ExchangeRel::common() const {
  const ::substrait::RelCommon* p = common_;
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.common)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::RelCommon*>(
      &::substrait::_RelCommon_default_instance_);
}
inline ::substrait::RelCommon* ExchangeRel::release_common() {
  // @@protoc_insertion_point(field_release:substrait.ExchangeRel.common)
  
  ::substrait::RelCommon* temp = common_;
  common_ = NULL;
  return temp;
}
inline ::substrait::RelCommon* ExchangeRel::mutable_common() {
  
  if (common_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::RelCommon>(GetArenaNoVirtual());
    common_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.ExchangeRel.common)
  return common_;
}
inline void ExchangeRel::set_allocated_common(::substrait::RelCommon* common) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete common_;
  }
  if (common) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      common = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, common, submessage_arena);
    }
    
  } else {
    
  }
  common_ = common;
  // @@protoc_insertion_point(field_set_allocated:substrait.ExchangeRel.common)
}

// .substrait.Rel input = 2;
inline bool ExchangeRel::has_input() const {
  return this != internal_default_instance() && input_ != NULL;
}
inline void ExchangeRel::clear_input() {
  if (GetArenaNoVirtual() == NULL && input_ != NULL) {
    delete input_;
  }
  input_ = NULL;
}
inline const ::substrait::Rel& ExchangeRel::_internal_input() const {
  return *input_;
}
inline const ::substrait::Rel& ExchangeRel::input() const {
  const ::substrait::Rel* p = input_;
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.input)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Rel*>(
      &::substrait::_Rel_default_instance_);
}
inline ::substrait::Rel* ExchangeRel::release_input() {
  // @@protoc_insertion_point(field_release:substrait.ExchangeRel.input)
  
  ::substrait::Rel* temp = input_;
  input_ = NULL;
  return temp;
}
inline ::substrait::Rel* ExchangeRel::mutable_input() {
  
  if (input_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Rel>(GetArenaNoVirtual());
    input_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.ExchangeRel.input)
  return input_;
}
inline void ExchangeRel::set_allocated_input(::substrait::Rel* input) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete input_;
  }
  if (input) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      input = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, input, submessage_arena);
    }
    
  } else {
    
  }
  input_ = input;
  // @@protoc_insertion_point(field_set_allocated:substrait.ExchangeRel.input)
}

// int32 partition_count = 3;
inline void ExchangeRel::clear_partition_count() {
  partition_count_ = 0;
}
inline ::google::protobuf::int32 ExchangeRel::partition_count() const {
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.partition_count)
  return partition_count_;
}
inline void ExchangeRel::set_partition_count(::google::protobuf::int32 value) {
  
  partition_count_ = value;
  // @@protoc_insertion_point(field_set:substrait.ExchangeRel.partition_count)
}

// repeated .substrait.ExchangeRel.ExchangeTarget targets = 4;
inline int ExchangeRel::targets_size() const {
  return targets_.size();
}
inline void ExchangeRel::clear_targets() {
  targets_.Clear();
}
inline ::substrait::ExchangeRel_ExchangeTarget* ExchangeRel::mutable_targets(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.ExchangeRel.targets)
  return targets_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::ExchangeRel_ExchangeTarget >*
ExchangeRel::mutable_targets() {
  // @@protoc_insertion_point(field_mutable_list:substrait.ExchangeRel.targets)
  return &targets_;
}
inline const ::substrait::ExchangeRel_ExchangeTarget& ExchangeRel::targets(int index) const {
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.targets)
  return targets_.Get(index);
}
inline ::substrait::ExchangeRel_ExchangeTarget* ExchangeRel::add_targets() {
  // @@protoc_insertion_point(field_add:substrait.ExchangeRel.targets)
  return targets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::ExchangeRel_ExchangeTarget >&
ExchangeRel::targets() const {
  // @@protoc_insertion_point(field_list:substrait.ExchangeRel.targets)
  return targets_;
}

// .substrait.ExchangeRel.ScatterFields scatter_by_fields = 5;
inline bool ExchangeRel::has_scatter_by_fields() const {
  return exchange_kind_case() == kScatterByFields;
}
inline void ExchangeRel::set_has_scatter_by_fields() {
  _oneof_case_[0] = kScatterByFields;
}
inline void ExchangeRel::clear_scatter_by_fields() {
  if (has_scatter_by_fields()) {
    delete exchange_kind_.scatter_by_fields_;
    clear_has_exchange_kind();
  }
}
inline const ::substrait::ExchangeRel_ScatterFields& ExchangeRel::_internal_scatter_by_fields() const {
  return *exchange_kind_.scatter_by_fields_;
}
inline ::substrait::ExchangeRel_ScatterFields* ExchangeRel::release_scatter_by_fields() {
  // @@protoc_insertion_point(field_release:substrait.ExchangeRel.scatter_by_fields)
  if (has_scatter_by_fields()) {
    clear_has_exchange_kind();
      ::substrait::ExchangeRel_ScatterFields* temp = exchange_kind_.scatter_by_fields_;
    exchange_kind_.scatter_by_fields_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::ExchangeRel_ScatterFields& ExchangeRel::scatter_by_fields() const {
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.scatter_by_fields)
  return has_scatter_by_fields()
      ? *exchange_kind_.scatter_by_fields_
      : *reinterpret_cast< ::substrait::ExchangeRel_ScatterFields*>(&::substrait::_ExchangeRel_ScatterFields_default_instance_);
}
inline ::substrait::ExchangeRel_ScatterFields* ExchangeRel::mutable_scatter_by_fields() {
  if (!has_scatter_by_fields()) {
    clear_exchange_kind();
    set_has_scatter_by_fields();
    exchange_kind_.scatter_by_fields_ = CreateMaybeMessage< ::substrait::ExchangeRel_ScatterFields >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.ExchangeRel.scatter_by_fields)
  return exchange_kind_.scatter_by_fields_;
}

// .substrait.ExchangeRel.SingleBucketExpression single_target = 6;
inline bool ExchangeRel::has_single_target() const {
  return exchange_kind_case() == kSingleTarget;
}
inline void ExchangeRel::set_has_single_target() {
  _oneof_case_[0] = kSingleTarget;
}
inline void ExchangeRel::clear_single_target() {
  if (has_single_target()) {
    delete exchange_kind_.single_target_;
    clear_has_exchange_kind();
  }
}
inline const ::substrait::ExchangeRel_SingleBucketExpression& ExchangeRel::_internal_single_target() const {
  return *exchange_kind_.single_target_;
}
inline ::substrait::ExchangeRel_SingleBucketExpression* ExchangeRel::release_single_target() {
  // @@protoc_insertion_point(field_release:substrait.ExchangeRel.single_target)
  if (has_single_target()) {
    clear_has_exchange_kind();
      ::substrait::ExchangeRel_SingleBucketExpression* temp = exchange_kind_.single_target_;
    exchange_kind_.single_target_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::ExchangeRel_SingleBucketExpression& ExchangeRel::single_target() const {
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.single_target)
  return has_single_target()
      ? *exchange_kind_.single_target_
      : *reinterpret_cast< ::substrait::ExchangeRel_SingleBucketExpression*>(&::substrait::_ExchangeRel_SingleBucketExpression_default_instance_);
}
inline ::substrait::ExchangeRel_SingleBucketExpression* ExchangeRel::mutable_single_target() {
  if (!has_single_target()) {
    clear_exchange_kind();
    set_has_single_target();
    exchange_kind_.single_target_ = CreateMaybeMessage< ::substrait::ExchangeRel_SingleBucketExpression >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.ExchangeRel.single_target)
  return exchange_kind_.single_target_;
}

// .substrait.ExchangeRel.MultiBucketExpression multi_target = 7;
inline bool ExchangeRel::has_multi_target() const {
  return exchange_kind_case() == kMultiTarget;
}
inline void ExchangeRel::set_has_multi_target() {
  _oneof_case_[0] = kMultiTarget;
}
inline void ExchangeRel::clear_multi_target() {
  if (has_multi_target()) {
    delete exchange_kind_.multi_target_;
    clear_has_exchange_kind();
  }
}
inline const ::substrait::ExchangeRel_MultiBucketExpression& ExchangeRel::_internal_multi_target() const {
  return *exchange_kind_.multi_target_;
}
inline ::substrait::ExchangeRel_MultiBucketExpression* ExchangeRel::release_multi_target() {
  // @@protoc_insertion_point(field_release:substrait.ExchangeRel.multi_target)
  if (has_multi_target()) {
    clear_has_exchange_kind();
      ::substrait::ExchangeRel_MultiBucketExpression* temp = exchange_kind_.multi_target_;
    exchange_kind_.multi_target_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::ExchangeRel_MultiBucketExpression& ExchangeRel::multi_target() const {
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.multi_target)
  return has_multi_target()
      ? *exchange_kind_.multi_target_
      : *reinterpret_cast< ::substrait::ExchangeRel_MultiBucketExpression*>(&::substrait::_ExchangeRel_MultiBucketExpression_default_instance_);
}
inline ::substrait::ExchangeRel_MultiBucketExpression* ExchangeRel::mutable_multi_target() {
  if (!has_multi_target()) {
    clear_exchange_kind();
    set_has_multi_target();
    exchange_kind_.multi_target_ = CreateMaybeMessage< ::substrait::ExchangeRel_MultiBucketExpression >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.ExchangeRel.multi_target)
  return exchange_kind_.multi_target_;
}

// .substrait.ExchangeRel.RoundRobin round_robin = 8;
inline bool ExchangeRel::has_round_robin() const {
  return exchange_kind_case() == kRoundRobin;
}
inline void ExchangeRel::set_has_round_robin() {
  _oneof_case_[0] = kRoundRobin;
}
inline void ExchangeRel::clear_round_robin() {
  if (has_round_robin()) {
    delete exchange_kind_.round_robin_;
    clear_has_exchange_kind();
  }
}
inline const ::substrait::ExchangeRel_RoundRobin& ExchangeRel::_internal_round_robin() const {
  return *exchange_kind_.round_robin_;
}
inline ::substrait::ExchangeRel_RoundRobin* ExchangeRel::release_round_robin() {
  // @@protoc_insertion_point(field_release:substrait.ExchangeRel.round_robin)
  if (has_round_robin()) {
    clear_has_exchange_kind();
      ::substrait::ExchangeRel_RoundRobin* temp = exchange_kind_.round_robin_;
    exchange_kind_.round_robin_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::ExchangeRel_RoundRobin& ExchangeRel::round_robin() const {
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.round_robin)
  return has_round_robin()
      ? *exchange_kind_.round_robin_
      : *reinterpret_cast< ::substrait::ExchangeRel_RoundRobin*>(&::substrait::_ExchangeRel_RoundRobin_default_instance_);
}
inline ::substrait::ExchangeRel_RoundRobin* ExchangeRel::mutable_round_robin() {
  if (!has_round_robin()) {
    clear_exchange_kind();
    set_has_round_robin();
    exchange_kind_.round_robin_ = CreateMaybeMessage< ::substrait::ExchangeRel_RoundRobin >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.ExchangeRel.round_robin)
  return exchange_kind_.round_robin_;
}

// .substrait.ExchangeRel.Broadcast broadcast = 9;
inline bool ExchangeRel::has_broadcast() const {
  return exchange_kind_case() == kBroadcast;
}
inline void ExchangeRel::set_has_broadcast() {
  _oneof_case_[0] = kBroadcast;
}
inline void ExchangeRel::clear_broadcast() {
  if (has_broadcast()) {
    delete exchange_kind_.broadcast_;
    clear_has_exchange_kind();
  }
}
inline const ::substrait::ExchangeRel_Broadcast& ExchangeRel::_internal_broadcast() const {
  return *exchange_kind_.broadcast_;
}
inline ::substrait::ExchangeRel_Broadcast* ExchangeRel::release_broadcast() {
  // @@protoc_insertion_point(field_release:substrait.ExchangeRel.broadcast)
  if (has_broadcast()) {
    clear_has_exchange_kind();
      ::substrait::ExchangeRel_Broadcast* temp = exchange_kind_.broadcast_;
    exchange_kind_.broadcast_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::ExchangeRel_Broadcast& ExchangeRel::broadcast() const {
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.broadcast)
  return has_broadcast()
      ? *exchange_kind_.broadcast_
      : *reinterpret_cast< ::substrait::ExchangeRel_Broadcast*>(&::substrait::_ExchangeRel_Broadcast_default_instance_);
}
inline ::substrait::ExchangeRel_Broadcast* ExchangeRel::mutable_broadcast() {
  if (!has_broadcast()) {
    clear_exchange_kind();
    set_has_broadcast();
    exchange_kind_.broadcast_ = CreateMaybeMessage< ::substrait::ExchangeRel_Broadcast >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.ExchangeRel.broadcast)
  return exchange_kind_.broadcast_;
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool ExchangeRel::has_advanced_extension() const {
  return this != internal_default_instance() && advanced_extension_ != NULL;
}
inline const ::substrait::extensions::AdvancedExtension& ExchangeRel::_internal_advanced_extension() const {
  return *advanced_extension_;
}
inline const ::substrait::extensions::AdvancedExtension& ExchangeRel::advanced_extension() const {
  const ::substrait::extensions::AdvancedExtension* p = advanced_extension_;
  // @@protoc_insertion_point(field_get:substrait.ExchangeRel.advanced_extension)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::extensions::AdvancedExtension*>(
      &::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline ::substrait::extensions::AdvancedExtension* ExchangeRel::release_advanced_extension() {
  // @@protoc_insertion_point(field_release:substrait.ExchangeRel.advanced_extension)
  
  ::substrait::extensions::AdvancedExtension* temp = advanced_extension_;
  advanced_extension_ = NULL;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* ExchangeRel::mutable_advanced_extension() {
  
  if (advanced_extension_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::extensions::AdvancedExtension>(GetArenaNoVirtual());
    advanced_extension_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.ExchangeRel.advanced_extension)
  return advanced_extension_;
}
inline void ExchangeRel::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(advanced_extension_);
  }
  if (advanced_extension) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      advanced_extension = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, advanced_extension, submessage_arena);
    }
    
  } else {
    
  }
  advanced_extension_ = advanced_extension;
  // @@protoc_insertion_point(field_set_allocated:substrait.ExchangeRel.advanced_extension)
}

inline bool ExchangeRel::has_exchange_kind() const {
  return exchange_kind_case() != EXCHANGE_KIND_NOT_SET;
}
inline void ExchangeRel::clear_has_exchange_kind() {
  _oneof_case_[0] = EXCHANGE_KIND_NOT_SET;
}
inline ExchangeRel::ExchangeKindCase ExchangeRel::exchange_kind_case() const {
  return ExchangeRel::ExchangeKindCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RelRoot

// .substrait.Rel input = 1;
inline bool RelRoot::has_input() const {
  return this != internal_default_instance() && input_ != NULL;
}
inline void RelRoot::clear_input() {
  if (GetArenaNoVirtual() == NULL && input_ != NULL) {
    delete input_;
  }
  input_ = NULL;
}
inline const ::substrait::Rel& RelRoot::_internal_input() const {
  return *input_;
}
inline const ::substrait::Rel& RelRoot::input() const {
  const ::substrait::Rel* p = input_;
  // @@protoc_insertion_point(field_get:substrait.RelRoot.input)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Rel*>(
      &::substrait::_Rel_default_instance_);
}
inline ::substrait::Rel* RelRoot::release_input() {
  // @@protoc_insertion_point(field_release:substrait.RelRoot.input)
  
  ::substrait::Rel* temp = input_;
  input_ = NULL;
  return temp;
}
inline ::substrait::Rel* RelRoot::mutable_input() {
  
  if (input_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Rel>(GetArenaNoVirtual());
    input_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.RelRoot.input)
  return input_;
}
inline void RelRoot::set_allocated_input(::substrait::Rel* input) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete input_;
  }
  if (input) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      input = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, input, submessage_arena);
    }
    
  } else {
    
  }
  input_ = input;
  // @@protoc_insertion_point(field_set_allocated:substrait.RelRoot.input)
}

// repeated string names = 2;
inline int RelRoot::names_size() const {
  return names_.size();
}
inline void RelRoot::clear_names() {
  names_.Clear();
}
inline const ::std::string& RelRoot::names(int index) const {
  // @@protoc_insertion_point(field_get:substrait.RelRoot.names)
  return names_.Get(index);
}
inline ::std::string* RelRoot::mutable_names(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.RelRoot.names)
  return names_.Mutable(index);
}
inline void RelRoot::set_names(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:substrait.RelRoot.names)
  names_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RelRoot::set_names(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:substrait.RelRoot.names)
  names_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RelRoot::set_names(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:substrait.RelRoot.names)
}
inline void RelRoot::set_names(int index, const char* value, size_t size) {
  names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:substrait.RelRoot.names)
}
inline ::std::string* RelRoot::add_names() {
  // @@protoc_insertion_point(field_add_mutable:substrait.RelRoot.names)
  return names_.Add();
}
inline void RelRoot::add_names(const ::std::string& value) {
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:substrait.RelRoot.names)
}
#if LANG_CXX11
inline void RelRoot::add_names(::std::string&& value) {
  names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:substrait.RelRoot.names)
}
#endif
inline void RelRoot::add_names(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:substrait.RelRoot.names)
}
inline void RelRoot::add_names(const char* value, size_t size) {
  names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:substrait.RelRoot.names)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RelRoot::names() const {
  // @@protoc_insertion_point(field_list:substrait.RelRoot.names)
  return names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RelRoot::mutable_names() {
  // @@protoc_insertion_point(field_mutable_list:substrait.RelRoot.names)
  return &names_;
}

// -------------------------------------------------------------------

// Rel

// .substrait.ReadRel read = 1;
inline bool Rel::has_read() const {
  return rel_type_case() == kRead;
}
inline void Rel::set_has_read() {
  _oneof_case_[0] = kRead;
}
inline void Rel::clear_read() {
  if (has_read()) {
    delete rel_type_.read_;
    clear_has_rel_type();
  }
}
inline const ::substrait::ReadRel& Rel::_internal_read() const {
  return *rel_type_.read_;
}
inline ::substrait::ReadRel* Rel::release_read() {
  // @@protoc_insertion_point(field_release:substrait.Rel.read)
  if (has_read()) {
    clear_has_rel_type();
      ::substrait::ReadRel* temp = rel_type_.read_;
    rel_type_.read_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::ReadRel& Rel::read() const {
  // @@protoc_insertion_point(field_get:substrait.Rel.read)
  return has_read()
      ? *rel_type_.read_
      : *reinterpret_cast< ::substrait::ReadRel*>(&::substrait::_ReadRel_default_instance_);
}
inline ::substrait::ReadRel* Rel::mutable_read() {
  if (!has_read()) {
    clear_rel_type();
    set_has_read();
    rel_type_.read_ = CreateMaybeMessage< ::substrait::ReadRel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Rel.read)
  return rel_type_.read_;
}

// .substrait.FilterRel filter = 2;
inline bool Rel::has_filter() const {
  return rel_type_case() == kFilter;
}
inline void Rel::set_has_filter() {
  _oneof_case_[0] = kFilter;
}
inline void Rel::clear_filter() {
  if (has_filter()) {
    delete rel_type_.filter_;
    clear_has_rel_type();
  }
}
inline const ::substrait::FilterRel& Rel::_internal_filter() const {
  return *rel_type_.filter_;
}
inline ::substrait::FilterRel* Rel::release_filter() {
  // @@protoc_insertion_point(field_release:substrait.Rel.filter)
  if (has_filter()) {
    clear_has_rel_type();
      ::substrait::FilterRel* temp = rel_type_.filter_;
    rel_type_.filter_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::FilterRel& Rel::filter() const {
  // @@protoc_insertion_point(field_get:substrait.Rel.filter)
  return has_filter()
      ? *rel_type_.filter_
      : *reinterpret_cast< ::substrait::FilterRel*>(&::substrait::_FilterRel_default_instance_);
}
inline ::substrait::FilterRel* Rel::mutable_filter() {
  if (!has_filter()) {
    clear_rel_type();
    set_has_filter();
    rel_type_.filter_ = CreateMaybeMessage< ::substrait::FilterRel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Rel.filter)
  return rel_type_.filter_;
}

// .substrait.FetchRel fetch = 3;
inline bool Rel::has_fetch() const {
  return rel_type_case() == kFetch;
}
inline void Rel::set_has_fetch() {
  _oneof_case_[0] = kFetch;
}
inline void Rel::clear_fetch() {
  if (has_fetch()) {
    delete rel_type_.fetch_;
    clear_has_rel_type();
  }
}
inline const ::substrait::FetchRel& Rel::_internal_fetch() const {
  return *rel_type_.fetch_;
}
inline ::substrait::FetchRel* Rel::release_fetch() {
  // @@protoc_insertion_point(field_release:substrait.Rel.fetch)
  if (has_fetch()) {
    clear_has_rel_type();
      ::substrait::FetchRel* temp = rel_type_.fetch_;
    rel_type_.fetch_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::FetchRel& Rel::fetch() const {
  // @@protoc_insertion_point(field_get:substrait.Rel.fetch)
  return has_fetch()
      ? *rel_type_.fetch_
      : *reinterpret_cast< ::substrait::FetchRel*>(&::substrait::_FetchRel_default_instance_);
}
inline ::substrait::FetchRel* Rel::mutable_fetch() {
  if (!has_fetch()) {
    clear_rel_type();
    set_has_fetch();
    rel_type_.fetch_ = CreateMaybeMessage< ::substrait::FetchRel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Rel.fetch)
  return rel_type_.fetch_;
}

// .substrait.AggregateRel aggregate = 4;
inline bool Rel::has_aggregate() const {
  return rel_type_case() == kAggregate;
}
inline void Rel::set_has_aggregate() {
  _oneof_case_[0] = kAggregate;
}
inline void Rel::clear_aggregate() {
  if (has_aggregate()) {
    delete rel_type_.aggregate_;
    clear_has_rel_type();
  }
}
inline const ::substrait::AggregateRel& Rel::_internal_aggregate() const {
  return *rel_type_.aggregate_;
}
inline ::substrait::AggregateRel* Rel::release_aggregate() {
  // @@protoc_insertion_point(field_release:substrait.Rel.aggregate)
  if (has_aggregate()) {
    clear_has_rel_type();
      ::substrait::AggregateRel* temp = rel_type_.aggregate_;
    rel_type_.aggregate_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::AggregateRel& Rel::aggregate() const {
  // @@protoc_insertion_point(field_get:substrait.Rel.aggregate)
  return has_aggregate()
      ? *rel_type_.aggregate_
      : *reinterpret_cast< ::substrait::AggregateRel*>(&::substrait::_AggregateRel_default_instance_);
}
inline ::substrait::AggregateRel* Rel::mutable_aggregate() {
  if (!has_aggregate()) {
    clear_rel_type();
    set_has_aggregate();
    rel_type_.aggregate_ = CreateMaybeMessage< ::substrait::AggregateRel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Rel.aggregate)
  return rel_type_.aggregate_;
}

// .substrait.SortRel sort = 5;
inline bool Rel::has_sort() const {
  return rel_type_case() == kSort;
}
inline void Rel::set_has_sort() {
  _oneof_case_[0] = kSort;
}
inline void Rel::clear_sort() {
  if (has_sort()) {
    delete rel_type_.sort_;
    clear_has_rel_type();
  }
}
inline const ::substrait::SortRel& Rel::_internal_sort() const {
  return *rel_type_.sort_;
}
inline ::substrait::SortRel* Rel::release_sort() {
  // @@protoc_insertion_point(field_release:substrait.Rel.sort)
  if (has_sort()) {
    clear_has_rel_type();
      ::substrait::SortRel* temp = rel_type_.sort_;
    rel_type_.sort_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::SortRel& Rel::sort() const {
  // @@protoc_insertion_point(field_get:substrait.Rel.sort)
  return has_sort()
      ? *rel_type_.sort_
      : *reinterpret_cast< ::substrait::SortRel*>(&::substrait::_SortRel_default_instance_);
}
inline ::substrait::SortRel* Rel::mutable_sort() {
  if (!has_sort()) {
    clear_rel_type();
    set_has_sort();
    rel_type_.sort_ = CreateMaybeMessage< ::substrait::SortRel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Rel.sort)
  return rel_type_.sort_;
}

// .substrait.JoinRel join = 6;
inline bool Rel::has_join() const {
  return rel_type_case() == kJoin;
}
inline void Rel::set_has_join() {
  _oneof_case_[0] = kJoin;
}
inline void Rel::clear_join() {
  if (has_join()) {
    delete rel_type_.join_;
    clear_has_rel_type();
  }
}
inline const ::substrait::JoinRel& Rel::_internal_join() const {
  return *rel_type_.join_;
}
inline ::substrait::JoinRel* Rel::release_join() {
  // @@protoc_insertion_point(field_release:substrait.Rel.join)
  if (has_join()) {
    clear_has_rel_type();
      ::substrait::JoinRel* temp = rel_type_.join_;
    rel_type_.join_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::JoinRel& Rel::join() const {
  // @@protoc_insertion_point(field_get:substrait.Rel.join)
  return has_join()
      ? *rel_type_.join_
      : *reinterpret_cast< ::substrait::JoinRel*>(&::substrait::_JoinRel_default_instance_);
}
inline ::substrait::JoinRel* Rel::mutable_join() {
  if (!has_join()) {
    clear_rel_type();
    set_has_join();
    rel_type_.join_ = CreateMaybeMessage< ::substrait::JoinRel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Rel.join)
  return rel_type_.join_;
}

// .substrait.ProjectRel project = 7;
inline bool Rel::has_project() const {
  return rel_type_case() == kProject;
}
inline void Rel::set_has_project() {
  _oneof_case_[0] = kProject;
}
inline void Rel::clear_project() {
  if (has_project()) {
    delete rel_type_.project_;
    clear_has_rel_type();
  }
}
inline const ::substrait::ProjectRel& Rel::_internal_project() const {
  return *rel_type_.project_;
}
inline ::substrait::ProjectRel* Rel::release_project() {
  // @@protoc_insertion_point(field_release:substrait.Rel.project)
  if (has_project()) {
    clear_has_rel_type();
      ::substrait::ProjectRel* temp = rel_type_.project_;
    rel_type_.project_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::ProjectRel& Rel::project() const {
  // @@protoc_insertion_point(field_get:substrait.Rel.project)
  return has_project()
      ? *rel_type_.project_
      : *reinterpret_cast< ::substrait::ProjectRel*>(&::substrait::_ProjectRel_default_instance_);
}
inline ::substrait::ProjectRel* Rel::mutable_project() {
  if (!has_project()) {
    clear_rel_type();
    set_has_project();
    rel_type_.project_ = CreateMaybeMessage< ::substrait::ProjectRel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Rel.project)
  return rel_type_.project_;
}

// .substrait.SetRel set = 8;
inline bool Rel::has_set() const {
  return rel_type_case() == kSet;
}
inline void Rel::set_has_set() {
  _oneof_case_[0] = kSet;
}
inline void Rel::clear_set() {
  if (has_set()) {
    delete rel_type_.set_;
    clear_has_rel_type();
  }
}
inline const ::substrait::SetRel& Rel::_internal_set() const {
  return *rel_type_.set_;
}
inline ::substrait::SetRel* Rel::release_set() {
  // @@protoc_insertion_point(field_release:substrait.Rel.set)
  if (has_set()) {
    clear_has_rel_type();
      ::substrait::SetRel* temp = rel_type_.set_;
    rel_type_.set_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::SetRel& Rel::set() const {
  // @@protoc_insertion_point(field_get:substrait.Rel.set)
  return has_set()
      ? *rel_type_.set_
      : *reinterpret_cast< ::substrait::SetRel*>(&::substrait::_SetRel_default_instance_);
}
inline ::substrait::SetRel* Rel::mutable_set() {
  if (!has_set()) {
    clear_rel_type();
    set_has_set();
    rel_type_.set_ = CreateMaybeMessage< ::substrait::SetRel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Rel.set)
  return rel_type_.set_;
}

// .substrait.ExtensionSingleRel extension_single = 9;
inline bool Rel::has_extension_single() const {
  return rel_type_case() == kExtensionSingle;
}
inline void Rel::set_has_extension_single() {
  _oneof_case_[0] = kExtensionSingle;
}
inline void Rel::clear_extension_single() {
  if (has_extension_single()) {
    delete rel_type_.extension_single_;
    clear_has_rel_type();
  }
}
inline const ::substrait::ExtensionSingleRel& Rel::_internal_extension_single() const {
  return *rel_type_.extension_single_;
}
inline ::substrait::ExtensionSingleRel* Rel::release_extension_single() {
  // @@protoc_insertion_point(field_release:substrait.Rel.extension_single)
  if (has_extension_single()) {
    clear_has_rel_type();
      ::substrait::ExtensionSingleRel* temp = rel_type_.extension_single_;
    rel_type_.extension_single_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::ExtensionSingleRel& Rel::extension_single() const {
  // @@protoc_insertion_point(field_get:substrait.Rel.extension_single)
  return has_extension_single()
      ? *rel_type_.extension_single_
      : *reinterpret_cast< ::substrait::ExtensionSingleRel*>(&::substrait::_ExtensionSingleRel_default_instance_);
}
inline ::substrait::ExtensionSingleRel* Rel::mutable_extension_single() {
  if (!has_extension_single()) {
    clear_rel_type();
    set_has_extension_single();
    rel_type_.extension_single_ = CreateMaybeMessage< ::substrait::ExtensionSingleRel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Rel.extension_single)
  return rel_type_.extension_single_;
}

// .substrait.ExtensionMultiRel extension_multi = 10;
inline bool Rel::has_extension_multi() const {
  return rel_type_case() == kExtensionMulti;
}
inline void Rel::set_has_extension_multi() {
  _oneof_case_[0] = kExtensionMulti;
}
inline void Rel::clear_extension_multi() {
  if (has_extension_multi()) {
    delete rel_type_.extension_multi_;
    clear_has_rel_type();
  }
}
inline const ::substrait::ExtensionMultiRel& Rel::_internal_extension_multi() const {
  return *rel_type_.extension_multi_;
}
inline ::substrait::ExtensionMultiRel* Rel::release_extension_multi() {
  // @@protoc_insertion_point(field_release:substrait.Rel.extension_multi)
  if (has_extension_multi()) {
    clear_has_rel_type();
      ::substrait::ExtensionMultiRel* temp = rel_type_.extension_multi_;
    rel_type_.extension_multi_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::ExtensionMultiRel& Rel::extension_multi() const {
  // @@protoc_insertion_point(field_get:substrait.Rel.extension_multi)
  return has_extension_multi()
      ? *rel_type_.extension_multi_
      : *reinterpret_cast< ::substrait::ExtensionMultiRel*>(&::substrait::_ExtensionMultiRel_default_instance_);
}
inline ::substrait::ExtensionMultiRel* Rel::mutable_extension_multi() {
  if (!has_extension_multi()) {
    clear_rel_type();
    set_has_extension_multi();
    rel_type_.extension_multi_ = CreateMaybeMessage< ::substrait::ExtensionMultiRel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Rel.extension_multi)
  return rel_type_.extension_multi_;
}

// .substrait.ExtensionLeafRel extension_leaf = 11;
inline bool Rel::has_extension_leaf() const {
  return rel_type_case() == kExtensionLeaf;
}
inline void Rel::set_has_extension_leaf() {
  _oneof_case_[0] = kExtensionLeaf;
}
inline void Rel::clear_extension_leaf() {
  if (has_extension_leaf()) {
    delete rel_type_.extension_leaf_;
    clear_has_rel_type();
  }
}
inline const ::substrait::ExtensionLeafRel& Rel::_internal_extension_leaf() const {
  return *rel_type_.extension_leaf_;
}
inline ::substrait::ExtensionLeafRel* Rel::release_extension_leaf() {
  // @@protoc_insertion_point(field_release:substrait.Rel.extension_leaf)
  if (has_extension_leaf()) {
    clear_has_rel_type();
      ::substrait::ExtensionLeafRel* temp = rel_type_.extension_leaf_;
    rel_type_.extension_leaf_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::ExtensionLeafRel& Rel::extension_leaf() const {
  // @@protoc_insertion_point(field_get:substrait.Rel.extension_leaf)
  return has_extension_leaf()
      ? *rel_type_.extension_leaf_
      : *reinterpret_cast< ::substrait::ExtensionLeafRel*>(&::substrait::_ExtensionLeafRel_default_instance_);
}
inline ::substrait::ExtensionLeafRel* Rel::mutable_extension_leaf() {
  if (!has_extension_leaf()) {
    clear_rel_type();
    set_has_extension_leaf();
    rel_type_.extension_leaf_ = CreateMaybeMessage< ::substrait::ExtensionLeafRel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Rel.extension_leaf)
  return rel_type_.extension_leaf_;
}

// .substrait.CrossRel cross = 12;
inline bool Rel::has_cross() const {
  return rel_type_case() == kCross;
}
inline void Rel::set_has_cross() {
  _oneof_case_[0] = kCross;
}
inline void Rel::clear_cross() {
  if (has_cross()) {
    delete rel_type_.cross_;
    clear_has_rel_type();
  }
}
inline const ::substrait::CrossRel& Rel::_internal_cross() const {
  return *rel_type_.cross_;
}
inline ::substrait::CrossRel* Rel::release_cross() {
  // @@protoc_insertion_point(field_release:substrait.Rel.cross)
  if (has_cross()) {
    clear_has_rel_type();
      ::substrait::CrossRel* temp = rel_type_.cross_;
    rel_type_.cross_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::CrossRel& Rel::cross() const {
  // @@protoc_insertion_point(field_get:substrait.Rel.cross)
  return has_cross()
      ? *rel_type_.cross_
      : *reinterpret_cast< ::substrait::CrossRel*>(&::substrait::_CrossRel_default_instance_);
}
inline ::substrait::CrossRel* Rel::mutable_cross() {
  if (!has_cross()) {
    clear_rel_type();
    set_has_cross();
    rel_type_.cross_ = CreateMaybeMessage< ::substrait::CrossRel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Rel.cross)
  return rel_type_.cross_;
}

// .substrait.HashJoinRel hash_join = 13;
inline bool Rel::has_hash_join() const {
  return rel_type_case() == kHashJoin;
}
inline void Rel::set_has_hash_join() {
  _oneof_case_[0] = kHashJoin;
}
inline void Rel::clear_hash_join() {
  if (has_hash_join()) {
    delete rel_type_.hash_join_;
    clear_has_rel_type();
  }
}
inline const ::substrait::HashJoinRel& Rel::_internal_hash_join() const {
  return *rel_type_.hash_join_;
}
inline ::substrait::HashJoinRel* Rel::release_hash_join() {
  // @@protoc_insertion_point(field_release:substrait.Rel.hash_join)
  if (has_hash_join()) {
    clear_has_rel_type();
      ::substrait::HashJoinRel* temp = rel_type_.hash_join_;
    rel_type_.hash_join_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::HashJoinRel& Rel::hash_join() const {
  // @@protoc_insertion_point(field_get:substrait.Rel.hash_join)
  return has_hash_join()
      ? *rel_type_.hash_join_
      : *reinterpret_cast< ::substrait::HashJoinRel*>(&::substrait::_HashJoinRel_default_instance_);
}
inline ::substrait::HashJoinRel* Rel::mutable_hash_join() {
  if (!has_hash_join()) {
    clear_rel_type();
    set_has_hash_join();
    rel_type_.hash_join_ = CreateMaybeMessage< ::substrait::HashJoinRel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Rel.hash_join)
  return rel_type_.hash_join_;
}

// .substrait.MergeJoinRel merge_join = 14;
inline bool Rel::has_merge_join() const {
  return rel_type_case() == kMergeJoin;
}
inline void Rel::set_has_merge_join() {
  _oneof_case_[0] = kMergeJoin;
}
inline void Rel::clear_merge_join() {
  if (has_merge_join()) {
    delete rel_type_.merge_join_;
    clear_has_rel_type();
  }
}
inline const ::substrait::MergeJoinRel& Rel::_internal_merge_join() const {
  return *rel_type_.merge_join_;
}
inline ::substrait::MergeJoinRel* Rel::release_merge_join() {
  // @@protoc_insertion_point(field_release:substrait.Rel.merge_join)
  if (has_merge_join()) {
    clear_has_rel_type();
      ::substrait::MergeJoinRel* temp = rel_type_.merge_join_;
    rel_type_.merge_join_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::MergeJoinRel& Rel::merge_join() const {
  // @@protoc_insertion_point(field_get:substrait.Rel.merge_join)
  return has_merge_join()
      ? *rel_type_.merge_join_
      : *reinterpret_cast< ::substrait::MergeJoinRel*>(&::substrait::_MergeJoinRel_default_instance_);
}
inline ::substrait::MergeJoinRel* Rel::mutable_merge_join() {
  if (!has_merge_join()) {
    clear_rel_type();
    set_has_merge_join();
    rel_type_.merge_join_ = CreateMaybeMessage< ::substrait::MergeJoinRel >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Rel.merge_join)
  return rel_type_.merge_join_;
}

inline bool Rel::has_rel_type() const {
  return rel_type_case() != REL_TYPE_NOT_SET;
}
inline void Rel::clear_has_rel_type() {
  _oneof_case_[0] = REL_TYPE_NOT_SET;
}
inline Rel::RelTypeCase Rel::rel_type_case() const {
  return Rel::RelTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// NamedObjectWrite

// repeated string names = 1;
inline int NamedObjectWrite::names_size() const {
  return names_.size();
}
inline void NamedObjectWrite::clear_names() {
  names_.Clear();
}
inline const ::std::string& NamedObjectWrite::names(int index) const {
  // @@protoc_insertion_point(field_get:substrait.NamedObjectWrite.names)
  return names_.Get(index);
}
inline ::std::string* NamedObjectWrite::mutable_names(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.NamedObjectWrite.names)
  return names_.Mutable(index);
}
inline void NamedObjectWrite::set_names(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:substrait.NamedObjectWrite.names)
  names_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void NamedObjectWrite::set_names(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:substrait.NamedObjectWrite.names)
  names_.Mutable(index)->assign(std::move(value));
}
#endif
inline void NamedObjectWrite::set_names(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:substrait.NamedObjectWrite.names)
}
inline void NamedObjectWrite::set_names(int index, const char* value, size_t size) {
  names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:substrait.NamedObjectWrite.names)
}
inline ::std::string* NamedObjectWrite::add_names() {
  // @@protoc_insertion_point(field_add_mutable:substrait.NamedObjectWrite.names)
  return names_.Add();
}
inline void NamedObjectWrite::add_names(const ::std::string& value) {
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:substrait.NamedObjectWrite.names)
}
#if LANG_CXX11
inline void NamedObjectWrite::add_names(::std::string&& value) {
  names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:substrait.NamedObjectWrite.names)
}
#endif
inline void NamedObjectWrite::add_names(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:substrait.NamedObjectWrite.names)
}
inline void NamedObjectWrite::add_names(const char* value, size_t size) {
  names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:substrait.NamedObjectWrite.names)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NamedObjectWrite::names() const {
  // @@protoc_insertion_point(field_list:substrait.NamedObjectWrite.names)
  return names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NamedObjectWrite::mutable_names() {
  // @@protoc_insertion_point(field_mutable_list:substrait.NamedObjectWrite.names)
  return &names_;
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool NamedObjectWrite::has_advanced_extension() const {
  return this != internal_default_instance() && advanced_extension_ != NULL;
}
inline const ::substrait::extensions::AdvancedExtension& NamedObjectWrite::_internal_advanced_extension() const {
  return *advanced_extension_;
}
inline const ::substrait::extensions::AdvancedExtension& NamedObjectWrite::advanced_extension() const {
  const ::substrait::extensions::AdvancedExtension* p = advanced_extension_;
  // @@protoc_insertion_point(field_get:substrait.NamedObjectWrite.advanced_extension)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::extensions::AdvancedExtension*>(
      &::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline ::substrait::extensions::AdvancedExtension* NamedObjectWrite::release_advanced_extension() {
  // @@protoc_insertion_point(field_release:substrait.NamedObjectWrite.advanced_extension)
  
  ::substrait::extensions::AdvancedExtension* temp = advanced_extension_;
  advanced_extension_ = NULL;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* NamedObjectWrite::mutable_advanced_extension() {
  
  if (advanced_extension_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::extensions::AdvancedExtension>(GetArenaNoVirtual());
    advanced_extension_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.NamedObjectWrite.advanced_extension)
  return advanced_extension_;
}
inline void NamedObjectWrite::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(advanced_extension_);
  }
  if (advanced_extension) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      advanced_extension = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, advanced_extension, submessage_arena);
    }
    
  } else {
    
  }
  advanced_extension_ = advanced_extension;
  // @@protoc_insertion_point(field_set_allocated:substrait.NamedObjectWrite.advanced_extension)
}

// -------------------------------------------------------------------

// ExtensionObject

// .google.protobuf.Any detail = 1;
inline bool ExtensionObject::has_detail() const {
  return this != internal_default_instance() && detail_ != NULL;
}
inline const ::google::protobuf::Any& ExtensionObject::_internal_detail() const {
  return *detail_;
}
inline const ::google::protobuf::Any& ExtensionObject::detail() const {
  const ::google::protobuf::Any* p = detail_;
  // @@protoc_insertion_point(field_get:substrait.ExtensionObject.detail)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Any*>(
      &::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* ExtensionObject::release_detail() {
  // @@protoc_insertion_point(field_release:substrait.ExtensionObject.detail)
  
  ::google::protobuf::Any* temp = detail_;
  detail_ = NULL;
  return temp;
}
inline ::google::protobuf::Any* ExtensionObject::mutable_detail() {
  
  if (detail_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArenaNoVirtual());
    detail_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.ExtensionObject.detail)
  return detail_;
}
inline void ExtensionObject::set_allocated_detail(::google::protobuf::Any* detail) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(detail_);
  }
  if (detail) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      detail = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, detail, submessage_arena);
    }
    
  } else {
    
  }
  detail_ = detail;
  // @@protoc_insertion_point(field_set_allocated:substrait.ExtensionObject.detail)
}

// -------------------------------------------------------------------

// DdlRel

// .substrait.NamedObjectWrite named_object = 1;
inline bool DdlRel::has_named_object() const {
  return write_type_case() == kNamedObject;
}
inline void DdlRel::set_has_named_object() {
  _oneof_case_[0] = kNamedObject;
}
inline void DdlRel::clear_named_object() {
  if (has_named_object()) {
    delete write_type_.named_object_;
    clear_has_write_type();
  }
}
inline const ::substrait::NamedObjectWrite& DdlRel::_internal_named_object() const {
  return *write_type_.named_object_;
}
inline ::substrait::NamedObjectWrite* DdlRel::release_named_object() {
  // @@protoc_insertion_point(field_release:substrait.DdlRel.named_object)
  if (has_named_object()) {
    clear_has_write_type();
      ::substrait::NamedObjectWrite* temp = write_type_.named_object_;
    write_type_.named_object_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::NamedObjectWrite& DdlRel::named_object() const {
  // @@protoc_insertion_point(field_get:substrait.DdlRel.named_object)
  return has_named_object()
      ? *write_type_.named_object_
      : *reinterpret_cast< ::substrait::NamedObjectWrite*>(&::substrait::_NamedObjectWrite_default_instance_);
}
inline ::substrait::NamedObjectWrite* DdlRel::mutable_named_object() {
  if (!has_named_object()) {
    clear_write_type();
    set_has_named_object();
    write_type_.named_object_ = CreateMaybeMessage< ::substrait::NamedObjectWrite >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.DdlRel.named_object)
  return write_type_.named_object_;
}

// .substrait.ExtensionObject extension_object = 2;
inline bool DdlRel::has_extension_object() const {
  return write_type_case() == kExtensionObject;
}
inline void DdlRel::set_has_extension_object() {
  _oneof_case_[0] = kExtensionObject;
}
inline void DdlRel::clear_extension_object() {
  if (has_extension_object()) {
    delete write_type_.extension_object_;
    clear_has_write_type();
  }
}
inline const ::substrait::ExtensionObject& DdlRel::_internal_extension_object() const {
  return *write_type_.extension_object_;
}
inline ::substrait::ExtensionObject* DdlRel::release_extension_object() {
  // @@protoc_insertion_point(field_release:substrait.DdlRel.extension_object)
  if (has_extension_object()) {
    clear_has_write_type();
      ::substrait::ExtensionObject* temp = write_type_.extension_object_;
    write_type_.extension_object_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::ExtensionObject& DdlRel::extension_object() const {
  // @@protoc_insertion_point(field_get:substrait.DdlRel.extension_object)
  return has_extension_object()
      ? *write_type_.extension_object_
      : *reinterpret_cast< ::substrait::ExtensionObject*>(&::substrait::_ExtensionObject_default_instance_);
}
inline ::substrait::ExtensionObject* DdlRel::mutable_extension_object() {
  if (!has_extension_object()) {
    clear_write_type();
    set_has_extension_object();
    write_type_.extension_object_ = CreateMaybeMessage< ::substrait::ExtensionObject >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.DdlRel.extension_object)
  return write_type_.extension_object_;
}

// .substrait.NamedStruct table_schema = 3;
inline bool DdlRel::has_table_schema() const {
  return this != internal_default_instance() && table_schema_ != NULL;
}
inline const ::substrait::NamedStruct& DdlRel::_internal_table_schema() const {
  return *table_schema_;
}
inline const ::substrait::NamedStruct& DdlRel::table_schema() const {
  const ::substrait::NamedStruct* p = table_schema_;
  // @@protoc_insertion_point(field_get:substrait.DdlRel.table_schema)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::NamedStruct*>(
      &::substrait::_NamedStruct_default_instance_);
}
inline ::substrait::NamedStruct* DdlRel::release_table_schema() {
  // @@protoc_insertion_point(field_release:substrait.DdlRel.table_schema)
  
  ::substrait::NamedStruct* temp = table_schema_;
  table_schema_ = NULL;
  return temp;
}
inline ::substrait::NamedStruct* DdlRel::mutable_table_schema() {
  
  if (table_schema_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::NamedStruct>(GetArenaNoVirtual());
    table_schema_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.DdlRel.table_schema)
  return table_schema_;
}
inline void DdlRel::set_allocated_table_schema(::substrait::NamedStruct* table_schema) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(table_schema_);
  }
  if (table_schema) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      table_schema = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, table_schema, submessage_arena);
    }
    
  } else {
    
  }
  table_schema_ = table_schema;
  // @@protoc_insertion_point(field_set_allocated:substrait.DdlRel.table_schema)
}

// .substrait.Expression.Literal.Struct table_defaults = 4;
inline bool DdlRel::has_table_defaults() const {
  return this != internal_default_instance() && table_defaults_ != NULL;
}
inline void DdlRel::clear_table_defaults() {
  if (GetArenaNoVirtual() == NULL && table_defaults_ != NULL) {
    delete table_defaults_;
  }
  table_defaults_ = NULL;
}
inline const ::substrait::Expression_Literal_Struct& DdlRel::_internal_table_defaults() const {
  return *table_defaults_;
}
inline const ::substrait::Expression_Literal_Struct& DdlRel::table_defaults() const {
  const ::substrait::Expression_Literal_Struct* p = table_defaults_;
  // @@protoc_insertion_point(field_get:substrait.DdlRel.table_defaults)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression_Literal_Struct*>(
      &::substrait::_Expression_Literal_Struct_default_instance_);
}
inline ::substrait::Expression_Literal_Struct* DdlRel::release_table_defaults() {
  // @@protoc_insertion_point(field_release:substrait.DdlRel.table_defaults)
  
  ::substrait::Expression_Literal_Struct* temp = table_defaults_;
  table_defaults_ = NULL;
  return temp;
}
inline ::substrait::Expression_Literal_Struct* DdlRel::mutable_table_defaults() {
  
  if (table_defaults_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression_Literal_Struct>(GetArenaNoVirtual());
    table_defaults_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.DdlRel.table_defaults)
  return table_defaults_;
}
inline void DdlRel::set_allocated_table_defaults(::substrait::Expression_Literal_Struct* table_defaults) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete table_defaults_;
  }
  if (table_defaults) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      table_defaults = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, table_defaults, submessage_arena);
    }
    
  } else {
    
  }
  table_defaults_ = table_defaults;
  // @@protoc_insertion_point(field_set_allocated:substrait.DdlRel.table_defaults)
}

// .substrait.DdlRel.DdlObject object = 5;
inline void DdlRel::clear_object() {
  object_ = 0;
}
inline ::substrait::DdlRel_DdlObject DdlRel::object() const {
  // @@protoc_insertion_point(field_get:substrait.DdlRel.object)
  return static_cast< ::substrait::DdlRel_DdlObject >(object_);
}
inline void DdlRel::set_object(::substrait::DdlRel_DdlObject value) {
  
  object_ = value;
  // @@protoc_insertion_point(field_set:substrait.DdlRel.object)
}

// .substrait.DdlRel.DdlOp op = 6;
inline void DdlRel::clear_op() {
  op_ = 0;
}
inline ::substrait::DdlRel_DdlOp DdlRel::op() const {
  // @@protoc_insertion_point(field_get:substrait.DdlRel.op)
  return static_cast< ::substrait::DdlRel_DdlOp >(op_);
}
inline void DdlRel::set_op(::substrait::DdlRel_DdlOp value) {
  
  op_ = value;
  // @@protoc_insertion_point(field_set:substrait.DdlRel.op)
}

// .substrait.Rel view_definition = 7;
inline bool DdlRel::has_view_definition() const {
  return this != internal_default_instance() && view_definition_ != NULL;
}
inline void DdlRel::clear_view_definition() {
  if (GetArenaNoVirtual() == NULL && view_definition_ != NULL) {
    delete view_definition_;
  }
  view_definition_ = NULL;
}
inline const ::substrait::Rel& DdlRel::_internal_view_definition() const {
  return *view_definition_;
}
inline const ::substrait::Rel& DdlRel::view_definition() const {
  const ::substrait::Rel* p = view_definition_;
  // @@protoc_insertion_point(field_get:substrait.DdlRel.view_definition)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Rel*>(
      &::substrait::_Rel_default_instance_);
}
inline ::substrait::Rel* DdlRel::release_view_definition() {
  // @@protoc_insertion_point(field_release:substrait.DdlRel.view_definition)
  
  ::substrait::Rel* temp = view_definition_;
  view_definition_ = NULL;
  return temp;
}
inline ::substrait::Rel* DdlRel::mutable_view_definition() {
  
  if (view_definition_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Rel>(GetArenaNoVirtual());
    view_definition_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.DdlRel.view_definition)
  return view_definition_;
}
inline void DdlRel::set_allocated_view_definition(::substrait::Rel* view_definition) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete view_definition_;
  }
  if (view_definition) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      view_definition = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, view_definition, submessage_arena);
    }
    
  } else {
    
  }
  view_definition_ = view_definition;
  // @@protoc_insertion_point(field_set_allocated:substrait.DdlRel.view_definition)
}

inline bool DdlRel::has_write_type() const {
  return write_type_case() != WRITE_TYPE_NOT_SET;
}
inline void DdlRel::clear_has_write_type() {
  _oneof_case_[0] = WRITE_TYPE_NOT_SET;
}
inline DdlRel::WriteTypeCase DdlRel::write_type_case() const {
  return DdlRel::WriteTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// WriteRel

// .substrait.NamedObjectWrite named_table = 1;
inline bool WriteRel::has_named_table() const {
  return write_type_case() == kNamedTable;
}
inline void WriteRel::set_has_named_table() {
  _oneof_case_[0] = kNamedTable;
}
inline void WriteRel::clear_named_table() {
  if (has_named_table()) {
    delete write_type_.named_table_;
    clear_has_write_type();
  }
}
inline const ::substrait::NamedObjectWrite& WriteRel::_internal_named_table() const {
  return *write_type_.named_table_;
}
inline ::substrait::NamedObjectWrite* WriteRel::release_named_table() {
  // @@protoc_insertion_point(field_release:substrait.WriteRel.named_table)
  if (has_named_table()) {
    clear_has_write_type();
      ::substrait::NamedObjectWrite* temp = write_type_.named_table_;
    write_type_.named_table_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::NamedObjectWrite& WriteRel::named_table() const {
  // @@protoc_insertion_point(field_get:substrait.WriteRel.named_table)
  return has_named_table()
      ? *write_type_.named_table_
      : *reinterpret_cast< ::substrait::NamedObjectWrite*>(&::substrait::_NamedObjectWrite_default_instance_);
}
inline ::substrait::NamedObjectWrite* WriteRel::mutable_named_table() {
  if (!has_named_table()) {
    clear_write_type();
    set_has_named_table();
    write_type_.named_table_ = CreateMaybeMessage< ::substrait::NamedObjectWrite >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.WriteRel.named_table)
  return write_type_.named_table_;
}

// .substrait.ExtensionObject extension_table = 2;
inline bool WriteRel::has_extension_table() const {
  return write_type_case() == kExtensionTable;
}
inline void WriteRel::set_has_extension_table() {
  _oneof_case_[0] = kExtensionTable;
}
inline void WriteRel::clear_extension_table() {
  if (has_extension_table()) {
    delete write_type_.extension_table_;
    clear_has_write_type();
  }
}
inline const ::substrait::ExtensionObject& WriteRel::_internal_extension_table() const {
  return *write_type_.extension_table_;
}
inline ::substrait::ExtensionObject* WriteRel::release_extension_table() {
  // @@protoc_insertion_point(field_release:substrait.WriteRel.extension_table)
  if (has_extension_table()) {
    clear_has_write_type();
      ::substrait::ExtensionObject* temp = write_type_.extension_table_;
    write_type_.extension_table_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::ExtensionObject& WriteRel::extension_table() const {
  // @@protoc_insertion_point(field_get:substrait.WriteRel.extension_table)
  return has_extension_table()
      ? *write_type_.extension_table_
      : *reinterpret_cast< ::substrait::ExtensionObject*>(&::substrait::_ExtensionObject_default_instance_);
}
inline ::substrait::ExtensionObject* WriteRel::mutable_extension_table() {
  if (!has_extension_table()) {
    clear_write_type();
    set_has_extension_table();
    write_type_.extension_table_ = CreateMaybeMessage< ::substrait::ExtensionObject >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.WriteRel.extension_table)
  return write_type_.extension_table_;
}

// .substrait.NamedStruct table_schema = 3;
inline bool WriteRel::has_table_schema() const {
  return this != internal_default_instance() && table_schema_ != NULL;
}
inline const ::substrait::NamedStruct& WriteRel::_internal_table_schema() const {
  return *table_schema_;
}
inline const ::substrait::NamedStruct& WriteRel::table_schema() const {
  const ::substrait::NamedStruct* p = table_schema_;
  // @@protoc_insertion_point(field_get:substrait.WriteRel.table_schema)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::NamedStruct*>(
      &::substrait::_NamedStruct_default_instance_);
}
inline ::substrait::NamedStruct* WriteRel::release_table_schema() {
  // @@protoc_insertion_point(field_release:substrait.WriteRel.table_schema)
  
  ::substrait::NamedStruct* temp = table_schema_;
  table_schema_ = NULL;
  return temp;
}
inline ::substrait::NamedStruct* WriteRel::mutable_table_schema() {
  
  if (table_schema_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::NamedStruct>(GetArenaNoVirtual());
    table_schema_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.WriteRel.table_schema)
  return table_schema_;
}
inline void WriteRel::set_allocated_table_schema(::substrait::NamedStruct* table_schema) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(table_schema_);
  }
  if (table_schema) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      table_schema = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, table_schema, submessage_arena);
    }
    
  } else {
    
  }
  table_schema_ = table_schema;
  // @@protoc_insertion_point(field_set_allocated:substrait.WriteRel.table_schema)
}

// .substrait.WriteRel.WriteOp op = 4;
inline void WriteRel::clear_op() {
  op_ = 0;
}
inline ::substrait::WriteRel_WriteOp WriteRel::op() const {
  // @@protoc_insertion_point(field_get:substrait.WriteRel.op)
  return static_cast< ::substrait::WriteRel_WriteOp >(op_);
}
inline void WriteRel::set_op(::substrait::WriteRel_WriteOp value) {
  
  op_ = value;
  // @@protoc_insertion_point(field_set:substrait.WriteRel.op)
}

// .substrait.Rel input = 5;
inline bool WriteRel::has_input() const {
  return this != internal_default_instance() && input_ != NULL;
}
inline void WriteRel::clear_input() {
  if (GetArenaNoVirtual() == NULL && input_ != NULL) {
    delete input_;
  }
  input_ = NULL;
}
inline const ::substrait::Rel& WriteRel::_internal_input() const {
  return *input_;
}
inline const ::substrait::Rel& WriteRel::input() const {
  const ::substrait::Rel* p = input_;
  // @@protoc_insertion_point(field_get:substrait.WriteRel.input)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Rel*>(
      &::substrait::_Rel_default_instance_);
}
inline ::substrait::Rel* WriteRel::release_input() {
  // @@protoc_insertion_point(field_release:substrait.WriteRel.input)
  
  ::substrait::Rel* temp = input_;
  input_ = NULL;
  return temp;
}
inline ::substrait::Rel* WriteRel::mutable_input() {
  
  if (input_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Rel>(GetArenaNoVirtual());
    input_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.WriteRel.input)
  return input_;
}
inline void WriteRel::set_allocated_input(::substrait::Rel* input) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete input_;
  }
  if (input) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      input = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, input, submessage_arena);
    }
    
  } else {
    
  }
  input_ = input;
  // @@protoc_insertion_point(field_set_allocated:substrait.WriteRel.input)
}

// .substrait.WriteRel.OutputMode output = 6;
inline void WriteRel::clear_output() {
  output_ = 0;
}
inline ::substrait::WriteRel_OutputMode WriteRel::output() const {
  // @@protoc_insertion_point(field_get:substrait.WriteRel.output)
  return static_cast< ::substrait::WriteRel_OutputMode >(output_);
}
inline void WriteRel::set_output(::substrait::WriteRel_OutputMode value) {
  
  output_ = value;
  // @@protoc_insertion_point(field_set:substrait.WriteRel.output)
}

inline bool WriteRel::has_write_type() const {
  return write_type_case() != WRITE_TYPE_NOT_SET;
}
inline void WriteRel::clear_has_write_type() {
  _oneof_case_[0] = WRITE_TYPE_NOT_SET;
}
inline WriteRel::WriteTypeCase WriteRel::write_type_case() const {
  return WriteRel::WriteTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// HashJoinRel

// .substrait.RelCommon common = 1;
inline bool HashJoinRel::has_common() const {
  return this != internal_default_instance() && common_ != NULL;
}
inline void HashJoinRel::clear_common() {
  if (GetArenaNoVirtual() == NULL && common_ != NULL) {
    delete common_;
  }
  common_ = NULL;
}
inline const ::substrait::RelCommon& HashJoinRel::_internal_common() const {
  return *common_;
}
inline const ::substrait::RelCommon& HashJoinRel::common() const {
  const ::substrait::RelCommon* p = common_;
  // @@protoc_insertion_point(field_get:substrait.HashJoinRel.common)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::RelCommon*>(
      &::substrait::_RelCommon_default_instance_);
}
inline ::substrait::RelCommon* HashJoinRel::release_common() {
  // @@protoc_insertion_point(field_release:substrait.HashJoinRel.common)
  
  ::substrait::RelCommon* temp = common_;
  common_ = NULL;
  return temp;
}
inline ::substrait::RelCommon* HashJoinRel::mutable_common() {
  
  if (common_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::RelCommon>(GetArenaNoVirtual());
    common_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.HashJoinRel.common)
  return common_;
}
inline void HashJoinRel::set_allocated_common(::substrait::RelCommon* common) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete common_;
  }
  if (common) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      common = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, common, submessage_arena);
    }
    
  } else {
    
  }
  common_ = common;
  // @@protoc_insertion_point(field_set_allocated:substrait.HashJoinRel.common)
}

// .substrait.Rel left = 2;
inline bool HashJoinRel::has_left() const {
  return this != internal_default_instance() && left_ != NULL;
}
inline void HashJoinRel::clear_left() {
  if (GetArenaNoVirtual() == NULL && left_ != NULL) {
    delete left_;
  }
  left_ = NULL;
}
inline const ::substrait::Rel& HashJoinRel::_internal_left() const {
  return *left_;
}
inline const ::substrait::Rel& HashJoinRel::left() const {
  const ::substrait::Rel* p = left_;
  // @@protoc_insertion_point(field_get:substrait.HashJoinRel.left)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Rel*>(
      &::substrait::_Rel_default_instance_);
}
inline ::substrait::Rel* HashJoinRel::release_left() {
  // @@protoc_insertion_point(field_release:substrait.HashJoinRel.left)
  
  ::substrait::Rel* temp = left_;
  left_ = NULL;
  return temp;
}
inline ::substrait::Rel* HashJoinRel::mutable_left() {
  
  if (left_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Rel>(GetArenaNoVirtual());
    left_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.HashJoinRel.left)
  return left_;
}
inline void HashJoinRel::set_allocated_left(::substrait::Rel* left) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete left_;
  }
  if (left) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      left = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, left, submessage_arena);
    }
    
  } else {
    
  }
  left_ = left;
  // @@protoc_insertion_point(field_set_allocated:substrait.HashJoinRel.left)
}

// .substrait.Rel right = 3;
inline bool HashJoinRel::has_right() const {
  return this != internal_default_instance() && right_ != NULL;
}
inline void HashJoinRel::clear_right() {
  if (GetArenaNoVirtual() == NULL && right_ != NULL) {
    delete right_;
  }
  right_ = NULL;
}
inline const ::substrait::Rel& HashJoinRel::_internal_right() const {
  return *right_;
}
inline const ::substrait::Rel& HashJoinRel::right() const {
  const ::substrait::Rel* p = right_;
  // @@protoc_insertion_point(field_get:substrait.HashJoinRel.right)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Rel*>(
      &::substrait::_Rel_default_instance_);
}
inline ::substrait::Rel* HashJoinRel::release_right() {
  // @@protoc_insertion_point(field_release:substrait.HashJoinRel.right)
  
  ::substrait::Rel* temp = right_;
  right_ = NULL;
  return temp;
}
inline ::substrait::Rel* HashJoinRel::mutable_right() {
  
  if (right_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Rel>(GetArenaNoVirtual());
    right_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.HashJoinRel.right)
  return right_;
}
inline void HashJoinRel::set_allocated_right(::substrait::Rel* right) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete right_;
  }
  if (right) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      right = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, right, submessage_arena);
    }
    
  } else {
    
  }
  right_ = right;
  // @@protoc_insertion_point(field_set_allocated:substrait.HashJoinRel.right)
}

// repeated .substrait.Expression.FieldReference left_keys = 4;
inline int HashJoinRel::left_keys_size() const {
  return left_keys_.size();
}
inline void HashJoinRel::clear_left_keys() {
  left_keys_.Clear();
}
inline ::substrait::Expression_FieldReference* HashJoinRel::mutable_left_keys(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.HashJoinRel.left_keys)
  return left_keys_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::Expression_FieldReference >*
HashJoinRel::mutable_left_keys() {
  // @@protoc_insertion_point(field_mutable_list:substrait.HashJoinRel.left_keys)
  return &left_keys_;
}
inline const ::substrait::Expression_FieldReference& HashJoinRel::left_keys(int index) const {
  // @@protoc_insertion_point(field_get:substrait.HashJoinRel.left_keys)
  return left_keys_.Get(index);
}
inline ::substrait::Expression_FieldReference* HashJoinRel::add_left_keys() {
  // @@protoc_insertion_point(field_add:substrait.HashJoinRel.left_keys)
  return left_keys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::Expression_FieldReference >&
HashJoinRel::left_keys() const {
  // @@protoc_insertion_point(field_list:substrait.HashJoinRel.left_keys)
  return left_keys_;
}

// repeated .substrait.Expression.FieldReference right_keys = 5;
inline int HashJoinRel::right_keys_size() const {
  return right_keys_.size();
}
inline void HashJoinRel::clear_right_keys() {
  right_keys_.Clear();
}
inline ::substrait::Expression_FieldReference* HashJoinRel::mutable_right_keys(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.HashJoinRel.right_keys)
  return right_keys_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::Expression_FieldReference >*
HashJoinRel::mutable_right_keys() {
  // @@protoc_insertion_point(field_mutable_list:substrait.HashJoinRel.right_keys)
  return &right_keys_;
}
inline const ::substrait::Expression_FieldReference& HashJoinRel::right_keys(int index) const {
  // @@protoc_insertion_point(field_get:substrait.HashJoinRel.right_keys)
  return right_keys_.Get(index);
}
inline ::substrait::Expression_FieldReference* HashJoinRel::add_right_keys() {
  // @@protoc_insertion_point(field_add:substrait.HashJoinRel.right_keys)
  return right_keys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::Expression_FieldReference >&
HashJoinRel::right_keys() const {
  // @@protoc_insertion_point(field_list:substrait.HashJoinRel.right_keys)
  return right_keys_;
}

// .substrait.Expression post_join_filter = 6;
inline bool HashJoinRel::has_post_join_filter() const {
  return this != internal_default_instance() && post_join_filter_ != NULL;
}
inline void HashJoinRel::clear_post_join_filter() {
  if (GetArenaNoVirtual() == NULL && post_join_filter_ != NULL) {
    delete post_join_filter_;
  }
  post_join_filter_ = NULL;
}
inline const ::substrait::Expression& HashJoinRel::_internal_post_join_filter() const {
  return *post_join_filter_;
}
inline const ::substrait::Expression& HashJoinRel::post_join_filter() const {
  const ::substrait::Expression* p = post_join_filter_;
  // @@protoc_insertion_point(field_get:substrait.HashJoinRel.post_join_filter)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression*>(
      &::substrait::_Expression_default_instance_);
}
inline ::substrait::Expression* HashJoinRel::release_post_join_filter() {
  // @@protoc_insertion_point(field_release:substrait.HashJoinRel.post_join_filter)
  
  ::substrait::Expression* temp = post_join_filter_;
  post_join_filter_ = NULL;
  return temp;
}
inline ::substrait::Expression* HashJoinRel::mutable_post_join_filter() {
  
  if (post_join_filter_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression>(GetArenaNoVirtual());
    post_join_filter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.HashJoinRel.post_join_filter)
  return post_join_filter_;
}
inline void HashJoinRel::set_allocated_post_join_filter(::substrait::Expression* post_join_filter) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete post_join_filter_;
  }
  if (post_join_filter) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      post_join_filter = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, post_join_filter, submessage_arena);
    }
    
  } else {
    
  }
  post_join_filter_ = post_join_filter;
  // @@protoc_insertion_point(field_set_allocated:substrait.HashJoinRel.post_join_filter)
}

// .substrait.HashJoinRel.JoinType type = 7;
inline void HashJoinRel::clear_type() {
  type_ = 0;
}
inline ::substrait::HashJoinRel_JoinType HashJoinRel::type() const {
  // @@protoc_insertion_point(field_get:substrait.HashJoinRel.type)
  return static_cast< ::substrait::HashJoinRel_JoinType >(type_);
}
inline void HashJoinRel::set_type(::substrait::HashJoinRel_JoinType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:substrait.HashJoinRel.type)
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool HashJoinRel::has_advanced_extension() const {
  return this != internal_default_instance() && advanced_extension_ != NULL;
}
inline const ::substrait::extensions::AdvancedExtension& HashJoinRel::_internal_advanced_extension() const {
  return *advanced_extension_;
}
inline const ::substrait::extensions::AdvancedExtension& HashJoinRel::advanced_extension() const {
  const ::substrait::extensions::AdvancedExtension* p = advanced_extension_;
  // @@protoc_insertion_point(field_get:substrait.HashJoinRel.advanced_extension)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::extensions::AdvancedExtension*>(
      &::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline ::substrait::extensions::AdvancedExtension* HashJoinRel::release_advanced_extension() {
  // @@protoc_insertion_point(field_release:substrait.HashJoinRel.advanced_extension)
  
  ::substrait::extensions::AdvancedExtension* temp = advanced_extension_;
  advanced_extension_ = NULL;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* HashJoinRel::mutable_advanced_extension() {
  
  if (advanced_extension_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::extensions::AdvancedExtension>(GetArenaNoVirtual());
    advanced_extension_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.HashJoinRel.advanced_extension)
  return advanced_extension_;
}
inline void HashJoinRel::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(advanced_extension_);
  }
  if (advanced_extension) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      advanced_extension = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, advanced_extension, submessage_arena);
    }
    
  } else {
    
  }
  advanced_extension_ = advanced_extension;
  // @@protoc_insertion_point(field_set_allocated:substrait.HashJoinRel.advanced_extension)
}

// -------------------------------------------------------------------

// MergeJoinRel

// .substrait.RelCommon common = 1;
inline bool MergeJoinRel::has_common() const {
  return this != internal_default_instance() && common_ != NULL;
}
inline void MergeJoinRel::clear_common() {
  if (GetArenaNoVirtual() == NULL && common_ != NULL) {
    delete common_;
  }
  common_ = NULL;
}
inline const ::substrait::RelCommon& MergeJoinRel::_internal_common() const {
  return *common_;
}
inline const ::substrait::RelCommon& MergeJoinRel::common() const {
  const ::substrait::RelCommon* p = common_;
  // @@protoc_insertion_point(field_get:substrait.MergeJoinRel.common)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::RelCommon*>(
      &::substrait::_RelCommon_default_instance_);
}
inline ::substrait::RelCommon* MergeJoinRel::release_common() {
  // @@protoc_insertion_point(field_release:substrait.MergeJoinRel.common)
  
  ::substrait::RelCommon* temp = common_;
  common_ = NULL;
  return temp;
}
inline ::substrait::RelCommon* MergeJoinRel::mutable_common() {
  
  if (common_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::RelCommon>(GetArenaNoVirtual());
    common_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.MergeJoinRel.common)
  return common_;
}
inline void MergeJoinRel::set_allocated_common(::substrait::RelCommon* common) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete common_;
  }
  if (common) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      common = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, common, submessage_arena);
    }
    
  } else {
    
  }
  common_ = common;
  // @@protoc_insertion_point(field_set_allocated:substrait.MergeJoinRel.common)
}

// .substrait.Rel left = 2;
inline bool MergeJoinRel::has_left() const {
  return this != internal_default_instance() && left_ != NULL;
}
inline void MergeJoinRel::clear_left() {
  if (GetArenaNoVirtual() == NULL && left_ != NULL) {
    delete left_;
  }
  left_ = NULL;
}
inline const ::substrait::Rel& MergeJoinRel::_internal_left() const {
  return *left_;
}
inline const ::substrait::Rel& MergeJoinRel::left() const {
  const ::substrait::Rel* p = left_;
  // @@protoc_insertion_point(field_get:substrait.MergeJoinRel.left)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Rel*>(
      &::substrait::_Rel_default_instance_);
}
inline ::substrait::Rel* MergeJoinRel::release_left() {
  // @@protoc_insertion_point(field_release:substrait.MergeJoinRel.left)
  
  ::substrait::Rel* temp = left_;
  left_ = NULL;
  return temp;
}
inline ::substrait::Rel* MergeJoinRel::mutable_left() {
  
  if (left_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Rel>(GetArenaNoVirtual());
    left_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.MergeJoinRel.left)
  return left_;
}
inline void MergeJoinRel::set_allocated_left(::substrait::Rel* left) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete left_;
  }
  if (left) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      left = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, left, submessage_arena);
    }
    
  } else {
    
  }
  left_ = left;
  // @@protoc_insertion_point(field_set_allocated:substrait.MergeJoinRel.left)
}

// .substrait.Rel right = 3;
inline bool MergeJoinRel::has_right() const {
  return this != internal_default_instance() && right_ != NULL;
}
inline void MergeJoinRel::clear_right() {
  if (GetArenaNoVirtual() == NULL && right_ != NULL) {
    delete right_;
  }
  right_ = NULL;
}
inline const ::substrait::Rel& MergeJoinRel::_internal_right() const {
  return *right_;
}
inline const ::substrait::Rel& MergeJoinRel::right() const {
  const ::substrait::Rel* p = right_;
  // @@protoc_insertion_point(field_get:substrait.MergeJoinRel.right)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Rel*>(
      &::substrait::_Rel_default_instance_);
}
inline ::substrait::Rel* MergeJoinRel::release_right() {
  // @@protoc_insertion_point(field_release:substrait.MergeJoinRel.right)
  
  ::substrait::Rel* temp = right_;
  right_ = NULL;
  return temp;
}
inline ::substrait::Rel* MergeJoinRel::mutable_right() {
  
  if (right_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Rel>(GetArenaNoVirtual());
    right_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.MergeJoinRel.right)
  return right_;
}
inline void MergeJoinRel::set_allocated_right(::substrait::Rel* right) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete right_;
  }
  if (right) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      right = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, right, submessage_arena);
    }
    
  } else {
    
  }
  right_ = right;
  // @@protoc_insertion_point(field_set_allocated:substrait.MergeJoinRel.right)
}

// repeated .substrait.Expression.FieldReference left_keys = 4;
inline int MergeJoinRel::left_keys_size() const {
  return left_keys_.size();
}
inline void MergeJoinRel::clear_left_keys() {
  left_keys_.Clear();
}
inline ::substrait::Expression_FieldReference* MergeJoinRel::mutable_left_keys(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.MergeJoinRel.left_keys)
  return left_keys_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::Expression_FieldReference >*
MergeJoinRel::mutable_left_keys() {
  // @@protoc_insertion_point(field_mutable_list:substrait.MergeJoinRel.left_keys)
  return &left_keys_;
}
inline const ::substrait::Expression_FieldReference& MergeJoinRel::left_keys(int index) const {
  // @@protoc_insertion_point(field_get:substrait.MergeJoinRel.left_keys)
  return left_keys_.Get(index);
}
inline ::substrait::Expression_FieldReference* MergeJoinRel::add_left_keys() {
  // @@protoc_insertion_point(field_add:substrait.MergeJoinRel.left_keys)
  return left_keys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::Expression_FieldReference >&
MergeJoinRel::left_keys() const {
  // @@protoc_insertion_point(field_list:substrait.MergeJoinRel.left_keys)
  return left_keys_;
}

// repeated .substrait.Expression.FieldReference right_keys = 5;
inline int MergeJoinRel::right_keys_size() const {
  return right_keys_.size();
}
inline void MergeJoinRel::clear_right_keys() {
  right_keys_.Clear();
}
inline ::substrait::Expression_FieldReference* MergeJoinRel::mutable_right_keys(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.MergeJoinRel.right_keys)
  return right_keys_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::Expression_FieldReference >*
MergeJoinRel::mutable_right_keys() {
  // @@protoc_insertion_point(field_mutable_list:substrait.MergeJoinRel.right_keys)
  return &right_keys_;
}
inline const ::substrait::Expression_FieldReference& MergeJoinRel::right_keys(int index) const {
  // @@protoc_insertion_point(field_get:substrait.MergeJoinRel.right_keys)
  return right_keys_.Get(index);
}
inline ::substrait::Expression_FieldReference* MergeJoinRel::add_right_keys() {
  // @@protoc_insertion_point(field_add:substrait.MergeJoinRel.right_keys)
  return right_keys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::Expression_FieldReference >&
MergeJoinRel::right_keys() const {
  // @@protoc_insertion_point(field_list:substrait.MergeJoinRel.right_keys)
  return right_keys_;
}

// .substrait.Expression post_join_filter = 6;
inline bool MergeJoinRel::has_post_join_filter() const {
  return this != internal_default_instance() && post_join_filter_ != NULL;
}
inline void MergeJoinRel::clear_post_join_filter() {
  if (GetArenaNoVirtual() == NULL && post_join_filter_ != NULL) {
    delete post_join_filter_;
  }
  post_join_filter_ = NULL;
}
inline const ::substrait::Expression& MergeJoinRel::_internal_post_join_filter() const {
  return *post_join_filter_;
}
inline const ::substrait::Expression& MergeJoinRel::post_join_filter() const {
  const ::substrait::Expression* p = post_join_filter_;
  // @@protoc_insertion_point(field_get:substrait.MergeJoinRel.post_join_filter)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression*>(
      &::substrait::_Expression_default_instance_);
}
inline ::substrait::Expression* MergeJoinRel::release_post_join_filter() {
  // @@protoc_insertion_point(field_release:substrait.MergeJoinRel.post_join_filter)
  
  ::substrait::Expression* temp = post_join_filter_;
  post_join_filter_ = NULL;
  return temp;
}
inline ::substrait::Expression* MergeJoinRel::mutable_post_join_filter() {
  
  if (post_join_filter_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression>(GetArenaNoVirtual());
    post_join_filter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.MergeJoinRel.post_join_filter)
  return post_join_filter_;
}
inline void MergeJoinRel::set_allocated_post_join_filter(::substrait::Expression* post_join_filter) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete post_join_filter_;
  }
  if (post_join_filter) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      post_join_filter = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, post_join_filter, submessage_arena);
    }
    
  } else {
    
  }
  post_join_filter_ = post_join_filter;
  // @@protoc_insertion_point(field_set_allocated:substrait.MergeJoinRel.post_join_filter)
}

// .substrait.MergeJoinRel.JoinType type = 7;
inline void MergeJoinRel::clear_type() {
  type_ = 0;
}
inline ::substrait::MergeJoinRel_JoinType MergeJoinRel::type() const {
  // @@protoc_insertion_point(field_get:substrait.MergeJoinRel.type)
  return static_cast< ::substrait::MergeJoinRel_JoinType >(type_);
}
inline void MergeJoinRel::set_type(::substrait::MergeJoinRel_JoinType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:substrait.MergeJoinRel.type)
}

// .substrait.extensions.AdvancedExtension advanced_extension = 10;
inline bool MergeJoinRel::has_advanced_extension() const {
  return this != internal_default_instance() && advanced_extension_ != NULL;
}
inline const ::substrait::extensions::AdvancedExtension& MergeJoinRel::_internal_advanced_extension() const {
  return *advanced_extension_;
}
inline const ::substrait::extensions::AdvancedExtension& MergeJoinRel::advanced_extension() const {
  const ::substrait::extensions::AdvancedExtension* p = advanced_extension_;
  // @@protoc_insertion_point(field_get:substrait.MergeJoinRel.advanced_extension)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::extensions::AdvancedExtension*>(
      &::substrait::extensions::_AdvancedExtension_default_instance_);
}
inline ::substrait::extensions::AdvancedExtension* MergeJoinRel::release_advanced_extension() {
  // @@protoc_insertion_point(field_release:substrait.MergeJoinRel.advanced_extension)
  
  ::substrait::extensions::AdvancedExtension* temp = advanced_extension_;
  advanced_extension_ = NULL;
  return temp;
}
inline ::substrait::extensions::AdvancedExtension* MergeJoinRel::mutable_advanced_extension() {
  
  if (advanced_extension_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::extensions::AdvancedExtension>(GetArenaNoVirtual());
    advanced_extension_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.MergeJoinRel.advanced_extension)
  return advanced_extension_;
}
inline void MergeJoinRel::set_allocated_advanced_extension(::substrait::extensions::AdvancedExtension* advanced_extension) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(advanced_extension_);
  }
  if (advanced_extension) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      advanced_extension = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, advanced_extension, submessage_arena);
    }
    
  } else {
    
  }
  advanced_extension_ = advanced_extension;
  // @@protoc_insertion_point(field_set_allocated:substrait.MergeJoinRel.advanced_extension)
}

// -------------------------------------------------------------------

// FunctionArgument

// string enum = 1;
inline bool FunctionArgument::has_enum_() const {
  return arg_type_case() == kEnum;
}
inline void FunctionArgument::set_has_enum_() {
  _oneof_case_[0] = kEnum;
}
inline void FunctionArgument::clear_enum_() {
  if (has_enum_()) {
    arg_type_.enum__.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_arg_type();
  }
}
inline const ::std::string& FunctionArgument::enum_() const {
  // @@protoc_insertion_point(field_get:substrait.FunctionArgument.enum)
  if (has_enum_()) {
    return arg_type_.enum__.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void FunctionArgument::set_enum_(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:substrait.FunctionArgument.enum)
  if (!has_enum_()) {
    clear_arg_type();
    set_has_enum_();
    arg_type_.enum__.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  arg_type_.enum__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:substrait.FunctionArgument.enum)
}
#if LANG_CXX11
inline void FunctionArgument::set_enum_(::std::string&& value) {
  // @@protoc_insertion_point(field_set:substrait.FunctionArgument.enum)
  if (!has_enum_()) {
    clear_arg_type();
    set_has_enum_();
    arg_type_.enum__.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  arg_type_.enum__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:substrait.FunctionArgument.enum)
}
#endif
inline void FunctionArgument::set_enum_(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_enum_()) {
    clear_arg_type();
    set_has_enum_();
    arg_type_.enum__.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  arg_type_.enum__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:substrait.FunctionArgument.enum)
}
inline void FunctionArgument::set_enum_(const char* value, size_t size) {
  if (!has_enum_()) {
    clear_arg_type();
    set_has_enum_();
    arg_type_.enum__.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  arg_type_.enum__.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:substrait.FunctionArgument.enum)
}
inline ::std::string* FunctionArgument::mutable_enum_() {
  if (!has_enum_()) {
    clear_arg_type();
    set_has_enum_();
    arg_type_.enum__.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:substrait.FunctionArgument.enum)
  return arg_type_.enum__.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FunctionArgument::release_enum_() {
  // @@protoc_insertion_point(field_release:substrait.FunctionArgument.enum)
  if (has_enum_()) {
    clear_has_arg_type();
    return arg_type_.enum__.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void FunctionArgument::set_allocated_enum_(::std::string* enum_) {
  if (!has_enum_()) {
    arg_type_.enum__.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_arg_type();
  if (enum_ != NULL) {
    set_has_enum_();
    arg_type_.enum__.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), enum_);
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.FunctionArgument.enum)
}

// .substrait.Type type = 2;
inline bool FunctionArgument::has_type() const {
  return arg_type_case() == kType;
}
inline void FunctionArgument::set_has_type() {
  _oneof_case_[0] = kType;
}
inline const ::substrait::Type& FunctionArgument::_internal_type() const {
  return *arg_type_.type_;
}
inline ::substrait::Type* FunctionArgument::release_type() {
  // @@protoc_insertion_point(field_release:substrait.FunctionArgument.type)
  if (has_type()) {
    clear_has_arg_type();
      ::substrait::Type* temp = arg_type_.type_;
    arg_type_.type_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Type& FunctionArgument::type() const {
  // @@protoc_insertion_point(field_get:substrait.FunctionArgument.type)
  return has_type()
      ? *arg_type_.type_
      : *reinterpret_cast< ::substrait::Type*>(&::substrait::_Type_default_instance_);
}
inline ::substrait::Type* FunctionArgument::mutable_type() {
  if (!has_type()) {
    clear_arg_type();
    set_has_type();
    arg_type_.type_ = CreateMaybeMessage< ::substrait::Type >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.FunctionArgument.type)
  return arg_type_.type_;
}

// .substrait.Expression value = 3;
inline bool FunctionArgument::has_value() const {
  return arg_type_case() == kValue;
}
inline void FunctionArgument::set_has_value() {
  _oneof_case_[0] = kValue;
}
inline void FunctionArgument::clear_value() {
  if (has_value()) {
    delete arg_type_.value_;
    clear_has_arg_type();
  }
}
inline const ::substrait::Expression& FunctionArgument::_internal_value() const {
  return *arg_type_.value_;
}
inline ::substrait::Expression* FunctionArgument::release_value() {
  // @@protoc_insertion_point(field_release:substrait.FunctionArgument.value)
  if (has_value()) {
    clear_has_arg_type();
      ::substrait::Expression* temp = arg_type_.value_;
    arg_type_.value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression& FunctionArgument::value() const {
  // @@protoc_insertion_point(field_get:substrait.FunctionArgument.value)
  return has_value()
      ? *arg_type_.value_
      : *reinterpret_cast< ::substrait::Expression*>(&::substrait::_Expression_default_instance_);
}
inline ::substrait::Expression* FunctionArgument::mutable_value() {
  if (!has_value()) {
    clear_arg_type();
    set_has_value();
    arg_type_.value_ = CreateMaybeMessage< ::substrait::Expression >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.FunctionArgument.value)
  return arg_type_.value_;
}

inline bool FunctionArgument::has_arg_type() const {
  return arg_type_case() != ARG_TYPE_NOT_SET;
}
inline void FunctionArgument::clear_has_arg_type() {
  _oneof_case_[0] = ARG_TYPE_NOT_SET;
}
inline FunctionArgument::ArgTypeCase FunctionArgument::arg_type_case() const {
  return FunctionArgument::ArgTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// FunctionOption

// string name = 1;
inline void FunctionOption::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FunctionOption::name() const {
  // @@protoc_insertion_point(field_get:substrait.FunctionOption.name)
  return name_.GetNoArena();
}
inline void FunctionOption::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:substrait.FunctionOption.name)
}
#if LANG_CXX11
inline void FunctionOption::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:substrait.FunctionOption.name)
}
#endif
inline void FunctionOption::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:substrait.FunctionOption.name)
}
inline void FunctionOption::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:substrait.FunctionOption.name)
}
inline ::std::string* FunctionOption::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:substrait.FunctionOption.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FunctionOption::release_name() {
  // @@protoc_insertion_point(field_release:substrait.FunctionOption.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FunctionOption::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:substrait.FunctionOption.name)
}

// repeated string preference = 2;
inline int FunctionOption::preference_size() const {
  return preference_.size();
}
inline void FunctionOption::clear_preference() {
  preference_.Clear();
}
inline const ::std::string& FunctionOption::preference(int index) const {
  // @@protoc_insertion_point(field_get:substrait.FunctionOption.preference)
  return preference_.Get(index);
}
inline ::std::string* FunctionOption::mutable_preference(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.FunctionOption.preference)
  return preference_.Mutable(index);
}
inline void FunctionOption::set_preference(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:substrait.FunctionOption.preference)
  preference_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void FunctionOption::set_preference(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:substrait.FunctionOption.preference)
  preference_.Mutable(index)->assign(std::move(value));
}
#endif
inline void FunctionOption::set_preference(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  preference_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:substrait.FunctionOption.preference)
}
inline void FunctionOption::set_preference(int index, const char* value, size_t size) {
  preference_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:substrait.FunctionOption.preference)
}
inline ::std::string* FunctionOption::add_preference() {
  // @@protoc_insertion_point(field_add_mutable:substrait.FunctionOption.preference)
  return preference_.Add();
}
inline void FunctionOption::add_preference(const ::std::string& value) {
  preference_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:substrait.FunctionOption.preference)
}
#if LANG_CXX11
inline void FunctionOption::add_preference(::std::string&& value) {
  preference_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:substrait.FunctionOption.preference)
}
#endif
inline void FunctionOption::add_preference(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  preference_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:substrait.FunctionOption.preference)
}
inline void FunctionOption::add_preference(const char* value, size_t size) {
  preference_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:substrait.FunctionOption.preference)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FunctionOption::preference() const {
  // @@protoc_insertion_point(field_list:substrait.FunctionOption.preference)
  return preference_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FunctionOption::mutable_preference() {
  // @@protoc_insertion_point(field_mutable_list:substrait.FunctionOption.preference)
  return &preference_;
}

// -------------------------------------------------------------------

// Expression_Enum_Empty

// -------------------------------------------------------------------

// Expression_Enum

// string specified = 1;
inline bool Expression_Enum::has_specified() const {
  return enum_kind_case() == kSpecified;
}
inline void Expression_Enum::set_has_specified() {
  _oneof_case_[0] = kSpecified;
}
inline void Expression_Enum::clear_specified() {
  if (has_specified()) {
    enum_kind_.specified_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_enum_kind();
  }
}
inline const ::std::string& Expression_Enum::specified() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Enum.specified)
  if (has_specified()) {
    return enum_kind_.specified_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Expression_Enum::set_specified(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:substrait.Expression.Enum.specified)
  if (!has_specified()) {
    clear_enum_kind();
    set_has_specified();
    enum_kind_.specified_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  enum_kind_.specified_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:substrait.Expression.Enum.specified)
}
#if LANG_CXX11
inline void Expression_Enum::set_specified(::std::string&& value) {
  // @@protoc_insertion_point(field_set:substrait.Expression.Enum.specified)
  if (!has_specified()) {
    clear_enum_kind();
    set_has_specified();
    enum_kind_.specified_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  enum_kind_.specified_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:substrait.Expression.Enum.specified)
}
#endif
inline void Expression_Enum::set_specified(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_specified()) {
    clear_enum_kind();
    set_has_specified();
    enum_kind_.specified_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  enum_kind_.specified_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:substrait.Expression.Enum.specified)
}
inline void Expression_Enum::set_specified(const char* value, size_t size) {
  if (!has_specified()) {
    clear_enum_kind();
    set_has_specified();
    enum_kind_.specified_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  enum_kind_.specified_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:substrait.Expression.Enum.specified)
}
inline ::std::string* Expression_Enum::mutable_specified() {
  if (!has_specified()) {
    clear_enum_kind();
    set_has_specified();
    enum_kind_.specified_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Enum.specified)
  return enum_kind_.specified_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Expression_Enum::release_specified() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Enum.specified)
  if (has_specified()) {
    clear_has_enum_kind();
    return enum_kind_.specified_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Expression_Enum::set_allocated_specified(::std::string* specified) {
  if (!has_specified()) {
    enum_kind_.specified_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_enum_kind();
  if (specified != NULL) {
    set_has_specified();
    enum_kind_.specified_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), specified);
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Enum.specified)
}

// .substrait.Expression.Enum.Empty unspecified = 2;
inline bool Expression_Enum::has_unspecified() const {
  return enum_kind_case() == kUnspecified;
}
inline void Expression_Enum::set_has_unspecified() {
  _oneof_case_[0] = kUnspecified;
}
inline void Expression_Enum::clear_unspecified() {
  if (has_unspecified()) {
    delete enum_kind_.unspecified_;
    clear_has_enum_kind();
  }
}
inline const ::substrait::Expression_Enum_Empty& Expression_Enum::_internal_unspecified() const {
  return *enum_kind_.unspecified_;
}
inline ::substrait::Expression_Enum_Empty* Expression_Enum::release_unspecified() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Enum.unspecified)
  if (has_unspecified()) {
    clear_has_enum_kind();
      ::substrait::Expression_Enum_Empty* temp = enum_kind_.unspecified_;
    enum_kind_.unspecified_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_Enum_Empty& Expression_Enum::unspecified() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Enum.unspecified)
  return has_unspecified()
      ? *enum_kind_.unspecified_
      : *reinterpret_cast< ::substrait::Expression_Enum_Empty*>(&::substrait::_Expression_Enum_Empty_default_instance_);
}
inline ::substrait::Expression_Enum_Empty* Expression_Enum::mutable_unspecified() {
  if (!has_unspecified()) {
    clear_enum_kind();
    set_has_unspecified();
    enum_kind_.unspecified_ = CreateMaybeMessage< ::substrait::Expression_Enum_Empty >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Enum.unspecified)
  return enum_kind_.unspecified_;
}

inline bool Expression_Enum::has_enum_kind() const {
  return enum_kind_case() != ENUM_KIND_NOT_SET;
}
inline void Expression_Enum::clear_has_enum_kind() {
  _oneof_case_[0] = ENUM_KIND_NOT_SET;
}
inline Expression_Enum::EnumKindCase Expression_Enum::enum_kind_case() const {
  return Expression_Enum::EnumKindCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Expression_Literal_VarChar

// string value = 1;
inline void Expression_Literal_VarChar::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Expression_Literal_VarChar::value() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.VarChar.value)
  return value_.GetNoArena();
}
inline void Expression_Literal_VarChar::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.VarChar.value)
}
#if LANG_CXX11
inline void Expression_Literal_VarChar::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:substrait.Expression.Literal.VarChar.value)
}
#endif
inline void Expression_Literal_VarChar::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:substrait.Expression.Literal.VarChar.value)
}
inline void Expression_Literal_VarChar::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:substrait.Expression.Literal.VarChar.value)
}
inline ::std::string* Expression_Literal_VarChar::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.VarChar.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Expression_Literal_VarChar::release_value() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.VarChar.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Expression_Literal_VarChar::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Literal.VarChar.value)
}

// uint32 length = 2;
inline void Expression_Literal_VarChar::clear_length() {
  length_ = 0u;
}
inline ::google::protobuf::uint32 Expression_Literal_VarChar::length() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.VarChar.length)
  return length_;
}
inline void Expression_Literal_VarChar::set_length(::google::protobuf::uint32 value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.VarChar.length)
}

// -------------------------------------------------------------------

// Expression_Literal_Decimal

// bytes value = 1;
inline void Expression_Literal_Decimal::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Expression_Literal_Decimal::value() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.Decimal.value)
  return value_.GetNoArena();
}
inline void Expression_Literal_Decimal::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.Decimal.value)
}
#if LANG_CXX11
inline void Expression_Literal_Decimal::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:substrait.Expression.Literal.Decimal.value)
}
#endif
inline void Expression_Literal_Decimal::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:substrait.Expression.Literal.Decimal.value)
}
inline void Expression_Literal_Decimal::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:substrait.Expression.Literal.Decimal.value)
}
inline ::std::string* Expression_Literal_Decimal::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.Decimal.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Expression_Literal_Decimal::release_value() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.Decimal.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Expression_Literal_Decimal::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Literal.Decimal.value)
}

// int32 precision = 2;
inline void Expression_Literal_Decimal::clear_precision() {
  precision_ = 0;
}
inline ::google::protobuf::int32 Expression_Literal_Decimal::precision() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.Decimal.precision)
  return precision_;
}
inline void Expression_Literal_Decimal::set_precision(::google::protobuf::int32 value) {
  
  precision_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.Decimal.precision)
}

// int32 scale = 3;
inline void Expression_Literal_Decimal::clear_scale() {
  scale_ = 0;
}
inline ::google::protobuf::int32 Expression_Literal_Decimal::scale() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.Decimal.scale)
  return scale_;
}
inline void Expression_Literal_Decimal::set_scale(::google::protobuf::int32 value) {
  
  scale_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.Decimal.scale)
}

// -------------------------------------------------------------------

// Expression_Literal_Map_KeyValue

// .substrait.Expression.Literal key = 1;
inline bool Expression_Literal_Map_KeyValue::has_key() const {
  return this != internal_default_instance() && key_ != NULL;
}
inline void Expression_Literal_Map_KeyValue::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) {
    delete key_;
  }
  key_ = NULL;
}
inline const ::substrait::Expression_Literal& Expression_Literal_Map_KeyValue::_internal_key() const {
  return *key_;
}
inline const ::substrait::Expression_Literal& Expression_Literal_Map_KeyValue::key() const {
  const ::substrait::Expression_Literal* p = key_;
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.Map.KeyValue.key)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression_Literal*>(
      &::substrait::_Expression_Literal_default_instance_);
}
inline ::substrait::Expression_Literal* Expression_Literal_Map_KeyValue::release_key() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.Map.KeyValue.key)
  
  ::substrait::Expression_Literal* temp = key_;
  key_ = NULL;
  return temp;
}
inline ::substrait::Expression_Literal* Expression_Literal_Map_KeyValue::mutable_key() {
  
  if (key_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression_Literal>(GetArenaNoVirtual());
    key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.Map.KeyValue.key)
  return key_;
}
inline void Expression_Literal_Map_KeyValue::set_allocated_key(::substrait::Expression_Literal* key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete key_;
  }
  if (key) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Literal.Map.KeyValue.key)
}

// .substrait.Expression.Literal value = 2;
inline bool Expression_Literal_Map_KeyValue::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline void Expression_Literal_Map_KeyValue::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) {
    delete value_;
  }
  value_ = NULL;
}
inline const ::substrait::Expression_Literal& Expression_Literal_Map_KeyValue::_internal_value() const {
  return *value_;
}
inline const ::substrait::Expression_Literal& Expression_Literal_Map_KeyValue::value() const {
  const ::substrait::Expression_Literal* p = value_;
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.Map.KeyValue.value)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression_Literal*>(
      &::substrait::_Expression_Literal_default_instance_);
}
inline ::substrait::Expression_Literal* Expression_Literal_Map_KeyValue::release_value() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.Map.KeyValue.value)
  
  ::substrait::Expression_Literal* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::substrait::Expression_Literal* Expression_Literal_Map_KeyValue::mutable_value() {
  
  if (value_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression_Literal>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.Map.KeyValue.value)
  return value_;
}
inline void Expression_Literal_Map_KeyValue::set_allocated_value(::substrait::Expression_Literal* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete value_;
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Literal.Map.KeyValue.value)
}

// -------------------------------------------------------------------

// Expression_Literal_Map

// repeated .substrait.Expression.Literal.Map.KeyValue key_values = 1;
inline int Expression_Literal_Map::key_values_size() const {
  return key_values_.size();
}
inline void Expression_Literal_Map::clear_key_values() {
  key_values_.Clear();
}
inline ::substrait::Expression_Literal_Map_KeyValue* Expression_Literal_Map::mutable_key_values(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.Map.key_values)
  return key_values_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::Expression_Literal_Map_KeyValue >*
Expression_Literal_Map::mutable_key_values() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.Literal.Map.key_values)
  return &key_values_;
}
inline const ::substrait::Expression_Literal_Map_KeyValue& Expression_Literal_Map::key_values(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.Map.key_values)
  return key_values_.Get(index);
}
inline ::substrait::Expression_Literal_Map_KeyValue* Expression_Literal_Map::add_key_values() {
  // @@protoc_insertion_point(field_add:substrait.Expression.Literal.Map.key_values)
  return key_values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::Expression_Literal_Map_KeyValue >&
Expression_Literal_Map::key_values() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.Literal.Map.key_values)
  return key_values_;
}

// -------------------------------------------------------------------

// Expression_Literal_IntervalYearToMonth

// int32 years = 1;
inline void Expression_Literal_IntervalYearToMonth::clear_years() {
  years_ = 0;
}
inline ::google::protobuf::int32 Expression_Literal_IntervalYearToMonth::years() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.IntervalYearToMonth.years)
  return years_;
}
inline void Expression_Literal_IntervalYearToMonth::set_years(::google::protobuf::int32 value) {
  
  years_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.IntervalYearToMonth.years)
}

// int32 months = 2;
inline void Expression_Literal_IntervalYearToMonth::clear_months() {
  months_ = 0;
}
inline ::google::protobuf::int32 Expression_Literal_IntervalYearToMonth::months() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.IntervalYearToMonth.months)
  return months_;
}
inline void Expression_Literal_IntervalYearToMonth::set_months(::google::protobuf::int32 value) {
  
  months_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.IntervalYearToMonth.months)
}

// -------------------------------------------------------------------

// Expression_Literal_IntervalDayToSecond

// int32 days = 1;
inline void Expression_Literal_IntervalDayToSecond::clear_days() {
  days_ = 0;
}
inline ::google::protobuf::int32 Expression_Literal_IntervalDayToSecond::days() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.IntervalDayToSecond.days)
  return days_;
}
inline void Expression_Literal_IntervalDayToSecond::set_days(::google::protobuf::int32 value) {
  
  days_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.IntervalDayToSecond.days)
}

// int32 seconds = 2;
inline void Expression_Literal_IntervalDayToSecond::clear_seconds() {
  seconds_ = 0;
}
inline ::google::protobuf::int32 Expression_Literal_IntervalDayToSecond::seconds() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.IntervalDayToSecond.seconds)
  return seconds_;
}
inline void Expression_Literal_IntervalDayToSecond::set_seconds(::google::protobuf::int32 value) {
  
  seconds_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.IntervalDayToSecond.seconds)
}

// int32 microseconds = 3;
inline void Expression_Literal_IntervalDayToSecond::clear_microseconds() {
  microseconds_ = 0;
}
inline ::google::protobuf::int32 Expression_Literal_IntervalDayToSecond::microseconds() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.IntervalDayToSecond.microseconds)
  return microseconds_;
}
inline void Expression_Literal_IntervalDayToSecond::set_microseconds(::google::protobuf::int32 value) {
  
  microseconds_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.IntervalDayToSecond.microseconds)
}

// -------------------------------------------------------------------

// Expression_Literal_Struct

// repeated .substrait.Expression.Literal fields = 1;
inline int Expression_Literal_Struct::fields_size() const {
  return fields_.size();
}
inline void Expression_Literal_Struct::clear_fields() {
  fields_.Clear();
}
inline ::substrait::Expression_Literal* Expression_Literal_Struct::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.Struct.fields)
  return fields_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::Expression_Literal >*
Expression_Literal_Struct::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.Literal.Struct.fields)
  return &fields_;
}
inline const ::substrait::Expression_Literal& Expression_Literal_Struct::fields(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.Struct.fields)
  return fields_.Get(index);
}
inline ::substrait::Expression_Literal* Expression_Literal_Struct::add_fields() {
  // @@protoc_insertion_point(field_add:substrait.Expression.Literal.Struct.fields)
  return fields_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::Expression_Literal >&
Expression_Literal_Struct::fields() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.Literal.Struct.fields)
  return fields_;
}

// -------------------------------------------------------------------

// Expression_Literal_List

// repeated .substrait.Expression.Literal values = 1;
inline int Expression_Literal_List::values_size() const {
  return values_.size();
}
inline void Expression_Literal_List::clear_values() {
  values_.Clear();
}
inline ::substrait::Expression_Literal* Expression_Literal_List::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.List.values)
  return values_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::Expression_Literal >*
Expression_Literal_List::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.Literal.List.values)
  return &values_;
}
inline const ::substrait::Expression_Literal& Expression_Literal_List::values(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.List.values)
  return values_.Get(index);
}
inline ::substrait::Expression_Literal* Expression_Literal_List::add_values() {
  // @@protoc_insertion_point(field_add:substrait.Expression.Literal.List.values)
  return values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::Expression_Literal >&
Expression_Literal_List::values() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.Literal.List.values)
  return values_;
}

// -------------------------------------------------------------------

// Expression_Literal_UserDefined

// uint32 type_reference = 1;
inline void Expression_Literal_UserDefined::clear_type_reference() {
  type_reference_ = 0u;
}
inline ::google::protobuf::uint32 Expression_Literal_UserDefined::type_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.UserDefined.type_reference)
  return type_reference_;
}
inline void Expression_Literal_UserDefined::set_type_reference(::google::protobuf::uint32 value) {
  
  type_reference_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.UserDefined.type_reference)
}

// repeated .substrait.Type.Parameter type_parameters = 3;
inline int Expression_Literal_UserDefined::type_parameters_size() const {
  return type_parameters_.size();
}
inline ::substrait::Type_Parameter* Expression_Literal_UserDefined::mutable_type_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.UserDefined.type_parameters)
  return type_parameters_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::Type_Parameter >*
Expression_Literal_UserDefined::mutable_type_parameters() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.Literal.UserDefined.type_parameters)
  return &type_parameters_;
}
inline const ::substrait::Type_Parameter& Expression_Literal_UserDefined::type_parameters(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.UserDefined.type_parameters)
  return type_parameters_.Get(index);
}
inline ::substrait::Type_Parameter* Expression_Literal_UserDefined::add_type_parameters() {
  // @@protoc_insertion_point(field_add:substrait.Expression.Literal.UserDefined.type_parameters)
  return type_parameters_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::Type_Parameter >&
Expression_Literal_UserDefined::type_parameters() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.Literal.UserDefined.type_parameters)
  return type_parameters_;
}

// .google.protobuf.Any value = 2;
inline bool Expression_Literal_UserDefined::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline const ::google::protobuf::Any& Expression_Literal_UserDefined::_internal_value() const {
  return *value_;
}
inline const ::google::protobuf::Any& Expression_Literal_UserDefined::value() const {
  const ::google::protobuf::Any* p = value_;
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.UserDefined.value)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Any*>(
      &::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* Expression_Literal_UserDefined::release_value() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.UserDefined.value)
  
  ::google::protobuf::Any* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::google::protobuf::Any* Expression_Literal_UserDefined::mutable_value() {
  
  if (value_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.UserDefined.value)
  return value_;
}
inline void Expression_Literal_UserDefined::set_allocated_value(::google::protobuf::Any* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_);
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Literal.UserDefined.value)
}

// -------------------------------------------------------------------

// Expression_Literal

// bool boolean = 1;
inline bool Expression_Literal::has_boolean() const {
  return literal_type_case() == kBoolean;
}
inline void Expression_Literal::set_has_boolean() {
  _oneof_case_[0] = kBoolean;
}
inline void Expression_Literal::clear_boolean() {
  if (has_boolean()) {
    literal_type_.boolean_ = false;
    clear_has_literal_type();
  }
}
inline bool Expression_Literal::boolean() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.boolean)
  if (has_boolean()) {
    return literal_type_.boolean_;
  }
  return false;
}
inline void Expression_Literal::set_boolean(bool value) {
  if (!has_boolean()) {
    clear_literal_type();
    set_has_boolean();
  }
  literal_type_.boolean_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.boolean)
}

// int32 i8 = 2;
inline bool Expression_Literal::has_i8() const {
  return literal_type_case() == kI8;
}
inline void Expression_Literal::set_has_i8() {
  _oneof_case_[0] = kI8;
}
inline void Expression_Literal::clear_i8() {
  if (has_i8()) {
    literal_type_.i8_ = 0;
    clear_has_literal_type();
  }
}
inline ::google::protobuf::int32 Expression_Literal::i8() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.i8)
  if (has_i8()) {
    return literal_type_.i8_;
  }
  return 0;
}
inline void Expression_Literal::set_i8(::google::protobuf::int32 value) {
  if (!has_i8()) {
    clear_literal_type();
    set_has_i8();
  }
  literal_type_.i8_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.i8)
}

// int32 i16 = 3;
inline bool Expression_Literal::has_i16() const {
  return literal_type_case() == kI16;
}
inline void Expression_Literal::set_has_i16() {
  _oneof_case_[0] = kI16;
}
inline void Expression_Literal::clear_i16() {
  if (has_i16()) {
    literal_type_.i16_ = 0;
    clear_has_literal_type();
  }
}
inline ::google::protobuf::int32 Expression_Literal::i16() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.i16)
  if (has_i16()) {
    return literal_type_.i16_;
  }
  return 0;
}
inline void Expression_Literal::set_i16(::google::protobuf::int32 value) {
  if (!has_i16()) {
    clear_literal_type();
    set_has_i16();
  }
  literal_type_.i16_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.i16)
}

// int32 i32 = 5;
inline bool Expression_Literal::has_i32() const {
  return literal_type_case() == kI32;
}
inline void Expression_Literal::set_has_i32() {
  _oneof_case_[0] = kI32;
}
inline void Expression_Literal::clear_i32() {
  if (has_i32()) {
    literal_type_.i32_ = 0;
    clear_has_literal_type();
  }
}
inline ::google::protobuf::int32 Expression_Literal::i32() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.i32)
  if (has_i32()) {
    return literal_type_.i32_;
  }
  return 0;
}
inline void Expression_Literal::set_i32(::google::protobuf::int32 value) {
  if (!has_i32()) {
    clear_literal_type();
    set_has_i32();
  }
  literal_type_.i32_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.i32)
}

// int64 i64 = 7;
inline bool Expression_Literal::has_i64() const {
  return literal_type_case() == kI64;
}
inline void Expression_Literal::set_has_i64() {
  _oneof_case_[0] = kI64;
}
inline void Expression_Literal::clear_i64() {
  if (has_i64()) {
    literal_type_.i64_ = GOOGLE_LONGLONG(0);
    clear_has_literal_type();
  }
}
inline ::google::protobuf::int64 Expression_Literal::i64() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.i64)
  if (has_i64()) {
    return literal_type_.i64_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void Expression_Literal::set_i64(::google::protobuf::int64 value) {
  if (!has_i64()) {
    clear_literal_type();
    set_has_i64();
  }
  literal_type_.i64_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.i64)
}

// float fp32 = 10;
inline bool Expression_Literal::has_fp32() const {
  return literal_type_case() == kFp32;
}
inline void Expression_Literal::set_has_fp32() {
  _oneof_case_[0] = kFp32;
}
inline void Expression_Literal::clear_fp32() {
  if (has_fp32()) {
    literal_type_.fp32_ = 0;
    clear_has_literal_type();
  }
}
inline float Expression_Literal::fp32() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.fp32)
  if (has_fp32()) {
    return literal_type_.fp32_;
  }
  return 0;
}
inline void Expression_Literal::set_fp32(float value) {
  if (!has_fp32()) {
    clear_literal_type();
    set_has_fp32();
  }
  literal_type_.fp32_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.fp32)
}

// double fp64 = 11;
inline bool Expression_Literal::has_fp64() const {
  return literal_type_case() == kFp64;
}
inline void Expression_Literal::set_has_fp64() {
  _oneof_case_[0] = kFp64;
}
inline void Expression_Literal::clear_fp64() {
  if (has_fp64()) {
    literal_type_.fp64_ = 0;
    clear_has_literal_type();
  }
}
inline double Expression_Literal::fp64() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.fp64)
  if (has_fp64()) {
    return literal_type_.fp64_;
  }
  return 0;
}
inline void Expression_Literal::set_fp64(double value) {
  if (!has_fp64()) {
    clear_literal_type();
    set_has_fp64();
  }
  literal_type_.fp64_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.fp64)
}

// string string = 12;
inline bool Expression_Literal::has_string() const {
  return literal_type_case() == kString;
}
inline void Expression_Literal::set_has_string() {
  _oneof_case_[0] = kString;
}
inline void Expression_Literal::clear_string() {
  if (has_string()) {
    literal_type_.string_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_literal_type();
  }
}
inline const ::std::string& Expression_Literal::string() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.string)
  if (has_string()) {
    return literal_type_.string_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Expression_Literal::set_string(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.string)
  if (!has_string()) {
    clear_literal_type();
    set_has_string();
    literal_type_.string_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  literal_type_.string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.string)
}
#if LANG_CXX11
inline void Expression_Literal::set_string(::std::string&& value) {
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.string)
  if (!has_string()) {
    clear_literal_type();
    set_has_string();
    literal_type_.string_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  literal_type_.string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:substrait.Expression.Literal.string)
}
#endif
inline void Expression_Literal::set_string(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_string()) {
    clear_literal_type();
    set_has_string();
    literal_type_.string_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  literal_type_.string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:substrait.Expression.Literal.string)
}
inline void Expression_Literal::set_string(const char* value, size_t size) {
  if (!has_string()) {
    clear_literal_type();
    set_has_string();
    literal_type_.string_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  literal_type_.string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:substrait.Expression.Literal.string)
}
inline ::std::string* Expression_Literal::mutable_string() {
  if (!has_string()) {
    clear_literal_type();
    set_has_string();
    literal_type_.string_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.string)
  return literal_type_.string_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Expression_Literal::release_string() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.string)
  if (has_string()) {
    clear_has_literal_type();
    return literal_type_.string_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Expression_Literal::set_allocated_string(::std::string* string) {
  if (!has_string()) {
    literal_type_.string_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_literal_type();
  if (string != NULL) {
    set_has_string();
    literal_type_.string_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), string);
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Literal.string)
}

// bytes binary = 13;
inline bool Expression_Literal::has_binary() const {
  return literal_type_case() == kBinary;
}
inline void Expression_Literal::set_has_binary() {
  _oneof_case_[0] = kBinary;
}
inline void Expression_Literal::clear_binary() {
  if (has_binary()) {
    literal_type_.binary_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_literal_type();
  }
}
inline const ::std::string& Expression_Literal::binary() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.binary)
  if (has_binary()) {
    return literal_type_.binary_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Expression_Literal::set_binary(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.binary)
  if (!has_binary()) {
    clear_literal_type();
    set_has_binary();
    literal_type_.binary_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  literal_type_.binary_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.binary)
}
#if LANG_CXX11
inline void Expression_Literal::set_binary(::std::string&& value) {
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.binary)
  if (!has_binary()) {
    clear_literal_type();
    set_has_binary();
    literal_type_.binary_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  literal_type_.binary_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:substrait.Expression.Literal.binary)
}
#endif
inline void Expression_Literal::set_binary(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_binary()) {
    clear_literal_type();
    set_has_binary();
    literal_type_.binary_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  literal_type_.binary_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:substrait.Expression.Literal.binary)
}
inline void Expression_Literal::set_binary(const void* value, size_t size) {
  if (!has_binary()) {
    clear_literal_type();
    set_has_binary();
    literal_type_.binary_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  literal_type_.binary_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:substrait.Expression.Literal.binary)
}
inline ::std::string* Expression_Literal::mutable_binary() {
  if (!has_binary()) {
    clear_literal_type();
    set_has_binary();
    literal_type_.binary_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.binary)
  return literal_type_.binary_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Expression_Literal::release_binary() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.binary)
  if (has_binary()) {
    clear_has_literal_type();
    return literal_type_.binary_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Expression_Literal::set_allocated_binary(::std::string* binary) {
  if (!has_binary()) {
    literal_type_.binary_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_literal_type();
  if (binary != NULL) {
    set_has_binary();
    literal_type_.binary_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), binary);
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Literal.binary)
}

// int64 timestamp = 14;
inline bool Expression_Literal::has_timestamp() const {
  return literal_type_case() == kTimestamp;
}
inline void Expression_Literal::set_has_timestamp() {
  _oneof_case_[0] = kTimestamp;
}
inline void Expression_Literal::clear_timestamp() {
  if (has_timestamp()) {
    literal_type_.timestamp_ = GOOGLE_LONGLONG(0);
    clear_has_literal_type();
  }
}
inline ::google::protobuf::int64 Expression_Literal::timestamp() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.timestamp)
  if (has_timestamp()) {
    return literal_type_.timestamp_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void Expression_Literal::set_timestamp(::google::protobuf::int64 value) {
  if (!has_timestamp()) {
    clear_literal_type();
    set_has_timestamp();
  }
  literal_type_.timestamp_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.timestamp)
}

// int32 date = 16;
inline bool Expression_Literal::has_date() const {
  return literal_type_case() == kDate;
}
inline void Expression_Literal::set_has_date() {
  _oneof_case_[0] = kDate;
}
inline void Expression_Literal::clear_date() {
  if (has_date()) {
    literal_type_.date_ = 0;
    clear_has_literal_type();
  }
}
inline ::google::protobuf::int32 Expression_Literal::date() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.date)
  if (has_date()) {
    return literal_type_.date_;
  }
  return 0;
}
inline void Expression_Literal::set_date(::google::protobuf::int32 value) {
  if (!has_date()) {
    clear_literal_type();
    set_has_date();
  }
  literal_type_.date_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.date)
}

// int64 time = 17;
inline bool Expression_Literal::has_time() const {
  return literal_type_case() == kTime;
}
inline void Expression_Literal::set_has_time() {
  _oneof_case_[0] = kTime;
}
inline void Expression_Literal::clear_time() {
  if (has_time()) {
    literal_type_.time_ = GOOGLE_LONGLONG(0);
    clear_has_literal_type();
  }
}
inline ::google::protobuf::int64 Expression_Literal::time() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.time)
  if (has_time()) {
    return literal_type_.time_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void Expression_Literal::set_time(::google::protobuf::int64 value) {
  if (!has_time()) {
    clear_literal_type();
    set_has_time();
  }
  literal_type_.time_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.time)
}

// .substrait.Expression.Literal.IntervalYearToMonth interval_year_to_month = 19;
inline bool Expression_Literal::has_interval_year_to_month() const {
  return literal_type_case() == kIntervalYearToMonth;
}
inline void Expression_Literal::set_has_interval_year_to_month() {
  _oneof_case_[0] = kIntervalYearToMonth;
}
inline void Expression_Literal::clear_interval_year_to_month() {
  if (has_interval_year_to_month()) {
    delete literal_type_.interval_year_to_month_;
    clear_has_literal_type();
  }
}
inline const ::substrait::Expression_Literal_IntervalYearToMonth& Expression_Literal::_internal_interval_year_to_month() const {
  return *literal_type_.interval_year_to_month_;
}
inline ::substrait::Expression_Literal_IntervalYearToMonth* Expression_Literal::release_interval_year_to_month() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.interval_year_to_month)
  if (has_interval_year_to_month()) {
    clear_has_literal_type();
      ::substrait::Expression_Literal_IntervalYearToMonth* temp = literal_type_.interval_year_to_month_;
    literal_type_.interval_year_to_month_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_Literal_IntervalYearToMonth& Expression_Literal::interval_year_to_month() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.interval_year_to_month)
  return has_interval_year_to_month()
      ? *literal_type_.interval_year_to_month_
      : *reinterpret_cast< ::substrait::Expression_Literal_IntervalYearToMonth*>(&::substrait::_Expression_Literal_IntervalYearToMonth_default_instance_);
}
inline ::substrait::Expression_Literal_IntervalYearToMonth* Expression_Literal::mutable_interval_year_to_month() {
  if (!has_interval_year_to_month()) {
    clear_literal_type();
    set_has_interval_year_to_month();
    literal_type_.interval_year_to_month_ = CreateMaybeMessage< ::substrait::Expression_Literal_IntervalYearToMonth >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.interval_year_to_month)
  return literal_type_.interval_year_to_month_;
}

// .substrait.Expression.Literal.IntervalDayToSecond interval_day_to_second = 20;
inline bool Expression_Literal::has_interval_day_to_second() const {
  return literal_type_case() == kIntervalDayToSecond;
}
inline void Expression_Literal::set_has_interval_day_to_second() {
  _oneof_case_[0] = kIntervalDayToSecond;
}
inline void Expression_Literal::clear_interval_day_to_second() {
  if (has_interval_day_to_second()) {
    delete literal_type_.interval_day_to_second_;
    clear_has_literal_type();
  }
}
inline const ::substrait::Expression_Literal_IntervalDayToSecond& Expression_Literal::_internal_interval_day_to_second() const {
  return *literal_type_.interval_day_to_second_;
}
inline ::substrait::Expression_Literal_IntervalDayToSecond* Expression_Literal::release_interval_day_to_second() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.interval_day_to_second)
  if (has_interval_day_to_second()) {
    clear_has_literal_type();
      ::substrait::Expression_Literal_IntervalDayToSecond* temp = literal_type_.interval_day_to_second_;
    literal_type_.interval_day_to_second_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_Literal_IntervalDayToSecond& Expression_Literal::interval_day_to_second() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.interval_day_to_second)
  return has_interval_day_to_second()
      ? *literal_type_.interval_day_to_second_
      : *reinterpret_cast< ::substrait::Expression_Literal_IntervalDayToSecond*>(&::substrait::_Expression_Literal_IntervalDayToSecond_default_instance_);
}
inline ::substrait::Expression_Literal_IntervalDayToSecond* Expression_Literal::mutable_interval_day_to_second() {
  if (!has_interval_day_to_second()) {
    clear_literal_type();
    set_has_interval_day_to_second();
    literal_type_.interval_day_to_second_ = CreateMaybeMessage< ::substrait::Expression_Literal_IntervalDayToSecond >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.interval_day_to_second)
  return literal_type_.interval_day_to_second_;
}

// string fixed_char = 21;
inline bool Expression_Literal::has_fixed_char() const {
  return literal_type_case() == kFixedChar;
}
inline void Expression_Literal::set_has_fixed_char() {
  _oneof_case_[0] = kFixedChar;
}
inline void Expression_Literal::clear_fixed_char() {
  if (has_fixed_char()) {
    literal_type_.fixed_char_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_literal_type();
  }
}
inline const ::std::string& Expression_Literal::fixed_char() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.fixed_char)
  if (has_fixed_char()) {
    return literal_type_.fixed_char_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Expression_Literal::set_fixed_char(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.fixed_char)
  if (!has_fixed_char()) {
    clear_literal_type();
    set_has_fixed_char();
    literal_type_.fixed_char_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  literal_type_.fixed_char_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.fixed_char)
}
#if LANG_CXX11
inline void Expression_Literal::set_fixed_char(::std::string&& value) {
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.fixed_char)
  if (!has_fixed_char()) {
    clear_literal_type();
    set_has_fixed_char();
    literal_type_.fixed_char_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  literal_type_.fixed_char_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:substrait.Expression.Literal.fixed_char)
}
#endif
inline void Expression_Literal::set_fixed_char(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_fixed_char()) {
    clear_literal_type();
    set_has_fixed_char();
    literal_type_.fixed_char_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  literal_type_.fixed_char_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:substrait.Expression.Literal.fixed_char)
}
inline void Expression_Literal::set_fixed_char(const char* value, size_t size) {
  if (!has_fixed_char()) {
    clear_literal_type();
    set_has_fixed_char();
    literal_type_.fixed_char_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  literal_type_.fixed_char_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:substrait.Expression.Literal.fixed_char)
}
inline ::std::string* Expression_Literal::mutable_fixed_char() {
  if (!has_fixed_char()) {
    clear_literal_type();
    set_has_fixed_char();
    literal_type_.fixed_char_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.fixed_char)
  return literal_type_.fixed_char_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Expression_Literal::release_fixed_char() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.fixed_char)
  if (has_fixed_char()) {
    clear_has_literal_type();
    return literal_type_.fixed_char_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Expression_Literal::set_allocated_fixed_char(::std::string* fixed_char) {
  if (!has_fixed_char()) {
    literal_type_.fixed_char_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_literal_type();
  if (fixed_char != NULL) {
    set_has_fixed_char();
    literal_type_.fixed_char_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fixed_char);
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Literal.fixed_char)
}

// .substrait.Expression.Literal.VarChar var_char = 22;
inline bool Expression_Literal::has_var_char() const {
  return literal_type_case() == kVarChar;
}
inline void Expression_Literal::set_has_var_char() {
  _oneof_case_[0] = kVarChar;
}
inline void Expression_Literal::clear_var_char() {
  if (has_var_char()) {
    delete literal_type_.var_char_;
    clear_has_literal_type();
  }
}
inline const ::substrait::Expression_Literal_VarChar& Expression_Literal::_internal_var_char() const {
  return *literal_type_.var_char_;
}
inline ::substrait::Expression_Literal_VarChar* Expression_Literal::release_var_char() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.var_char)
  if (has_var_char()) {
    clear_has_literal_type();
      ::substrait::Expression_Literal_VarChar* temp = literal_type_.var_char_;
    literal_type_.var_char_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_Literal_VarChar& Expression_Literal::var_char() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.var_char)
  return has_var_char()
      ? *literal_type_.var_char_
      : *reinterpret_cast< ::substrait::Expression_Literal_VarChar*>(&::substrait::_Expression_Literal_VarChar_default_instance_);
}
inline ::substrait::Expression_Literal_VarChar* Expression_Literal::mutable_var_char() {
  if (!has_var_char()) {
    clear_literal_type();
    set_has_var_char();
    literal_type_.var_char_ = CreateMaybeMessage< ::substrait::Expression_Literal_VarChar >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.var_char)
  return literal_type_.var_char_;
}

// bytes fixed_binary = 23;
inline bool Expression_Literal::has_fixed_binary() const {
  return literal_type_case() == kFixedBinary;
}
inline void Expression_Literal::set_has_fixed_binary() {
  _oneof_case_[0] = kFixedBinary;
}
inline void Expression_Literal::clear_fixed_binary() {
  if (has_fixed_binary()) {
    literal_type_.fixed_binary_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_literal_type();
  }
}
inline const ::std::string& Expression_Literal::fixed_binary() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.fixed_binary)
  if (has_fixed_binary()) {
    return literal_type_.fixed_binary_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Expression_Literal::set_fixed_binary(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.fixed_binary)
  if (!has_fixed_binary()) {
    clear_literal_type();
    set_has_fixed_binary();
    literal_type_.fixed_binary_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  literal_type_.fixed_binary_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.fixed_binary)
}
#if LANG_CXX11
inline void Expression_Literal::set_fixed_binary(::std::string&& value) {
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.fixed_binary)
  if (!has_fixed_binary()) {
    clear_literal_type();
    set_has_fixed_binary();
    literal_type_.fixed_binary_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  literal_type_.fixed_binary_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:substrait.Expression.Literal.fixed_binary)
}
#endif
inline void Expression_Literal::set_fixed_binary(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_fixed_binary()) {
    clear_literal_type();
    set_has_fixed_binary();
    literal_type_.fixed_binary_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  literal_type_.fixed_binary_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:substrait.Expression.Literal.fixed_binary)
}
inline void Expression_Literal::set_fixed_binary(const void* value, size_t size) {
  if (!has_fixed_binary()) {
    clear_literal_type();
    set_has_fixed_binary();
    literal_type_.fixed_binary_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  literal_type_.fixed_binary_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:substrait.Expression.Literal.fixed_binary)
}
inline ::std::string* Expression_Literal::mutable_fixed_binary() {
  if (!has_fixed_binary()) {
    clear_literal_type();
    set_has_fixed_binary();
    literal_type_.fixed_binary_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.fixed_binary)
  return literal_type_.fixed_binary_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Expression_Literal::release_fixed_binary() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.fixed_binary)
  if (has_fixed_binary()) {
    clear_has_literal_type();
    return literal_type_.fixed_binary_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Expression_Literal::set_allocated_fixed_binary(::std::string* fixed_binary) {
  if (!has_fixed_binary()) {
    literal_type_.fixed_binary_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_literal_type();
  if (fixed_binary != NULL) {
    set_has_fixed_binary();
    literal_type_.fixed_binary_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fixed_binary);
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Literal.fixed_binary)
}

// .substrait.Expression.Literal.Decimal decimal = 24;
inline bool Expression_Literal::has_decimal() const {
  return literal_type_case() == kDecimal;
}
inline void Expression_Literal::set_has_decimal() {
  _oneof_case_[0] = kDecimal;
}
inline void Expression_Literal::clear_decimal() {
  if (has_decimal()) {
    delete literal_type_.decimal_;
    clear_has_literal_type();
  }
}
inline const ::substrait::Expression_Literal_Decimal& Expression_Literal::_internal_decimal() const {
  return *literal_type_.decimal_;
}
inline ::substrait::Expression_Literal_Decimal* Expression_Literal::release_decimal() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.decimal)
  if (has_decimal()) {
    clear_has_literal_type();
      ::substrait::Expression_Literal_Decimal* temp = literal_type_.decimal_;
    literal_type_.decimal_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_Literal_Decimal& Expression_Literal::decimal() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.decimal)
  return has_decimal()
      ? *literal_type_.decimal_
      : *reinterpret_cast< ::substrait::Expression_Literal_Decimal*>(&::substrait::_Expression_Literal_Decimal_default_instance_);
}
inline ::substrait::Expression_Literal_Decimal* Expression_Literal::mutable_decimal() {
  if (!has_decimal()) {
    clear_literal_type();
    set_has_decimal();
    literal_type_.decimal_ = CreateMaybeMessage< ::substrait::Expression_Literal_Decimal >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.decimal)
  return literal_type_.decimal_;
}

// .substrait.Expression.Literal.Struct struct = 25;
inline bool Expression_Literal::has_struct_() const {
  return literal_type_case() == kStruct;
}
inline void Expression_Literal::set_has_struct_() {
  _oneof_case_[0] = kStruct;
}
inline void Expression_Literal::clear_struct_() {
  if (has_struct_()) {
    delete literal_type_.struct__;
    clear_has_literal_type();
  }
}
inline const ::substrait::Expression_Literal_Struct& Expression_Literal::_internal_struct_() const {
  return *literal_type_.struct__;
}
inline ::substrait::Expression_Literal_Struct* Expression_Literal::release_struct_() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.struct)
  if (has_struct_()) {
    clear_has_literal_type();
      ::substrait::Expression_Literal_Struct* temp = literal_type_.struct__;
    literal_type_.struct__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_Literal_Struct& Expression_Literal::struct_() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.struct)
  return has_struct_()
      ? *literal_type_.struct__
      : *reinterpret_cast< ::substrait::Expression_Literal_Struct*>(&::substrait::_Expression_Literal_Struct_default_instance_);
}
inline ::substrait::Expression_Literal_Struct* Expression_Literal::mutable_struct_() {
  if (!has_struct_()) {
    clear_literal_type();
    set_has_struct_();
    literal_type_.struct__ = CreateMaybeMessage< ::substrait::Expression_Literal_Struct >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.struct)
  return literal_type_.struct__;
}

// .substrait.Expression.Literal.Map map = 26;
inline bool Expression_Literal::has_map() const {
  return literal_type_case() == kMap;
}
inline void Expression_Literal::set_has_map() {
  _oneof_case_[0] = kMap;
}
inline void Expression_Literal::clear_map() {
  if (has_map()) {
    delete literal_type_.map_;
    clear_has_literal_type();
  }
}
inline const ::substrait::Expression_Literal_Map& Expression_Literal::_internal_map() const {
  return *literal_type_.map_;
}
inline ::substrait::Expression_Literal_Map* Expression_Literal::release_map() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.map)
  if (has_map()) {
    clear_has_literal_type();
      ::substrait::Expression_Literal_Map* temp = literal_type_.map_;
    literal_type_.map_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_Literal_Map& Expression_Literal::map() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.map)
  return has_map()
      ? *literal_type_.map_
      : *reinterpret_cast< ::substrait::Expression_Literal_Map*>(&::substrait::_Expression_Literal_Map_default_instance_);
}
inline ::substrait::Expression_Literal_Map* Expression_Literal::mutable_map() {
  if (!has_map()) {
    clear_literal_type();
    set_has_map();
    literal_type_.map_ = CreateMaybeMessage< ::substrait::Expression_Literal_Map >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.map)
  return literal_type_.map_;
}

// int64 timestamp_tz = 27;
inline bool Expression_Literal::has_timestamp_tz() const {
  return literal_type_case() == kTimestampTz;
}
inline void Expression_Literal::set_has_timestamp_tz() {
  _oneof_case_[0] = kTimestampTz;
}
inline void Expression_Literal::clear_timestamp_tz() {
  if (has_timestamp_tz()) {
    literal_type_.timestamp_tz_ = GOOGLE_LONGLONG(0);
    clear_has_literal_type();
  }
}
inline ::google::protobuf::int64 Expression_Literal::timestamp_tz() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.timestamp_tz)
  if (has_timestamp_tz()) {
    return literal_type_.timestamp_tz_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void Expression_Literal::set_timestamp_tz(::google::protobuf::int64 value) {
  if (!has_timestamp_tz()) {
    clear_literal_type();
    set_has_timestamp_tz();
  }
  literal_type_.timestamp_tz_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.timestamp_tz)
}

// bytes uuid = 28;
inline bool Expression_Literal::has_uuid() const {
  return literal_type_case() == kUuid;
}
inline void Expression_Literal::set_has_uuid() {
  _oneof_case_[0] = kUuid;
}
inline void Expression_Literal::clear_uuid() {
  if (has_uuid()) {
    literal_type_.uuid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_literal_type();
  }
}
inline const ::std::string& Expression_Literal::uuid() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.uuid)
  if (has_uuid()) {
    return literal_type_.uuid_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Expression_Literal::set_uuid(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.uuid)
  if (!has_uuid()) {
    clear_literal_type();
    set_has_uuid();
    literal_type_.uuid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  literal_type_.uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.uuid)
}
#if LANG_CXX11
inline void Expression_Literal::set_uuid(::std::string&& value) {
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.uuid)
  if (!has_uuid()) {
    clear_literal_type();
    set_has_uuid();
    literal_type_.uuid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  literal_type_.uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:substrait.Expression.Literal.uuid)
}
#endif
inline void Expression_Literal::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_uuid()) {
    clear_literal_type();
    set_has_uuid();
    literal_type_.uuid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  literal_type_.uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:substrait.Expression.Literal.uuid)
}
inline void Expression_Literal::set_uuid(const void* value, size_t size) {
  if (!has_uuid()) {
    clear_literal_type();
    set_has_uuid();
    literal_type_.uuid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  literal_type_.uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:substrait.Expression.Literal.uuid)
}
inline ::std::string* Expression_Literal::mutable_uuid() {
  if (!has_uuid()) {
    clear_literal_type();
    set_has_uuid();
    literal_type_.uuid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.uuid)
  return literal_type_.uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Expression_Literal::release_uuid() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.uuid)
  if (has_uuid()) {
    clear_has_literal_type();
    return literal_type_.uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Expression_Literal::set_allocated_uuid(::std::string* uuid) {
  if (!has_uuid()) {
    literal_type_.uuid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_literal_type();
  if (uuid != NULL) {
    set_has_uuid();
    literal_type_.uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Literal.uuid)
}

// .substrait.Type null = 29;
inline bool Expression_Literal::has_null() const {
  return literal_type_case() == kNull;
}
inline void Expression_Literal::set_has_null() {
  _oneof_case_[0] = kNull;
}
inline const ::substrait::Type& Expression_Literal::_internal_null() const {
  return *literal_type_.null_;
}
inline ::substrait::Type* Expression_Literal::release_null() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.null)
  if (has_null()) {
    clear_has_literal_type();
      ::substrait::Type* temp = literal_type_.null_;
    literal_type_.null_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Type& Expression_Literal::null() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.null)
  return has_null()
      ? *literal_type_.null_
      : *reinterpret_cast< ::substrait::Type*>(&::substrait::_Type_default_instance_);
}
inline ::substrait::Type* Expression_Literal::mutable_null() {
  if (!has_null()) {
    clear_literal_type();
    set_has_null();
    literal_type_.null_ = CreateMaybeMessage< ::substrait::Type >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.null)
  return literal_type_.null_;
}

// .substrait.Expression.Literal.List list = 30;
inline bool Expression_Literal::has_list() const {
  return literal_type_case() == kList;
}
inline void Expression_Literal::set_has_list() {
  _oneof_case_[0] = kList;
}
inline void Expression_Literal::clear_list() {
  if (has_list()) {
    delete literal_type_.list_;
    clear_has_literal_type();
  }
}
inline const ::substrait::Expression_Literal_List& Expression_Literal::_internal_list() const {
  return *literal_type_.list_;
}
inline ::substrait::Expression_Literal_List* Expression_Literal::release_list() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.list)
  if (has_list()) {
    clear_has_literal_type();
      ::substrait::Expression_Literal_List* temp = literal_type_.list_;
    literal_type_.list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_Literal_List& Expression_Literal::list() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.list)
  return has_list()
      ? *literal_type_.list_
      : *reinterpret_cast< ::substrait::Expression_Literal_List*>(&::substrait::_Expression_Literal_List_default_instance_);
}
inline ::substrait::Expression_Literal_List* Expression_Literal::mutable_list() {
  if (!has_list()) {
    clear_literal_type();
    set_has_list();
    literal_type_.list_ = CreateMaybeMessage< ::substrait::Expression_Literal_List >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.list)
  return literal_type_.list_;
}

// .substrait.Type.List empty_list = 31;
inline bool Expression_Literal::has_empty_list() const {
  return literal_type_case() == kEmptyList;
}
inline void Expression_Literal::set_has_empty_list() {
  _oneof_case_[0] = kEmptyList;
}
inline const ::substrait::Type_List& Expression_Literal::_internal_empty_list() const {
  return *literal_type_.empty_list_;
}
inline ::substrait::Type_List* Expression_Literal::release_empty_list() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.empty_list)
  if (has_empty_list()) {
    clear_has_literal_type();
      ::substrait::Type_List* temp = literal_type_.empty_list_;
    literal_type_.empty_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Type_List& Expression_Literal::empty_list() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.empty_list)
  return has_empty_list()
      ? *literal_type_.empty_list_
      : *reinterpret_cast< ::substrait::Type_List*>(&::substrait::_Type_List_default_instance_);
}
inline ::substrait::Type_List* Expression_Literal::mutable_empty_list() {
  if (!has_empty_list()) {
    clear_literal_type();
    set_has_empty_list();
    literal_type_.empty_list_ = CreateMaybeMessage< ::substrait::Type_List >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.empty_list)
  return literal_type_.empty_list_;
}

// .substrait.Type.Map empty_map = 32;
inline bool Expression_Literal::has_empty_map() const {
  return literal_type_case() == kEmptyMap;
}
inline void Expression_Literal::set_has_empty_map() {
  _oneof_case_[0] = kEmptyMap;
}
inline const ::substrait::Type_Map& Expression_Literal::_internal_empty_map() const {
  return *literal_type_.empty_map_;
}
inline ::substrait::Type_Map* Expression_Literal::release_empty_map() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.empty_map)
  if (has_empty_map()) {
    clear_has_literal_type();
      ::substrait::Type_Map* temp = literal_type_.empty_map_;
    literal_type_.empty_map_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Type_Map& Expression_Literal::empty_map() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.empty_map)
  return has_empty_map()
      ? *literal_type_.empty_map_
      : *reinterpret_cast< ::substrait::Type_Map*>(&::substrait::_Type_Map_default_instance_);
}
inline ::substrait::Type_Map* Expression_Literal::mutable_empty_map() {
  if (!has_empty_map()) {
    clear_literal_type();
    set_has_empty_map();
    literal_type_.empty_map_ = CreateMaybeMessage< ::substrait::Type_Map >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.empty_map)
  return literal_type_.empty_map_;
}

// .substrait.Expression.Literal.UserDefined user_defined = 33;
inline bool Expression_Literal::has_user_defined() const {
  return literal_type_case() == kUserDefined;
}
inline void Expression_Literal::set_has_user_defined() {
  _oneof_case_[0] = kUserDefined;
}
inline void Expression_Literal::clear_user_defined() {
  if (has_user_defined()) {
    delete literal_type_.user_defined_;
    clear_has_literal_type();
  }
}
inline const ::substrait::Expression_Literal_UserDefined& Expression_Literal::_internal_user_defined() const {
  return *literal_type_.user_defined_;
}
inline ::substrait::Expression_Literal_UserDefined* Expression_Literal::release_user_defined() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Literal.user_defined)
  if (has_user_defined()) {
    clear_has_literal_type();
      ::substrait::Expression_Literal_UserDefined* temp = literal_type_.user_defined_;
    literal_type_.user_defined_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_Literal_UserDefined& Expression_Literal::user_defined() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.user_defined)
  return has_user_defined()
      ? *literal_type_.user_defined_
      : *reinterpret_cast< ::substrait::Expression_Literal_UserDefined*>(&::substrait::_Expression_Literal_UserDefined_default_instance_);
}
inline ::substrait::Expression_Literal_UserDefined* Expression_Literal::mutable_user_defined() {
  if (!has_user_defined()) {
    clear_literal_type();
    set_has_user_defined();
    literal_type_.user_defined_ = CreateMaybeMessage< ::substrait::Expression_Literal_UserDefined >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Literal.user_defined)
  return literal_type_.user_defined_;
}

// bool nullable = 50;
inline void Expression_Literal::clear_nullable() {
  nullable_ = false;
}
inline bool Expression_Literal::nullable() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.nullable)
  return nullable_;
}
inline void Expression_Literal::set_nullable(bool value) {
  
  nullable_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.nullable)
}

// uint32 type_variation_reference = 51;
inline void Expression_Literal::clear_type_variation_reference() {
  type_variation_reference_ = 0u;
}
inline ::google::protobuf::uint32 Expression_Literal::type_variation_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Literal.type_variation_reference)
  return type_variation_reference_;
}
inline void Expression_Literal::set_type_variation_reference(::google::protobuf::uint32 value) {
  
  type_variation_reference_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Literal.type_variation_reference)
}

inline bool Expression_Literal::has_literal_type() const {
  return literal_type_case() != LITERAL_TYPE_NOT_SET;
}
inline void Expression_Literal::clear_has_literal_type() {
  _oneof_case_[0] = LITERAL_TYPE_NOT_SET;
}
inline Expression_Literal::LiteralTypeCase Expression_Literal::literal_type_case() const {
  return Expression_Literal::LiteralTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Expression_Nested_Map_KeyValue

// .substrait.Expression key = 1;
inline bool Expression_Nested_Map_KeyValue::has_key() const {
  return this != internal_default_instance() && key_ != NULL;
}
inline void Expression_Nested_Map_KeyValue::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) {
    delete key_;
  }
  key_ = NULL;
}
inline const ::substrait::Expression& Expression_Nested_Map_KeyValue::_internal_key() const {
  return *key_;
}
inline const ::substrait::Expression& Expression_Nested_Map_KeyValue::key() const {
  const ::substrait::Expression* p = key_;
  // @@protoc_insertion_point(field_get:substrait.Expression.Nested.Map.KeyValue.key)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression*>(
      &::substrait::_Expression_default_instance_);
}
inline ::substrait::Expression* Expression_Nested_Map_KeyValue::release_key() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Nested.Map.KeyValue.key)
  
  ::substrait::Expression* temp = key_;
  key_ = NULL;
  return temp;
}
inline ::substrait::Expression* Expression_Nested_Map_KeyValue::mutable_key() {
  
  if (key_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression>(GetArenaNoVirtual());
    key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Nested.Map.KeyValue.key)
  return key_;
}
inline void Expression_Nested_Map_KeyValue::set_allocated_key(::substrait::Expression* key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete key_;
  }
  if (key) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    
  } else {
    
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Nested.Map.KeyValue.key)
}

// .substrait.Expression value = 2;
inline bool Expression_Nested_Map_KeyValue::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline void Expression_Nested_Map_KeyValue::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) {
    delete value_;
  }
  value_ = NULL;
}
inline const ::substrait::Expression& Expression_Nested_Map_KeyValue::_internal_value() const {
  return *value_;
}
inline const ::substrait::Expression& Expression_Nested_Map_KeyValue::value() const {
  const ::substrait::Expression* p = value_;
  // @@protoc_insertion_point(field_get:substrait.Expression.Nested.Map.KeyValue.value)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression*>(
      &::substrait::_Expression_default_instance_);
}
inline ::substrait::Expression* Expression_Nested_Map_KeyValue::release_value() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Nested.Map.KeyValue.value)
  
  ::substrait::Expression* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::substrait::Expression* Expression_Nested_Map_KeyValue::mutable_value() {
  
  if (value_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Nested.Map.KeyValue.value)
  return value_;
}
inline void Expression_Nested_Map_KeyValue::set_allocated_value(::substrait::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete value_;
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Nested.Map.KeyValue.value)
}

// -------------------------------------------------------------------

// Expression_Nested_Map

// repeated .substrait.Expression.Nested.Map.KeyValue key_values = 1;
inline int Expression_Nested_Map::key_values_size() const {
  return key_values_.size();
}
inline void Expression_Nested_Map::clear_key_values() {
  key_values_.Clear();
}
inline ::substrait::Expression_Nested_Map_KeyValue* Expression_Nested_Map::mutable_key_values(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Nested.Map.key_values)
  return key_values_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::Expression_Nested_Map_KeyValue >*
Expression_Nested_Map::mutable_key_values() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.Nested.Map.key_values)
  return &key_values_;
}
inline const ::substrait::Expression_Nested_Map_KeyValue& Expression_Nested_Map::key_values(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Nested.Map.key_values)
  return key_values_.Get(index);
}
inline ::substrait::Expression_Nested_Map_KeyValue* Expression_Nested_Map::add_key_values() {
  // @@protoc_insertion_point(field_add:substrait.Expression.Nested.Map.key_values)
  return key_values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::Expression_Nested_Map_KeyValue >&
Expression_Nested_Map::key_values() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.Nested.Map.key_values)
  return key_values_;
}

// -------------------------------------------------------------------

// Expression_Nested_Struct

// repeated .substrait.Expression fields = 1;
inline int Expression_Nested_Struct::fields_size() const {
  return fields_.size();
}
inline void Expression_Nested_Struct::clear_fields() {
  fields_.Clear();
}
inline ::substrait::Expression* Expression_Nested_Struct::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Nested.Struct.fields)
  return fields_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::Expression >*
Expression_Nested_Struct::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.Nested.Struct.fields)
  return &fields_;
}
inline const ::substrait::Expression& Expression_Nested_Struct::fields(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Nested.Struct.fields)
  return fields_.Get(index);
}
inline ::substrait::Expression* Expression_Nested_Struct::add_fields() {
  // @@protoc_insertion_point(field_add:substrait.Expression.Nested.Struct.fields)
  return fields_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::Expression >&
Expression_Nested_Struct::fields() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.Nested.Struct.fields)
  return fields_;
}

// -------------------------------------------------------------------

// Expression_Nested_List

// repeated .substrait.Expression values = 1;
inline int Expression_Nested_List::values_size() const {
  return values_.size();
}
inline void Expression_Nested_List::clear_values() {
  values_.Clear();
}
inline ::substrait::Expression* Expression_Nested_List::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Nested.List.values)
  return values_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::Expression >*
Expression_Nested_List::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.Nested.List.values)
  return &values_;
}
inline const ::substrait::Expression& Expression_Nested_List::values(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Nested.List.values)
  return values_.Get(index);
}
inline ::substrait::Expression* Expression_Nested_List::add_values() {
  // @@protoc_insertion_point(field_add:substrait.Expression.Nested.List.values)
  return values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::Expression >&
Expression_Nested_List::values() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.Nested.List.values)
  return values_;
}

// -------------------------------------------------------------------

// Expression_Nested

// bool nullable = 1;
inline void Expression_Nested::clear_nullable() {
  nullable_ = false;
}
inline bool Expression_Nested::nullable() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Nested.nullable)
  return nullable_;
}
inline void Expression_Nested::set_nullable(bool value) {
  
  nullable_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Nested.nullable)
}

// uint32 type_variation_reference = 2;
inline void Expression_Nested::clear_type_variation_reference() {
  type_variation_reference_ = 0u;
}
inline ::google::protobuf::uint32 Expression_Nested::type_variation_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Nested.type_variation_reference)
  return type_variation_reference_;
}
inline void Expression_Nested::set_type_variation_reference(::google::protobuf::uint32 value) {
  
  type_variation_reference_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Nested.type_variation_reference)
}

// .substrait.Expression.Nested.Struct struct = 3;
inline bool Expression_Nested::has_struct_() const {
  return nested_type_case() == kStruct;
}
inline void Expression_Nested::set_has_struct_() {
  _oneof_case_[0] = kStruct;
}
inline void Expression_Nested::clear_struct_() {
  if (has_struct_()) {
    delete nested_type_.struct__;
    clear_has_nested_type();
  }
}
inline const ::substrait::Expression_Nested_Struct& Expression_Nested::_internal_struct_() const {
  return *nested_type_.struct__;
}
inline ::substrait::Expression_Nested_Struct* Expression_Nested::release_struct_() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Nested.struct)
  if (has_struct_()) {
    clear_has_nested_type();
      ::substrait::Expression_Nested_Struct* temp = nested_type_.struct__;
    nested_type_.struct__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_Nested_Struct& Expression_Nested::struct_() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Nested.struct)
  return has_struct_()
      ? *nested_type_.struct__
      : *reinterpret_cast< ::substrait::Expression_Nested_Struct*>(&::substrait::_Expression_Nested_Struct_default_instance_);
}
inline ::substrait::Expression_Nested_Struct* Expression_Nested::mutable_struct_() {
  if (!has_struct_()) {
    clear_nested_type();
    set_has_struct_();
    nested_type_.struct__ = CreateMaybeMessage< ::substrait::Expression_Nested_Struct >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Nested.struct)
  return nested_type_.struct__;
}

// .substrait.Expression.Nested.List list = 4;
inline bool Expression_Nested::has_list() const {
  return nested_type_case() == kList;
}
inline void Expression_Nested::set_has_list() {
  _oneof_case_[0] = kList;
}
inline void Expression_Nested::clear_list() {
  if (has_list()) {
    delete nested_type_.list_;
    clear_has_nested_type();
  }
}
inline const ::substrait::Expression_Nested_List& Expression_Nested::_internal_list() const {
  return *nested_type_.list_;
}
inline ::substrait::Expression_Nested_List* Expression_Nested::release_list() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Nested.list)
  if (has_list()) {
    clear_has_nested_type();
      ::substrait::Expression_Nested_List* temp = nested_type_.list_;
    nested_type_.list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_Nested_List& Expression_Nested::list() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Nested.list)
  return has_list()
      ? *nested_type_.list_
      : *reinterpret_cast< ::substrait::Expression_Nested_List*>(&::substrait::_Expression_Nested_List_default_instance_);
}
inline ::substrait::Expression_Nested_List* Expression_Nested::mutable_list() {
  if (!has_list()) {
    clear_nested_type();
    set_has_list();
    nested_type_.list_ = CreateMaybeMessage< ::substrait::Expression_Nested_List >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Nested.list)
  return nested_type_.list_;
}

// .substrait.Expression.Nested.Map map = 5;
inline bool Expression_Nested::has_map() const {
  return nested_type_case() == kMap;
}
inline void Expression_Nested::set_has_map() {
  _oneof_case_[0] = kMap;
}
inline void Expression_Nested::clear_map() {
  if (has_map()) {
    delete nested_type_.map_;
    clear_has_nested_type();
  }
}
inline const ::substrait::Expression_Nested_Map& Expression_Nested::_internal_map() const {
  return *nested_type_.map_;
}
inline ::substrait::Expression_Nested_Map* Expression_Nested::release_map() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Nested.map)
  if (has_map()) {
    clear_has_nested_type();
      ::substrait::Expression_Nested_Map* temp = nested_type_.map_;
    nested_type_.map_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_Nested_Map& Expression_Nested::map() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Nested.map)
  return has_map()
      ? *nested_type_.map_
      : *reinterpret_cast< ::substrait::Expression_Nested_Map*>(&::substrait::_Expression_Nested_Map_default_instance_);
}
inline ::substrait::Expression_Nested_Map* Expression_Nested::mutable_map() {
  if (!has_map()) {
    clear_nested_type();
    set_has_map();
    nested_type_.map_ = CreateMaybeMessage< ::substrait::Expression_Nested_Map >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Nested.map)
  return nested_type_.map_;
}

inline bool Expression_Nested::has_nested_type() const {
  return nested_type_case() != NESTED_TYPE_NOT_SET;
}
inline void Expression_Nested::clear_has_nested_type() {
  _oneof_case_[0] = NESTED_TYPE_NOT_SET;
}
inline Expression_Nested::NestedTypeCase Expression_Nested::nested_type_case() const {
  return Expression_Nested::NestedTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Expression_ScalarFunction

// uint32 function_reference = 1;
inline void Expression_ScalarFunction::clear_function_reference() {
  function_reference_ = 0u;
}
inline ::google::protobuf::uint32 Expression_ScalarFunction::function_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.ScalarFunction.function_reference)
  return function_reference_;
}
inline void Expression_ScalarFunction::set_function_reference(::google::protobuf::uint32 value) {
  
  function_reference_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.ScalarFunction.function_reference)
}

// repeated .substrait.FunctionArgument arguments = 4;
inline int Expression_ScalarFunction::arguments_size() const {
  return arguments_.size();
}
inline void Expression_ScalarFunction::clear_arguments() {
  arguments_.Clear();
}
inline ::substrait::FunctionArgument* Expression_ScalarFunction::mutable_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.ScalarFunction.arguments)
  return arguments_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::FunctionArgument >*
Expression_ScalarFunction::mutable_arguments() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.ScalarFunction.arguments)
  return &arguments_;
}
inline const ::substrait::FunctionArgument& Expression_ScalarFunction::arguments(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.ScalarFunction.arguments)
  return arguments_.Get(index);
}
inline ::substrait::FunctionArgument* Expression_ScalarFunction::add_arguments() {
  // @@protoc_insertion_point(field_add:substrait.Expression.ScalarFunction.arguments)
  return arguments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::FunctionArgument >&
Expression_ScalarFunction::arguments() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.ScalarFunction.arguments)
  return arguments_;
}

// repeated .substrait.FunctionOption options = 5;
inline int Expression_ScalarFunction::options_size() const {
  return options_.size();
}
inline void Expression_ScalarFunction::clear_options() {
  options_.Clear();
}
inline ::substrait::FunctionOption* Expression_ScalarFunction::mutable_options(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.ScalarFunction.options)
  return options_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::FunctionOption >*
Expression_ScalarFunction::mutable_options() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.ScalarFunction.options)
  return &options_;
}
inline const ::substrait::FunctionOption& Expression_ScalarFunction::options(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.ScalarFunction.options)
  return options_.Get(index);
}
inline ::substrait::FunctionOption* Expression_ScalarFunction::add_options() {
  // @@protoc_insertion_point(field_add:substrait.Expression.ScalarFunction.options)
  return options_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::FunctionOption >&
Expression_ScalarFunction::options() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.ScalarFunction.options)
  return options_;
}

// .substrait.Type output_type = 3;
inline bool Expression_ScalarFunction::has_output_type() const {
  return this != internal_default_instance() && output_type_ != NULL;
}
inline const ::substrait::Type& Expression_ScalarFunction::_internal_output_type() const {
  return *output_type_;
}
inline const ::substrait::Type& Expression_ScalarFunction::output_type() const {
  const ::substrait::Type* p = output_type_;
  // @@protoc_insertion_point(field_get:substrait.Expression.ScalarFunction.output_type)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Type*>(
      &::substrait::_Type_default_instance_);
}
inline ::substrait::Type* Expression_ScalarFunction::release_output_type() {
  // @@protoc_insertion_point(field_release:substrait.Expression.ScalarFunction.output_type)
  
  ::substrait::Type* temp = output_type_;
  output_type_ = NULL;
  return temp;
}
inline ::substrait::Type* Expression_ScalarFunction::mutable_output_type() {
  
  if (output_type_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Type>(GetArenaNoVirtual());
    output_type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.ScalarFunction.output_type)
  return output_type_;
}
inline void Expression_ScalarFunction::set_allocated_output_type(::substrait::Type* output_type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(output_type_);
  }
  if (output_type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      output_type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, output_type, submessage_arena);
    }
    
  } else {
    
  }
  output_type_ = output_type;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.ScalarFunction.output_type)
}

// repeated .substrait.Expression args = 2 [deprecated = true];
inline int Expression_ScalarFunction::args_size() const {
  return args_.size();
}
inline void Expression_ScalarFunction::clear_args() {
  args_.Clear();
}
inline ::substrait::Expression* Expression_ScalarFunction::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.ScalarFunction.args)
  return args_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::Expression >*
Expression_ScalarFunction::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.ScalarFunction.args)
  return &args_;
}
inline const ::substrait::Expression& Expression_ScalarFunction::args(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.ScalarFunction.args)
  return args_.Get(index);
}
inline ::substrait::Expression* Expression_ScalarFunction::add_args() {
  // @@protoc_insertion_point(field_add:substrait.Expression.ScalarFunction.args)
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::Expression >&
Expression_ScalarFunction::args() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.ScalarFunction.args)
  return args_;
}

// -------------------------------------------------------------------

// Expression_WindowFunction_Bound_Preceding

// int64 offset = 1;
inline void Expression_WindowFunction_Bound_Preceding::clear_offset() {
  offset_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Expression_WindowFunction_Bound_Preceding::offset() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.Bound.Preceding.offset)
  return offset_;
}
inline void Expression_WindowFunction_Bound_Preceding::set_offset(::google::protobuf::int64 value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.WindowFunction.Bound.Preceding.offset)
}

// -------------------------------------------------------------------

// Expression_WindowFunction_Bound_Following

// int64 offset = 1;
inline void Expression_WindowFunction_Bound_Following::clear_offset() {
  offset_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Expression_WindowFunction_Bound_Following::offset() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.Bound.Following.offset)
  return offset_;
}
inline void Expression_WindowFunction_Bound_Following::set_offset(::google::protobuf::int64 value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.WindowFunction.Bound.Following.offset)
}

// -------------------------------------------------------------------

// Expression_WindowFunction_Bound_CurrentRow

// -------------------------------------------------------------------

// Expression_WindowFunction_Bound_Unbounded

// -------------------------------------------------------------------

// Expression_WindowFunction_Bound

// .substrait.Expression.WindowFunction.Bound.Preceding preceding = 1;
inline bool Expression_WindowFunction_Bound::has_preceding() const {
  return kind_case() == kPreceding;
}
inline void Expression_WindowFunction_Bound::set_has_preceding() {
  _oneof_case_[0] = kPreceding;
}
inline void Expression_WindowFunction_Bound::clear_preceding() {
  if (has_preceding()) {
    delete kind_.preceding_;
    clear_has_kind();
  }
}
inline const ::substrait::Expression_WindowFunction_Bound_Preceding& Expression_WindowFunction_Bound::_internal_preceding() const {
  return *kind_.preceding_;
}
inline ::substrait::Expression_WindowFunction_Bound_Preceding* Expression_WindowFunction_Bound::release_preceding() {
  // @@protoc_insertion_point(field_release:substrait.Expression.WindowFunction.Bound.preceding)
  if (has_preceding()) {
    clear_has_kind();
      ::substrait::Expression_WindowFunction_Bound_Preceding* temp = kind_.preceding_;
    kind_.preceding_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_WindowFunction_Bound_Preceding& Expression_WindowFunction_Bound::preceding() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.Bound.preceding)
  return has_preceding()
      ? *kind_.preceding_
      : *reinterpret_cast< ::substrait::Expression_WindowFunction_Bound_Preceding*>(&::substrait::_Expression_WindowFunction_Bound_Preceding_default_instance_);
}
inline ::substrait::Expression_WindowFunction_Bound_Preceding* Expression_WindowFunction_Bound::mutable_preceding() {
  if (!has_preceding()) {
    clear_kind();
    set_has_preceding();
    kind_.preceding_ = CreateMaybeMessage< ::substrait::Expression_WindowFunction_Bound_Preceding >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.WindowFunction.Bound.preceding)
  return kind_.preceding_;
}

// .substrait.Expression.WindowFunction.Bound.Following following = 2;
inline bool Expression_WindowFunction_Bound::has_following() const {
  return kind_case() == kFollowing;
}
inline void Expression_WindowFunction_Bound::set_has_following() {
  _oneof_case_[0] = kFollowing;
}
inline void Expression_WindowFunction_Bound::clear_following() {
  if (has_following()) {
    delete kind_.following_;
    clear_has_kind();
  }
}
inline const ::substrait::Expression_WindowFunction_Bound_Following& Expression_WindowFunction_Bound::_internal_following() const {
  return *kind_.following_;
}
inline ::substrait::Expression_WindowFunction_Bound_Following* Expression_WindowFunction_Bound::release_following() {
  // @@protoc_insertion_point(field_release:substrait.Expression.WindowFunction.Bound.following)
  if (has_following()) {
    clear_has_kind();
      ::substrait::Expression_WindowFunction_Bound_Following* temp = kind_.following_;
    kind_.following_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_WindowFunction_Bound_Following& Expression_WindowFunction_Bound::following() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.Bound.following)
  return has_following()
      ? *kind_.following_
      : *reinterpret_cast< ::substrait::Expression_WindowFunction_Bound_Following*>(&::substrait::_Expression_WindowFunction_Bound_Following_default_instance_);
}
inline ::substrait::Expression_WindowFunction_Bound_Following* Expression_WindowFunction_Bound::mutable_following() {
  if (!has_following()) {
    clear_kind();
    set_has_following();
    kind_.following_ = CreateMaybeMessage< ::substrait::Expression_WindowFunction_Bound_Following >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.WindowFunction.Bound.following)
  return kind_.following_;
}

// .substrait.Expression.WindowFunction.Bound.CurrentRow current_row = 3;
inline bool Expression_WindowFunction_Bound::has_current_row() const {
  return kind_case() == kCurrentRow;
}
inline void Expression_WindowFunction_Bound::set_has_current_row() {
  _oneof_case_[0] = kCurrentRow;
}
inline void Expression_WindowFunction_Bound::clear_current_row() {
  if (has_current_row()) {
    delete kind_.current_row_;
    clear_has_kind();
  }
}
inline const ::substrait::Expression_WindowFunction_Bound_CurrentRow& Expression_WindowFunction_Bound::_internal_current_row() const {
  return *kind_.current_row_;
}
inline ::substrait::Expression_WindowFunction_Bound_CurrentRow* Expression_WindowFunction_Bound::release_current_row() {
  // @@protoc_insertion_point(field_release:substrait.Expression.WindowFunction.Bound.current_row)
  if (has_current_row()) {
    clear_has_kind();
      ::substrait::Expression_WindowFunction_Bound_CurrentRow* temp = kind_.current_row_;
    kind_.current_row_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_WindowFunction_Bound_CurrentRow& Expression_WindowFunction_Bound::current_row() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.Bound.current_row)
  return has_current_row()
      ? *kind_.current_row_
      : *reinterpret_cast< ::substrait::Expression_WindowFunction_Bound_CurrentRow*>(&::substrait::_Expression_WindowFunction_Bound_CurrentRow_default_instance_);
}
inline ::substrait::Expression_WindowFunction_Bound_CurrentRow* Expression_WindowFunction_Bound::mutable_current_row() {
  if (!has_current_row()) {
    clear_kind();
    set_has_current_row();
    kind_.current_row_ = CreateMaybeMessage< ::substrait::Expression_WindowFunction_Bound_CurrentRow >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.WindowFunction.Bound.current_row)
  return kind_.current_row_;
}

// .substrait.Expression.WindowFunction.Bound.Unbounded unbounded = 4;
inline bool Expression_WindowFunction_Bound::has_unbounded() const {
  return kind_case() == kUnbounded;
}
inline void Expression_WindowFunction_Bound::set_has_unbounded() {
  _oneof_case_[0] = kUnbounded;
}
inline void Expression_WindowFunction_Bound::clear_unbounded() {
  if (has_unbounded()) {
    delete kind_.unbounded_;
    clear_has_kind();
  }
}
inline const ::substrait::Expression_WindowFunction_Bound_Unbounded& Expression_WindowFunction_Bound::_internal_unbounded() const {
  return *kind_.unbounded_;
}
inline ::substrait::Expression_WindowFunction_Bound_Unbounded* Expression_WindowFunction_Bound::release_unbounded() {
  // @@protoc_insertion_point(field_release:substrait.Expression.WindowFunction.Bound.unbounded)
  if (has_unbounded()) {
    clear_has_kind();
      ::substrait::Expression_WindowFunction_Bound_Unbounded* temp = kind_.unbounded_;
    kind_.unbounded_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_WindowFunction_Bound_Unbounded& Expression_WindowFunction_Bound::unbounded() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.Bound.unbounded)
  return has_unbounded()
      ? *kind_.unbounded_
      : *reinterpret_cast< ::substrait::Expression_WindowFunction_Bound_Unbounded*>(&::substrait::_Expression_WindowFunction_Bound_Unbounded_default_instance_);
}
inline ::substrait::Expression_WindowFunction_Bound_Unbounded* Expression_WindowFunction_Bound::mutable_unbounded() {
  if (!has_unbounded()) {
    clear_kind();
    set_has_unbounded();
    kind_.unbounded_ = CreateMaybeMessage< ::substrait::Expression_WindowFunction_Bound_Unbounded >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.WindowFunction.Bound.unbounded)
  return kind_.unbounded_;
}

inline bool Expression_WindowFunction_Bound::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void Expression_WindowFunction_Bound::clear_has_kind() {
  _oneof_case_[0] = KIND_NOT_SET;
}
inline Expression_WindowFunction_Bound::KindCase Expression_WindowFunction_Bound::kind_case() const {
  return Expression_WindowFunction_Bound::KindCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Expression_WindowFunction

// uint32 function_reference = 1;
inline void Expression_WindowFunction::clear_function_reference() {
  function_reference_ = 0u;
}
inline ::google::protobuf::uint32 Expression_WindowFunction::function_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.function_reference)
  return function_reference_;
}
inline void Expression_WindowFunction::set_function_reference(::google::protobuf::uint32 value) {
  
  function_reference_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.WindowFunction.function_reference)
}

// repeated .substrait.FunctionArgument arguments = 9;
inline int Expression_WindowFunction::arguments_size() const {
  return arguments_.size();
}
inline void Expression_WindowFunction::clear_arguments() {
  arguments_.Clear();
}
inline ::substrait::FunctionArgument* Expression_WindowFunction::mutable_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.WindowFunction.arguments)
  return arguments_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::FunctionArgument >*
Expression_WindowFunction::mutable_arguments() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.WindowFunction.arguments)
  return &arguments_;
}
inline const ::substrait::FunctionArgument& Expression_WindowFunction::arguments(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.arguments)
  return arguments_.Get(index);
}
inline ::substrait::FunctionArgument* Expression_WindowFunction::add_arguments() {
  // @@protoc_insertion_point(field_add:substrait.Expression.WindowFunction.arguments)
  return arguments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::FunctionArgument >&
Expression_WindowFunction::arguments() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.WindowFunction.arguments)
  return arguments_;
}

// repeated .substrait.FunctionOption options = 11;
inline int Expression_WindowFunction::options_size() const {
  return options_.size();
}
inline void Expression_WindowFunction::clear_options() {
  options_.Clear();
}
inline ::substrait::FunctionOption* Expression_WindowFunction::mutable_options(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.WindowFunction.options)
  return options_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::FunctionOption >*
Expression_WindowFunction::mutable_options() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.WindowFunction.options)
  return &options_;
}
inline const ::substrait::FunctionOption& Expression_WindowFunction::options(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.options)
  return options_.Get(index);
}
inline ::substrait::FunctionOption* Expression_WindowFunction::add_options() {
  // @@protoc_insertion_point(field_add:substrait.Expression.WindowFunction.options)
  return options_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::FunctionOption >&
Expression_WindowFunction::options() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.WindowFunction.options)
  return options_;
}

// .substrait.Type output_type = 7;
inline bool Expression_WindowFunction::has_output_type() const {
  return this != internal_default_instance() && output_type_ != NULL;
}
inline const ::substrait::Type& Expression_WindowFunction::_internal_output_type() const {
  return *output_type_;
}
inline const ::substrait::Type& Expression_WindowFunction::output_type() const {
  const ::substrait::Type* p = output_type_;
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.output_type)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Type*>(
      &::substrait::_Type_default_instance_);
}
inline ::substrait::Type* Expression_WindowFunction::release_output_type() {
  // @@protoc_insertion_point(field_release:substrait.Expression.WindowFunction.output_type)
  
  ::substrait::Type* temp = output_type_;
  output_type_ = NULL;
  return temp;
}
inline ::substrait::Type* Expression_WindowFunction::mutable_output_type() {
  
  if (output_type_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Type>(GetArenaNoVirtual());
    output_type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.WindowFunction.output_type)
  return output_type_;
}
inline void Expression_WindowFunction::set_allocated_output_type(::substrait::Type* output_type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(output_type_);
  }
  if (output_type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      output_type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, output_type, submessage_arena);
    }
    
  } else {
    
  }
  output_type_ = output_type;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.WindowFunction.output_type)
}

// .substrait.AggregationPhase phase = 6;
inline void Expression_WindowFunction::clear_phase() {
  phase_ = 0;
}
inline ::substrait::AggregationPhase Expression_WindowFunction::phase() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.phase)
  return static_cast< ::substrait::AggregationPhase >(phase_);
}
inline void Expression_WindowFunction::set_phase(::substrait::AggregationPhase value) {
  
  phase_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.WindowFunction.phase)
}

// repeated .substrait.SortField sorts = 3;
inline int Expression_WindowFunction::sorts_size() const {
  return sorts_.size();
}
inline void Expression_WindowFunction::clear_sorts() {
  sorts_.Clear();
}
inline ::substrait::SortField* Expression_WindowFunction::mutable_sorts(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.WindowFunction.sorts)
  return sorts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::SortField >*
Expression_WindowFunction::mutable_sorts() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.WindowFunction.sorts)
  return &sorts_;
}
inline const ::substrait::SortField& Expression_WindowFunction::sorts(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.sorts)
  return sorts_.Get(index);
}
inline ::substrait::SortField* Expression_WindowFunction::add_sorts() {
  // @@protoc_insertion_point(field_add:substrait.Expression.WindowFunction.sorts)
  return sorts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::SortField >&
Expression_WindowFunction::sorts() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.WindowFunction.sorts)
  return sorts_;
}

// .substrait.AggregateFunction.AggregationInvocation invocation = 10;
inline void Expression_WindowFunction::clear_invocation() {
  invocation_ = 0;
}
inline ::substrait::AggregateFunction_AggregationInvocation Expression_WindowFunction::invocation() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.invocation)
  return static_cast< ::substrait::AggregateFunction_AggregationInvocation >(invocation_);
}
inline void Expression_WindowFunction::set_invocation(::substrait::AggregateFunction_AggregationInvocation value) {
  
  invocation_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.WindowFunction.invocation)
}

// repeated .substrait.Expression partitions = 2;
inline int Expression_WindowFunction::partitions_size() const {
  return partitions_.size();
}
inline void Expression_WindowFunction::clear_partitions() {
  partitions_.Clear();
}
inline ::substrait::Expression* Expression_WindowFunction::mutable_partitions(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.WindowFunction.partitions)
  return partitions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::Expression >*
Expression_WindowFunction::mutable_partitions() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.WindowFunction.partitions)
  return &partitions_;
}
inline const ::substrait::Expression& Expression_WindowFunction::partitions(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.partitions)
  return partitions_.Get(index);
}
inline ::substrait::Expression* Expression_WindowFunction::add_partitions() {
  // @@protoc_insertion_point(field_add:substrait.Expression.WindowFunction.partitions)
  return partitions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::Expression >&
Expression_WindowFunction::partitions() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.WindowFunction.partitions)
  return partitions_;
}

// .substrait.Expression.WindowFunction.Bound lower_bound = 5;
inline bool Expression_WindowFunction::has_lower_bound() const {
  return this != internal_default_instance() && lower_bound_ != NULL;
}
inline void Expression_WindowFunction::clear_lower_bound() {
  if (GetArenaNoVirtual() == NULL && lower_bound_ != NULL) {
    delete lower_bound_;
  }
  lower_bound_ = NULL;
}
inline const ::substrait::Expression_WindowFunction_Bound& Expression_WindowFunction::_internal_lower_bound() const {
  return *lower_bound_;
}
inline const ::substrait::Expression_WindowFunction_Bound& Expression_WindowFunction::lower_bound() const {
  const ::substrait::Expression_WindowFunction_Bound* p = lower_bound_;
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.lower_bound)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression_WindowFunction_Bound*>(
      &::substrait::_Expression_WindowFunction_Bound_default_instance_);
}
inline ::substrait::Expression_WindowFunction_Bound* Expression_WindowFunction::release_lower_bound() {
  // @@protoc_insertion_point(field_release:substrait.Expression.WindowFunction.lower_bound)
  
  ::substrait::Expression_WindowFunction_Bound* temp = lower_bound_;
  lower_bound_ = NULL;
  return temp;
}
inline ::substrait::Expression_WindowFunction_Bound* Expression_WindowFunction::mutable_lower_bound() {
  
  if (lower_bound_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression_WindowFunction_Bound>(GetArenaNoVirtual());
    lower_bound_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.WindowFunction.lower_bound)
  return lower_bound_;
}
inline void Expression_WindowFunction::set_allocated_lower_bound(::substrait::Expression_WindowFunction_Bound* lower_bound) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete lower_bound_;
  }
  if (lower_bound) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lower_bound = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lower_bound, submessage_arena);
    }
    
  } else {
    
  }
  lower_bound_ = lower_bound;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.WindowFunction.lower_bound)
}

// .substrait.Expression.WindowFunction.Bound upper_bound = 4;
inline bool Expression_WindowFunction::has_upper_bound() const {
  return this != internal_default_instance() && upper_bound_ != NULL;
}
inline void Expression_WindowFunction::clear_upper_bound() {
  if (GetArenaNoVirtual() == NULL && upper_bound_ != NULL) {
    delete upper_bound_;
  }
  upper_bound_ = NULL;
}
inline const ::substrait::Expression_WindowFunction_Bound& Expression_WindowFunction::_internal_upper_bound() const {
  return *upper_bound_;
}
inline const ::substrait::Expression_WindowFunction_Bound& Expression_WindowFunction::upper_bound() const {
  const ::substrait::Expression_WindowFunction_Bound* p = upper_bound_;
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.upper_bound)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression_WindowFunction_Bound*>(
      &::substrait::_Expression_WindowFunction_Bound_default_instance_);
}
inline ::substrait::Expression_WindowFunction_Bound* Expression_WindowFunction::release_upper_bound() {
  // @@protoc_insertion_point(field_release:substrait.Expression.WindowFunction.upper_bound)
  
  ::substrait::Expression_WindowFunction_Bound* temp = upper_bound_;
  upper_bound_ = NULL;
  return temp;
}
inline ::substrait::Expression_WindowFunction_Bound* Expression_WindowFunction::mutable_upper_bound() {
  
  if (upper_bound_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression_WindowFunction_Bound>(GetArenaNoVirtual());
    upper_bound_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.WindowFunction.upper_bound)
  return upper_bound_;
}
inline void Expression_WindowFunction::set_allocated_upper_bound(::substrait::Expression_WindowFunction_Bound* upper_bound) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete upper_bound_;
  }
  if (upper_bound) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      upper_bound = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, upper_bound, submessage_arena);
    }
    
  } else {
    
  }
  upper_bound_ = upper_bound;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.WindowFunction.upper_bound)
}

// repeated .substrait.Expression args = 8 [deprecated = true];
inline int Expression_WindowFunction::args_size() const {
  return args_.size();
}
inline void Expression_WindowFunction::clear_args() {
  args_.Clear();
}
inline ::substrait::Expression* Expression_WindowFunction::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.WindowFunction.args)
  return args_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::Expression >*
Expression_WindowFunction::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.WindowFunction.args)
  return &args_;
}
inline const ::substrait::Expression& Expression_WindowFunction::args(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.WindowFunction.args)
  return args_.Get(index);
}
inline ::substrait::Expression* Expression_WindowFunction::add_args() {
  // @@protoc_insertion_point(field_add:substrait.Expression.WindowFunction.args)
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::Expression >&
Expression_WindowFunction::args() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.WindowFunction.args)
  return args_;
}

// -------------------------------------------------------------------

// Expression_IfThen_IfClause

// .substrait.Expression if = 1;
inline bool Expression_IfThen_IfClause::has_if_() const {
  return this != internal_default_instance() && if__ != NULL;
}
inline void Expression_IfThen_IfClause::clear_if_() {
  if (GetArenaNoVirtual() == NULL && if__ != NULL) {
    delete if__;
  }
  if__ = NULL;
}
inline const ::substrait::Expression& Expression_IfThen_IfClause::_internal_if_() const {
  return *if__;
}
inline const ::substrait::Expression& Expression_IfThen_IfClause::if_() const {
  const ::substrait::Expression* p = if__;
  // @@protoc_insertion_point(field_get:substrait.Expression.IfThen.IfClause.if)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression*>(
      &::substrait::_Expression_default_instance_);
}
inline ::substrait::Expression* Expression_IfThen_IfClause::release_if_() {
  // @@protoc_insertion_point(field_release:substrait.Expression.IfThen.IfClause.if)
  
  ::substrait::Expression* temp = if__;
  if__ = NULL;
  return temp;
}
inline ::substrait::Expression* Expression_IfThen_IfClause::mutable_if_() {
  
  if (if__ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression>(GetArenaNoVirtual());
    if__ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.IfThen.IfClause.if)
  return if__;
}
inline void Expression_IfThen_IfClause::set_allocated_if_(::substrait::Expression* if_) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete if__;
  }
  if (if_) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      if_ = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, if_, submessage_arena);
    }
    
  } else {
    
  }
  if__ = if_;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.IfThen.IfClause.if)
}

// .substrait.Expression then = 2;
inline bool Expression_IfThen_IfClause::has_then() const {
  return this != internal_default_instance() && then_ != NULL;
}
inline void Expression_IfThen_IfClause::clear_then() {
  if (GetArenaNoVirtual() == NULL && then_ != NULL) {
    delete then_;
  }
  then_ = NULL;
}
inline const ::substrait::Expression& Expression_IfThen_IfClause::_internal_then() const {
  return *then_;
}
inline const ::substrait::Expression& Expression_IfThen_IfClause::then() const {
  const ::substrait::Expression* p = then_;
  // @@protoc_insertion_point(field_get:substrait.Expression.IfThen.IfClause.then)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression*>(
      &::substrait::_Expression_default_instance_);
}
inline ::substrait::Expression* Expression_IfThen_IfClause::release_then() {
  // @@protoc_insertion_point(field_release:substrait.Expression.IfThen.IfClause.then)
  
  ::substrait::Expression* temp = then_;
  then_ = NULL;
  return temp;
}
inline ::substrait::Expression* Expression_IfThen_IfClause::mutable_then() {
  
  if (then_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression>(GetArenaNoVirtual());
    then_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.IfThen.IfClause.then)
  return then_;
}
inline void Expression_IfThen_IfClause::set_allocated_then(::substrait::Expression* then) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete then_;
  }
  if (then) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      then = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, then, submessage_arena);
    }
    
  } else {
    
  }
  then_ = then;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.IfThen.IfClause.then)
}

// -------------------------------------------------------------------

// Expression_IfThen

// repeated .substrait.Expression.IfThen.IfClause ifs = 1;
inline int Expression_IfThen::ifs_size() const {
  return ifs_.size();
}
inline void Expression_IfThen::clear_ifs() {
  ifs_.Clear();
}
inline ::substrait::Expression_IfThen_IfClause* Expression_IfThen::mutable_ifs(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.IfThen.ifs)
  return ifs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::Expression_IfThen_IfClause >*
Expression_IfThen::mutable_ifs() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.IfThen.ifs)
  return &ifs_;
}
inline const ::substrait::Expression_IfThen_IfClause& Expression_IfThen::ifs(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.IfThen.ifs)
  return ifs_.Get(index);
}
inline ::substrait::Expression_IfThen_IfClause* Expression_IfThen::add_ifs() {
  // @@protoc_insertion_point(field_add:substrait.Expression.IfThen.ifs)
  return ifs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::Expression_IfThen_IfClause >&
Expression_IfThen::ifs() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.IfThen.ifs)
  return ifs_;
}

// .substrait.Expression else = 2;
inline bool Expression_IfThen::has_else_() const {
  return this != internal_default_instance() && else__ != NULL;
}
inline void Expression_IfThen::clear_else_() {
  if (GetArenaNoVirtual() == NULL && else__ != NULL) {
    delete else__;
  }
  else__ = NULL;
}
inline const ::substrait::Expression& Expression_IfThen::_internal_else_() const {
  return *else__;
}
inline const ::substrait::Expression& Expression_IfThen::else_() const {
  const ::substrait::Expression* p = else__;
  // @@protoc_insertion_point(field_get:substrait.Expression.IfThen.else)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression*>(
      &::substrait::_Expression_default_instance_);
}
inline ::substrait::Expression* Expression_IfThen::release_else_() {
  // @@protoc_insertion_point(field_release:substrait.Expression.IfThen.else)
  
  ::substrait::Expression* temp = else__;
  else__ = NULL;
  return temp;
}
inline ::substrait::Expression* Expression_IfThen::mutable_else_() {
  
  if (else__ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression>(GetArenaNoVirtual());
    else__ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.IfThen.else)
  return else__;
}
inline void Expression_IfThen::set_allocated_else_(::substrait::Expression* else_) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete else__;
  }
  if (else_) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      else_ = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, else_, submessage_arena);
    }
    
  } else {
    
  }
  else__ = else_;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.IfThen.else)
}

// -------------------------------------------------------------------

// Expression_Cast

// .substrait.Type type = 1;
inline bool Expression_Cast::has_type() const {
  return this != internal_default_instance() && type_ != NULL;
}
inline const ::substrait::Type& Expression_Cast::_internal_type() const {
  return *type_;
}
inline const ::substrait::Type& Expression_Cast::type() const {
  const ::substrait::Type* p = type_;
  // @@protoc_insertion_point(field_get:substrait.Expression.Cast.type)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Type*>(
      &::substrait::_Type_default_instance_);
}
inline ::substrait::Type* Expression_Cast::release_type() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Cast.type)
  
  ::substrait::Type* temp = type_;
  type_ = NULL;
  return temp;
}
inline ::substrait::Type* Expression_Cast::mutable_type() {
  
  if (type_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Type>(GetArenaNoVirtual());
    type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Cast.type)
  return type_;
}
inline void Expression_Cast::set_allocated_type(::substrait::Type* type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(type_);
  }
  if (type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Cast.type)
}

// .substrait.Expression input = 2;
inline bool Expression_Cast::has_input() const {
  return this != internal_default_instance() && input_ != NULL;
}
inline void Expression_Cast::clear_input() {
  if (GetArenaNoVirtual() == NULL && input_ != NULL) {
    delete input_;
  }
  input_ = NULL;
}
inline const ::substrait::Expression& Expression_Cast::_internal_input() const {
  return *input_;
}
inline const ::substrait::Expression& Expression_Cast::input() const {
  const ::substrait::Expression* p = input_;
  // @@protoc_insertion_point(field_get:substrait.Expression.Cast.input)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression*>(
      &::substrait::_Expression_default_instance_);
}
inline ::substrait::Expression* Expression_Cast::release_input() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Cast.input)
  
  ::substrait::Expression* temp = input_;
  input_ = NULL;
  return temp;
}
inline ::substrait::Expression* Expression_Cast::mutable_input() {
  
  if (input_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression>(GetArenaNoVirtual());
    input_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Cast.input)
  return input_;
}
inline void Expression_Cast::set_allocated_input(::substrait::Expression* input) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete input_;
  }
  if (input) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      input = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, input, submessage_arena);
    }
    
  } else {
    
  }
  input_ = input;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Cast.input)
}

// .substrait.Expression.Cast.FailureBehavior failure_behavior = 3;
inline void Expression_Cast::clear_failure_behavior() {
  failure_behavior_ = 0;
}
inline ::substrait::Expression_Cast_FailureBehavior Expression_Cast::failure_behavior() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Cast.failure_behavior)
  return static_cast< ::substrait::Expression_Cast_FailureBehavior >(failure_behavior_);
}
inline void Expression_Cast::set_failure_behavior(::substrait::Expression_Cast_FailureBehavior value) {
  
  failure_behavior_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Cast.failure_behavior)
}

// -------------------------------------------------------------------

// Expression_SwitchExpression_IfValue

// .substrait.Expression.Literal if = 1;
inline bool Expression_SwitchExpression_IfValue::has_if_() const {
  return this != internal_default_instance() && if__ != NULL;
}
inline void Expression_SwitchExpression_IfValue::clear_if_() {
  if (GetArenaNoVirtual() == NULL && if__ != NULL) {
    delete if__;
  }
  if__ = NULL;
}
inline const ::substrait::Expression_Literal& Expression_SwitchExpression_IfValue::_internal_if_() const {
  return *if__;
}
inline const ::substrait::Expression_Literal& Expression_SwitchExpression_IfValue::if_() const {
  const ::substrait::Expression_Literal* p = if__;
  // @@protoc_insertion_point(field_get:substrait.Expression.SwitchExpression.IfValue.if)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression_Literal*>(
      &::substrait::_Expression_Literal_default_instance_);
}
inline ::substrait::Expression_Literal* Expression_SwitchExpression_IfValue::release_if_() {
  // @@protoc_insertion_point(field_release:substrait.Expression.SwitchExpression.IfValue.if)
  
  ::substrait::Expression_Literal* temp = if__;
  if__ = NULL;
  return temp;
}
inline ::substrait::Expression_Literal* Expression_SwitchExpression_IfValue::mutable_if_() {
  
  if (if__ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression_Literal>(GetArenaNoVirtual());
    if__ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.SwitchExpression.IfValue.if)
  return if__;
}
inline void Expression_SwitchExpression_IfValue::set_allocated_if_(::substrait::Expression_Literal* if_) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete if__;
  }
  if (if_) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      if_ = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, if_, submessage_arena);
    }
    
  } else {
    
  }
  if__ = if_;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.SwitchExpression.IfValue.if)
}

// .substrait.Expression then = 2;
inline bool Expression_SwitchExpression_IfValue::has_then() const {
  return this != internal_default_instance() && then_ != NULL;
}
inline void Expression_SwitchExpression_IfValue::clear_then() {
  if (GetArenaNoVirtual() == NULL && then_ != NULL) {
    delete then_;
  }
  then_ = NULL;
}
inline const ::substrait::Expression& Expression_SwitchExpression_IfValue::_internal_then() const {
  return *then_;
}
inline const ::substrait::Expression& Expression_SwitchExpression_IfValue::then() const {
  const ::substrait::Expression* p = then_;
  // @@protoc_insertion_point(field_get:substrait.Expression.SwitchExpression.IfValue.then)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression*>(
      &::substrait::_Expression_default_instance_);
}
inline ::substrait::Expression* Expression_SwitchExpression_IfValue::release_then() {
  // @@protoc_insertion_point(field_release:substrait.Expression.SwitchExpression.IfValue.then)
  
  ::substrait::Expression* temp = then_;
  then_ = NULL;
  return temp;
}
inline ::substrait::Expression* Expression_SwitchExpression_IfValue::mutable_then() {
  
  if (then_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression>(GetArenaNoVirtual());
    then_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.SwitchExpression.IfValue.then)
  return then_;
}
inline void Expression_SwitchExpression_IfValue::set_allocated_then(::substrait::Expression* then) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete then_;
  }
  if (then) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      then = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, then, submessage_arena);
    }
    
  } else {
    
  }
  then_ = then;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.SwitchExpression.IfValue.then)
}

// -------------------------------------------------------------------

// Expression_SwitchExpression

// .substrait.Expression match = 3;
inline bool Expression_SwitchExpression::has_match() const {
  return this != internal_default_instance() && match_ != NULL;
}
inline void Expression_SwitchExpression::clear_match() {
  if (GetArenaNoVirtual() == NULL && match_ != NULL) {
    delete match_;
  }
  match_ = NULL;
}
inline const ::substrait::Expression& Expression_SwitchExpression::_internal_match() const {
  return *match_;
}
inline const ::substrait::Expression& Expression_SwitchExpression::match() const {
  const ::substrait::Expression* p = match_;
  // @@protoc_insertion_point(field_get:substrait.Expression.SwitchExpression.match)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression*>(
      &::substrait::_Expression_default_instance_);
}
inline ::substrait::Expression* Expression_SwitchExpression::release_match() {
  // @@protoc_insertion_point(field_release:substrait.Expression.SwitchExpression.match)
  
  ::substrait::Expression* temp = match_;
  match_ = NULL;
  return temp;
}
inline ::substrait::Expression* Expression_SwitchExpression::mutable_match() {
  
  if (match_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression>(GetArenaNoVirtual());
    match_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.SwitchExpression.match)
  return match_;
}
inline void Expression_SwitchExpression::set_allocated_match(::substrait::Expression* match) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete match_;
  }
  if (match) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      match = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, match, submessage_arena);
    }
    
  } else {
    
  }
  match_ = match;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.SwitchExpression.match)
}

// repeated .substrait.Expression.SwitchExpression.IfValue ifs = 1;
inline int Expression_SwitchExpression::ifs_size() const {
  return ifs_.size();
}
inline void Expression_SwitchExpression::clear_ifs() {
  ifs_.Clear();
}
inline ::substrait::Expression_SwitchExpression_IfValue* Expression_SwitchExpression::mutable_ifs(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.SwitchExpression.ifs)
  return ifs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::Expression_SwitchExpression_IfValue >*
Expression_SwitchExpression::mutable_ifs() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.SwitchExpression.ifs)
  return &ifs_;
}
inline const ::substrait::Expression_SwitchExpression_IfValue& Expression_SwitchExpression::ifs(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.SwitchExpression.ifs)
  return ifs_.Get(index);
}
inline ::substrait::Expression_SwitchExpression_IfValue* Expression_SwitchExpression::add_ifs() {
  // @@protoc_insertion_point(field_add:substrait.Expression.SwitchExpression.ifs)
  return ifs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::Expression_SwitchExpression_IfValue >&
Expression_SwitchExpression::ifs() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.SwitchExpression.ifs)
  return ifs_;
}

// .substrait.Expression else = 2;
inline bool Expression_SwitchExpression::has_else_() const {
  return this != internal_default_instance() && else__ != NULL;
}
inline void Expression_SwitchExpression::clear_else_() {
  if (GetArenaNoVirtual() == NULL && else__ != NULL) {
    delete else__;
  }
  else__ = NULL;
}
inline const ::substrait::Expression& Expression_SwitchExpression::_internal_else_() const {
  return *else__;
}
inline const ::substrait::Expression& Expression_SwitchExpression::else_() const {
  const ::substrait::Expression* p = else__;
  // @@protoc_insertion_point(field_get:substrait.Expression.SwitchExpression.else)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression*>(
      &::substrait::_Expression_default_instance_);
}
inline ::substrait::Expression* Expression_SwitchExpression::release_else_() {
  // @@protoc_insertion_point(field_release:substrait.Expression.SwitchExpression.else)
  
  ::substrait::Expression* temp = else__;
  else__ = NULL;
  return temp;
}
inline ::substrait::Expression* Expression_SwitchExpression::mutable_else_() {
  
  if (else__ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression>(GetArenaNoVirtual());
    else__ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.SwitchExpression.else)
  return else__;
}
inline void Expression_SwitchExpression::set_allocated_else_(::substrait::Expression* else_) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete else__;
  }
  if (else_) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      else_ = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, else_, submessage_arena);
    }
    
  } else {
    
  }
  else__ = else_;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.SwitchExpression.else)
}

// -------------------------------------------------------------------

// Expression_SingularOrList

// .substrait.Expression value = 1;
inline bool Expression_SingularOrList::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline void Expression_SingularOrList::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) {
    delete value_;
  }
  value_ = NULL;
}
inline const ::substrait::Expression& Expression_SingularOrList::_internal_value() const {
  return *value_;
}
inline const ::substrait::Expression& Expression_SingularOrList::value() const {
  const ::substrait::Expression* p = value_;
  // @@protoc_insertion_point(field_get:substrait.Expression.SingularOrList.value)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression*>(
      &::substrait::_Expression_default_instance_);
}
inline ::substrait::Expression* Expression_SingularOrList::release_value() {
  // @@protoc_insertion_point(field_release:substrait.Expression.SingularOrList.value)
  
  ::substrait::Expression* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::substrait::Expression* Expression_SingularOrList::mutable_value() {
  
  if (value_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.SingularOrList.value)
  return value_;
}
inline void Expression_SingularOrList::set_allocated_value(::substrait::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete value_;
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.SingularOrList.value)
}

// repeated .substrait.Expression options = 2;
inline int Expression_SingularOrList::options_size() const {
  return options_.size();
}
inline void Expression_SingularOrList::clear_options() {
  options_.Clear();
}
inline ::substrait::Expression* Expression_SingularOrList::mutable_options(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.SingularOrList.options)
  return options_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::Expression >*
Expression_SingularOrList::mutable_options() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.SingularOrList.options)
  return &options_;
}
inline const ::substrait::Expression& Expression_SingularOrList::options(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.SingularOrList.options)
  return options_.Get(index);
}
inline ::substrait::Expression* Expression_SingularOrList::add_options() {
  // @@protoc_insertion_point(field_add:substrait.Expression.SingularOrList.options)
  return options_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::Expression >&
Expression_SingularOrList::options() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.SingularOrList.options)
  return options_;
}

// -------------------------------------------------------------------

// Expression_MultiOrList_Record

// repeated .substrait.Expression fields = 1;
inline int Expression_MultiOrList_Record::fields_size() const {
  return fields_.size();
}
inline void Expression_MultiOrList_Record::clear_fields() {
  fields_.Clear();
}
inline ::substrait::Expression* Expression_MultiOrList_Record::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MultiOrList.Record.fields)
  return fields_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::Expression >*
Expression_MultiOrList_Record::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.MultiOrList.Record.fields)
  return &fields_;
}
inline const ::substrait::Expression& Expression_MultiOrList_Record::fields(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MultiOrList.Record.fields)
  return fields_.Get(index);
}
inline ::substrait::Expression* Expression_MultiOrList_Record::add_fields() {
  // @@protoc_insertion_point(field_add:substrait.Expression.MultiOrList.Record.fields)
  return fields_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::Expression >&
Expression_MultiOrList_Record::fields() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.MultiOrList.Record.fields)
  return fields_;
}

// -------------------------------------------------------------------

// Expression_MultiOrList

// repeated .substrait.Expression value = 1;
inline int Expression_MultiOrList::value_size() const {
  return value_.size();
}
inline void Expression_MultiOrList::clear_value() {
  value_.Clear();
}
inline ::substrait::Expression* Expression_MultiOrList::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MultiOrList.value)
  return value_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::Expression >*
Expression_MultiOrList::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.MultiOrList.value)
  return &value_;
}
inline const ::substrait::Expression& Expression_MultiOrList::value(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MultiOrList.value)
  return value_.Get(index);
}
inline ::substrait::Expression* Expression_MultiOrList::add_value() {
  // @@protoc_insertion_point(field_add:substrait.Expression.MultiOrList.value)
  return value_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::Expression >&
Expression_MultiOrList::value() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.MultiOrList.value)
  return value_;
}

// repeated .substrait.Expression.MultiOrList.Record options = 2;
inline int Expression_MultiOrList::options_size() const {
  return options_.size();
}
inline void Expression_MultiOrList::clear_options() {
  options_.Clear();
}
inline ::substrait::Expression_MultiOrList_Record* Expression_MultiOrList::mutable_options(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MultiOrList.options)
  return options_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::Expression_MultiOrList_Record >*
Expression_MultiOrList::mutable_options() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.MultiOrList.options)
  return &options_;
}
inline const ::substrait::Expression_MultiOrList_Record& Expression_MultiOrList::options(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MultiOrList.options)
  return options_.Get(index);
}
inline ::substrait::Expression_MultiOrList_Record* Expression_MultiOrList::add_options() {
  // @@protoc_insertion_point(field_add:substrait.Expression.MultiOrList.options)
  return options_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::Expression_MultiOrList_Record >&
Expression_MultiOrList::options() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.MultiOrList.options)
  return options_;
}

// -------------------------------------------------------------------

// Expression_EmbeddedFunction_PythonPickleFunction

// bytes function = 1;
inline void Expression_EmbeddedFunction_PythonPickleFunction::clear_function() {
  function_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Expression_EmbeddedFunction_PythonPickleFunction::function() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.EmbeddedFunction.PythonPickleFunction.function)
  return function_.GetNoArena();
}
inline void Expression_EmbeddedFunction_PythonPickleFunction::set_function(const ::std::string& value) {
  
  function_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:substrait.Expression.EmbeddedFunction.PythonPickleFunction.function)
}
#if LANG_CXX11
inline void Expression_EmbeddedFunction_PythonPickleFunction::set_function(::std::string&& value) {
  
  function_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:substrait.Expression.EmbeddedFunction.PythonPickleFunction.function)
}
#endif
inline void Expression_EmbeddedFunction_PythonPickleFunction::set_function(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  function_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:substrait.Expression.EmbeddedFunction.PythonPickleFunction.function)
}
inline void Expression_EmbeddedFunction_PythonPickleFunction::set_function(const void* value, size_t size) {
  
  function_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:substrait.Expression.EmbeddedFunction.PythonPickleFunction.function)
}
inline ::std::string* Expression_EmbeddedFunction_PythonPickleFunction::mutable_function() {
  
  // @@protoc_insertion_point(field_mutable:substrait.Expression.EmbeddedFunction.PythonPickleFunction.function)
  return function_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Expression_EmbeddedFunction_PythonPickleFunction::release_function() {
  // @@protoc_insertion_point(field_release:substrait.Expression.EmbeddedFunction.PythonPickleFunction.function)
  
  return function_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Expression_EmbeddedFunction_PythonPickleFunction::set_allocated_function(::std::string* function) {
  if (function != NULL) {
    
  } else {
    
  }
  function_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), function);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.EmbeddedFunction.PythonPickleFunction.function)
}

// repeated string prerequisite = 2;
inline int Expression_EmbeddedFunction_PythonPickleFunction::prerequisite_size() const {
  return prerequisite_.size();
}
inline void Expression_EmbeddedFunction_PythonPickleFunction::clear_prerequisite() {
  prerequisite_.Clear();
}
inline const ::std::string& Expression_EmbeddedFunction_PythonPickleFunction::prerequisite(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.EmbeddedFunction.PythonPickleFunction.prerequisite)
  return prerequisite_.Get(index);
}
inline ::std::string* Expression_EmbeddedFunction_PythonPickleFunction::mutable_prerequisite(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.EmbeddedFunction.PythonPickleFunction.prerequisite)
  return prerequisite_.Mutable(index);
}
inline void Expression_EmbeddedFunction_PythonPickleFunction::set_prerequisite(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:substrait.Expression.EmbeddedFunction.PythonPickleFunction.prerequisite)
  prerequisite_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Expression_EmbeddedFunction_PythonPickleFunction::set_prerequisite(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:substrait.Expression.EmbeddedFunction.PythonPickleFunction.prerequisite)
  prerequisite_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Expression_EmbeddedFunction_PythonPickleFunction::set_prerequisite(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  prerequisite_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:substrait.Expression.EmbeddedFunction.PythonPickleFunction.prerequisite)
}
inline void Expression_EmbeddedFunction_PythonPickleFunction::set_prerequisite(int index, const char* value, size_t size) {
  prerequisite_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:substrait.Expression.EmbeddedFunction.PythonPickleFunction.prerequisite)
}
inline ::std::string* Expression_EmbeddedFunction_PythonPickleFunction::add_prerequisite() {
  // @@protoc_insertion_point(field_add_mutable:substrait.Expression.EmbeddedFunction.PythonPickleFunction.prerequisite)
  return prerequisite_.Add();
}
inline void Expression_EmbeddedFunction_PythonPickleFunction::add_prerequisite(const ::std::string& value) {
  prerequisite_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:substrait.Expression.EmbeddedFunction.PythonPickleFunction.prerequisite)
}
#if LANG_CXX11
inline void Expression_EmbeddedFunction_PythonPickleFunction::add_prerequisite(::std::string&& value) {
  prerequisite_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:substrait.Expression.EmbeddedFunction.PythonPickleFunction.prerequisite)
}
#endif
inline void Expression_EmbeddedFunction_PythonPickleFunction::add_prerequisite(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  prerequisite_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:substrait.Expression.EmbeddedFunction.PythonPickleFunction.prerequisite)
}
inline void Expression_EmbeddedFunction_PythonPickleFunction::add_prerequisite(const char* value, size_t size) {
  prerequisite_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:substrait.Expression.EmbeddedFunction.PythonPickleFunction.prerequisite)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Expression_EmbeddedFunction_PythonPickleFunction::prerequisite() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.EmbeddedFunction.PythonPickleFunction.prerequisite)
  return prerequisite_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Expression_EmbeddedFunction_PythonPickleFunction::mutable_prerequisite() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.EmbeddedFunction.PythonPickleFunction.prerequisite)
  return &prerequisite_;
}

// -------------------------------------------------------------------

// Expression_EmbeddedFunction_WebAssemblyFunction

// bytes script = 1;
inline void Expression_EmbeddedFunction_WebAssemblyFunction::clear_script() {
  script_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Expression_EmbeddedFunction_WebAssemblyFunction::script() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.script)
  return script_.GetNoArena();
}
inline void Expression_EmbeddedFunction_WebAssemblyFunction::set_script(const ::std::string& value) {
  
  script_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.script)
}
#if LANG_CXX11
inline void Expression_EmbeddedFunction_WebAssemblyFunction::set_script(::std::string&& value) {
  
  script_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.script)
}
#endif
inline void Expression_EmbeddedFunction_WebAssemblyFunction::set_script(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  script_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.script)
}
inline void Expression_EmbeddedFunction_WebAssemblyFunction::set_script(const void* value, size_t size) {
  
  script_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.script)
}
inline ::std::string* Expression_EmbeddedFunction_WebAssemblyFunction::mutable_script() {
  
  // @@protoc_insertion_point(field_mutable:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.script)
  return script_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Expression_EmbeddedFunction_WebAssemblyFunction::release_script() {
  // @@protoc_insertion_point(field_release:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.script)
  
  return script_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Expression_EmbeddedFunction_WebAssemblyFunction::set_allocated_script(::std::string* script) {
  if (script != NULL) {
    
  } else {
    
  }
  script_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), script);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.script)
}

// repeated string prerequisite = 2;
inline int Expression_EmbeddedFunction_WebAssemblyFunction::prerequisite_size() const {
  return prerequisite_.size();
}
inline void Expression_EmbeddedFunction_WebAssemblyFunction::clear_prerequisite() {
  prerequisite_.Clear();
}
inline const ::std::string& Expression_EmbeddedFunction_WebAssemblyFunction::prerequisite(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.prerequisite)
  return prerequisite_.Get(index);
}
inline ::std::string* Expression_EmbeddedFunction_WebAssemblyFunction::mutable_prerequisite(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.prerequisite)
  return prerequisite_.Mutable(index);
}
inline void Expression_EmbeddedFunction_WebAssemblyFunction::set_prerequisite(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.prerequisite)
  prerequisite_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Expression_EmbeddedFunction_WebAssemblyFunction::set_prerequisite(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.prerequisite)
  prerequisite_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Expression_EmbeddedFunction_WebAssemblyFunction::set_prerequisite(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  prerequisite_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.prerequisite)
}
inline void Expression_EmbeddedFunction_WebAssemblyFunction::set_prerequisite(int index, const char* value, size_t size) {
  prerequisite_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.prerequisite)
}
inline ::std::string* Expression_EmbeddedFunction_WebAssemblyFunction::add_prerequisite() {
  // @@protoc_insertion_point(field_add_mutable:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.prerequisite)
  return prerequisite_.Add();
}
inline void Expression_EmbeddedFunction_WebAssemblyFunction::add_prerequisite(const ::std::string& value) {
  prerequisite_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.prerequisite)
}
#if LANG_CXX11
inline void Expression_EmbeddedFunction_WebAssemblyFunction::add_prerequisite(::std::string&& value) {
  prerequisite_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.prerequisite)
}
#endif
inline void Expression_EmbeddedFunction_WebAssemblyFunction::add_prerequisite(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  prerequisite_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.prerequisite)
}
inline void Expression_EmbeddedFunction_WebAssemblyFunction::add_prerequisite(const char* value, size_t size) {
  prerequisite_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.prerequisite)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Expression_EmbeddedFunction_WebAssemblyFunction::prerequisite() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.prerequisite)
  return prerequisite_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Expression_EmbeddedFunction_WebAssemblyFunction::mutable_prerequisite() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.EmbeddedFunction.WebAssemblyFunction.prerequisite)
  return &prerequisite_;
}

// -------------------------------------------------------------------

// Expression_EmbeddedFunction

// repeated .substrait.Expression arguments = 1;
inline int Expression_EmbeddedFunction::arguments_size() const {
  return arguments_.size();
}
inline void Expression_EmbeddedFunction::clear_arguments() {
  arguments_.Clear();
}
inline ::substrait::Expression* Expression_EmbeddedFunction::mutable_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.EmbeddedFunction.arguments)
  return arguments_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::Expression >*
Expression_EmbeddedFunction::mutable_arguments() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.EmbeddedFunction.arguments)
  return &arguments_;
}
inline const ::substrait::Expression& Expression_EmbeddedFunction::arguments(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.EmbeddedFunction.arguments)
  return arguments_.Get(index);
}
inline ::substrait::Expression* Expression_EmbeddedFunction::add_arguments() {
  // @@protoc_insertion_point(field_add:substrait.Expression.EmbeddedFunction.arguments)
  return arguments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::Expression >&
Expression_EmbeddedFunction::arguments() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.EmbeddedFunction.arguments)
  return arguments_;
}

// .substrait.Type output_type = 2;
inline bool Expression_EmbeddedFunction::has_output_type() const {
  return this != internal_default_instance() && output_type_ != NULL;
}
inline const ::substrait::Type& Expression_EmbeddedFunction::_internal_output_type() const {
  return *output_type_;
}
inline const ::substrait::Type& Expression_EmbeddedFunction::output_type() const {
  const ::substrait::Type* p = output_type_;
  // @@protoc_insertion_point(field_get:substrait.Expression.EmbeddedFunction.output_type)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Type*>(
      &::substrait::_Type_default_instance_);
}
inline ::substrait::Type* Expression_EmbeddedFunction::release_output_type() {
  // @@protoc_insertion_point(field_release:substrait.Expression.EmbeddedFunction.output_type)
  
  ::substrait::Type* temp = output_type_;
  output_type_ = NULL;
  return temp;
}
inline ::substrait::Type* Expression_EmbeddedFunction::mutable_output_type() {
  
  if (output_type_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Type>(GetArenaNoVirtual());
    output_type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.EmbeddedFunction.output_type)
  return output_type_;
}
inline void Expression_EmbeddedFunction::set_allocated_output_type(::substrait::Type* output_type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(output_type_);
  }
  if (output_type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      output_type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, output_type, submessage_arena);
    }
    
  } else {
    
  }
  output_type_ = output_type;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.EmbeddedFunction.output_type)
}

// .substrait.Expression.EmbeddedFunction.PythonPickleFunction python_pickle_function = 3;
inline bool Expression_EmbeddedFunction::has_python_pickle_function() const {
  return kind_case() == kPythonPickleFunction;
}
inline void Expression_EmbeddedFunction::set_has_python_pickle_function() {
  _oneof_case_[0] = kPythonPickleFunction;
}
inline void Expression_EmbeddedFunction::clear_python_pickle_function() {
  if (has_python_pickle_function()) {
    delete kind_.python_pickle_function_;
    clear_has_kind();
  }
}
inline const ::substrait::Expression_EmbeddedFunction_PythonPickleFunction& Expression_EmbeddedFunction::_internal_python_pickle_function() const {
  return *kind_.python_pickle_function_;
}
inline ::substrait::Expression_EmbeddedFunction_PythonPickleFunction* Expression_EmbeddedFunction::release_python_pickle_function() {
  // @@protoc_insertion_point(field_release:substrait.Expression.EmbeddedFunction.python_pickle_function)
  if (has_python_pickle_function()) {
    clear_has_kind();
      ::substrait::Expression_EmbeddedFunction_PythonPickleFunction* temp = kind_.python_pickle_function_;
    kind_.python_pickle_function_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_EmbeddedFunction_PythonPickleFunction& Expression_EmbeddedFunction::python_pickle_function() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.EmbeddedFunction.python_pickle_function)
  return has_python_pickle_function()
      ? *kind_.python_pickle_function_
      : *reinterpret_cast< ::substrait::Expression_EmbeddedFunction_PythonPickleFunction*>(&::substrait::_Expression_EmbeddedFunction_PythonPickleFunction_default_instance_);
}
inline ::substrait::Expression_EmbeddedFunction_PythonPickleFunction* Expression_EmbeddedFunction::mutable_python_pickle_function() {
  if (!has_python_pickle_function()) {
    clear_kind();
    set_has_python_pickle_function();
    kind_.python_pickle_function_ = CreateMaybeMessage< ::substrait::Expression_EmbeddedFunction_PythonPickleFunction >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.EmbeddedFunction.python_pickle_function)
  return kind_.python_pickle_function_;
}

// .substrait.Expression.EmbeddedFunction.WebAssemblyFunction web_assembly_function = 4;
inline bool Expression_EmbeddedFunction::has_web_assembly_function() const {
  return kind_case() == kWebAssemblyFunction;
}
inline void Expression_EmbeddedFunction::set_has_web_assembly_function() {
  _oneof_case_[0] = kWebAssemblyFunction;
}
inline void Expression_EmbeddedFunction::clear_web_assembly_function() {
  if (has_web_assembly_function()) {
    delete kind_.web_assembly_function_;
    clear_has_kind();
  }
}
inline const ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction& Expression_EmbeddedFunction::_internal_web_assembly_function() const {
  return *kind_.web_assembly_function_;
}
inline ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* Expression_EmbeddedFunction::release_web_assembly_function() {
  // @@protoc_insertion_point(field_release:substrait.Expression.EmbeddedFunction.web_assembly_function)
  if (has_web_assembly_function()) {
    clear_has_kind();
      ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* temp = kind_.web_assembly_function_;
    kind_.web_assembly_function_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction& Expression_EmbeddedFunction::web_assembly_function() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.EmbeddedFunction.web_assembly_function)
  return has_web_assembly_function()
      ? *kind_.web_assembly_function_
      : *reinterpret_cast< ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction*>(&::substrait::_Expression_EmbeddedFunction_WebAssemblyFunction_default_instance_);
}
inline ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction* Expression_EmbeddedFunction::mutable_web_assembly_function() {
  if (!has_web_assembly_function()) {
    clear_kind();
    set_has_web_assembly_function();
    kind_.web_assembly_function_ = CreateMaybeMessage< ::substrait::Expression_EmbeddedFunction_WebAssemblyFunction >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.EmbeddedFunction.web_assembly_function)
  return kind_.web_assembly_function_;
}

inline bool Expression_EmbeddedFunction::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void Expression_EmbeddedFunction::clear_has_kind() {
  _oneof_case_[0] = KIND_NOT_SET;
}
inline Expression_EmbeddedFunction::KindCase Expression_EmbeddedFunction::kind_case() const {
  return Expression_EmbeddedFunction::KindCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Expression_ReferenceSegment_MapKey

// .substrait.Expression.Literal map_key = 1;
inline bool Expression_ReferenceSegment_MapKey::has_map_key() const {
  return this != internal_default_instance() && map_key_ != NULL;
}
inline void Expression_ReferenceSegment_MapKey::clear_map_key() {
  if (GetArenaNoVirtual() == NULL && map_key_ != NULL) {
    delete map_key_;
  }
  map_key_ = NULL;
}
inline const ::substrait::Expression_Literal& Expression_ReferenceSegment_MapKey::_internal_map_key() const {
  return *map_key_;
}
inline const ::substrait::Expression_Literal& Expression_ReferenceSegment_MapKey::map_key() const {
  const ::substrait::Expression_Literal* p = map_key_;
  // @@protoc_insertion_point(field_get:substrait.Expression.ReferenceSegment.MapKey.map_key)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression_Literal*>(
      &::substrait::_Expression_Literal_default_instance_);
}
inline ::substrait::Expression_Literal* Expression_ReferenceSegment_MapKey::release_map_key() {
  // @@protoc_insertion_point(field_release:substrait.Expression.ReferenceSegment.MapKey.map_key)
  
  ::substrait::Expression_Literal* temp = map_key_;
  map_key_ = NULL;
  return temp;
}
inline ::substrait::Expression_Literal* Expression_ReferenceSegment_MapKey::mutable_map_key() {
  
  if (map_key_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression_Literal>(GetArenaNoVirtual());
    map_key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.ReferenceSegment.MapKey.map_key)
  return map_key_;
}
inline void Expression_ReferenceSegment_MapKey::set_allocated_map_key(::substrait::Expression_Literal* map_key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete map_key_;
  }
  if (map_key) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      map_key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, map_key, submessage_arena);
    }
    
  } else {
    
  }
  map_key_ = map_key;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.ReferenceSegment.MapKey.map_key)
}

// .substrait.Expression.ReferenceSegment child = 2;
inline bool Expression_ReferenceSegment_MapKey::has_child() const {
  return this != internal_default_instance() && child_ != NULL;
}
inline void Expression_ReferenceSegment_MapKey::clear_child() {
  if (GetArenaNoVirtual() == NULL && child_ != NULL) {
    delete child_;
  }
  child_ = NULL;
}
inline const ::substrait::Expression_ReferenceSegment& Expression_ReferenceSegment_MapKey::_internal_child() const {
  return *child_;
}
inline const ::substrait::Expression_ReferenceSegment& Expression_ReferenceSegment_MapKey::child() const {
  const ::substrait::Expression_ReferenceSegment* p = child_;
  // @@protoc_insertion_point(field_get:substrait.Expression.ReferenceSegment.MapKey.child)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression_ReferenceSegment*>(
      &::substrait::_Expression_ReferenceSegment_default_instance_);
}
inline ::substrait::Expression_ReferenceSegment* Expression_ReferenceSegment_MapKey::release_child() {
  // @@protoc_insertion_point(field_release:substrait.Expression.ReferenceSegment.MapKey.child)
  
  ::substrait::Expression_ReferenceSegment* temp = child_;
  child_ = NULL;
  return temp;
}
inline ::substrait::Expression_ReferenceSegment* Expression_ReferenceSegment_MapKey::mutable_child() {
  
  if (child_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression_ReferenceSegment>(GetArenaNoVirtual());
    child_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.ReferenceSegment.MapKey.child)
  return child_;
}
inline void Expression_ReferenceSegment_MapKey::set_allocated_child(::substrait::Expression_ReferenceSegment* child) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete child_;
  }
  if (child) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      child = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.ReferenceSegment.MapKey.child)
}

// -------------------------------------------------------------------

// Expression_ReferenceSegment_StructField

// int32 field = 1;
inline void Expression_ReferenceSegment_StructField::clear_field() {
  field_ = 0;
}
inline ::google::protobuf::int32 Expression_ReferenceSegment_StructField::field() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.ReferenceSegment.StructField.field)
  return field_;
}
inline void Expression_ReferenceSegment_StructField::set_field(::google::protobuf::int32 value) {
  
  field_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.ReferenceSegment.StructField.field)
}

// .substrait.Expression.ReferenceSegment child = 2;
inline bool Expression_ReferenceSegment_StructField::has_child() const {
  return this != internal_default_instance() && child_ != NULL;
}
inline void Expression_ReferenceSegment_StructField::clear_child() {
  if (GetArenaNoVirtual() == NULL && child_ != NULL) {
    delete child_;
  }
  child_ = NULL;
}
inline const ::substrait::Expression_ReferenceSegment& Expression_ReferenceSegment_StructField::_internal_child() const {
  return *child_;
}
inline const ::substrait::Expression_ReferenceSegment& Expression_ReferenceSegment_StructField::child() const {
  const ::substrait::Expression_ReferenceSegment* p = child_;
  // @@protoc_insertion_point(field_get:substrait.Expression.ReferenceSegment.StructField.child)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression_ReferenceSegment*>(
      &::substrait::_Expression_ReferenceSegment_default_instance_);
}
inline ::substrait::Expression_ReferenceSegment* Expression_ReferenceSegment_StructField::release_child() {
  // @@protoc_insertion_point(field_release:substrait.Expression.ReferenceSegment.StructField.child)
  
  ::substrait::Expression_ReferenceSegment* temp = child_;
  child_ = NULL;
  return temp;
}
inline ::substrait::Expression_ReferenceSegment* Expression_ReferenceSegment_StructField::mutable_child() {
  
  if (child_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression_ReferenceSegment>(GetArenaNoVirtual());
    child_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.ReferenceSegment.StructField.child)
  return child_;
}
inline void Expression_ReferenceSegment_StructField::set_allocated_child(::substrait::Expression_ReferenceSegment* child) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete child_;
  }
  if (child) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      child = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.ReferenceSegment.StructField.child)
}

// -------------------------------------------------------------------

// Expression_ReferenceSegment_ListElement

// int32 offset = 1;
inline void Expression_ReferenceSegment_ListElement::clear_offset() {
  offset_ = 0;
}
inline ::google::protobuf::int32 Expression_ReferenceSegment_ListElement::offset() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.ReferenceSegment.ListElement.offset)
  return offset_;
}
inline void Expression_ReferenceSegment_ListElement::set_offset(::google::protobuf::int32 value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.ReferenceSegment.ListElement.offset)
}

// .substrait.Expression.ReferenceSegment child = 2;
inline bool Expression_ReferenceSegment_ListElement::has_child() const {
  return this != internal_default_instance() && child_ != NULL;
}
inline void Expression_ReferenceSegment_ListElement::clear_child() {
  if (GetArenaNoVirtual() == NULL && child_ != NULL) {
    delete child_;
  }
  child_ = NULL;
}
inline const ::substrait::Expression_ReferenceSegment& Expression_ReferenceSegment_ListElement::_internal_child() const {
  return *child_;
}
inline const ::substrait::Expression_ReferenceSegment& Expression_ReferenceSegment_ListElement::child() const {
  const ::substrait::Expression_ReferenceSegment* p = child_;
  // @@protoc_insertion_point(field_get:substrait.Expression.ReferenceSegment.ListElement.child)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression_ReferenceSegment*>(
      &::substrait::_Expression_ReferenceSegment_default_instance_);
}
inline ::substrait::Expression_ReferenceSegment* Expression_ReferenceSegment_ListElement::release_child() {
  // @@protoc_insertion_point(field_release:substrait.Expression.ReferenceSegment.ListElement.child)
  
  ::substrait::Expression_ReferenceSegment* temp = child_;
  child_ = NULL;
  return temp;
}
inline ::substrait::Expression_ReferenceSegment* Expression_ReferenceSegment_ListElement::mutable_child() {
  
  if (child_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression_ReferenceSegment>(GetArenaNoVirtual());
    child_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.ReferenceSegment.ListElement.child)
  return child_;
}
inline void Expression_ReferenceSegment_ListElement::set_allocated_child(::substrait::Expression_ReferenceSegment* child) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete child_;
  }
  if (child) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      child = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.ReferenceSegment.ListElement.child)
}

// -------------------------------------------------------------------

// Expression_ReferenceSegment

// .substrait.Expression.ReferenceSegment.MapKey map_key = 1;
inline bool Expression_ReferenceSegment::has_map_key() const {
  return reference_type_case() == kMapKey;
}
inline void Expression_ReferenceSegment::set_has_map_key() {
  _oneof_case_[0] = kMapKey;
}
inline void Expression_ReferenceSegment::clear_map_key() {
  if (has_map_key()) {
    delete reference_type_.map_key_;
    clear_has_reference_type();
  }
}
inline const ::substrait::Expression_ReferenceSegment_MapKey& Expression_ReferenceSegment::_internal_map_key() const {
  return *reference_type_.map_key_;
}
inline ::substrait::Expression_ReferenceSegment_MapKey* Expression_ReferenceSegment::release_map_key() {
  // @@protoc_insertion_point(field_release:substrait.Expression.ReferenceSegment.map_key)
  if (has_map_key()) {
    clear_has_reference_type();
      ::substrait::Expression_ReferenceSegment_MapKey* temp = reference_type_.map_key_;
    reference_type_.map_key_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_ReferenceSegment_MapKey& Expression_ReferenceSegment::map_key() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.ReferenceSegment.map_key)
  return has_map_key()
      ? *reference_type_.map_key_
      : *reinterpret_cast< ::substrait::Expression_ReferenceSegment_MapKey*>(&::substrait::_Expression_ReferenceSegment_MapKey_default_instance_);
}
inline ::substrait::Expression_ReferenceSegment_MapKey* Expression_ReferenceSegment::mutable_map_key() {
  if (!has_map_key()) {
    clear_reference_type();
    set_has_map_key();
    reference_type_.map_key_ = CreateMaybeMessage< ::substrait::Expression_ReferenceSegment_MapKey >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.ReferenceSegment.map_key)
  return reference_type_.map_key_;
}

// .substrait.Expression.ReferenceSegment.StructField struct_field = 2;
inline bool Expression_ReferenceSegment::has_struct_field() const {
  return reference_type_case() == kStructField;
}
inline void Expression_ReferenceSegment::set_has_struct_field() {
  _oneof_case_[0] = kStructField;
}
inline void Expression_ReferenceSegment::clear_struct_field() {
  if (has_struct_field()) {
    delete reference_type_.struct_field_;
    clear_has_reference_type();
  }
}
inline const ::substrait::Expression_ReferenceSegment_StructField& Expression_ReferenceSegment::_internal_struct_field() const {
  return *reference_type_.struct_field_;
}
inline ::substrait::Expression_ReferenceSegment_StructField* Expression_ReferenceSegment::release_struct_field() {
  // @@protoc_insertion_point(field_release:substrait.Expression.ReferenceSegment.struct_field)
  if (has_struct_field()) {
    clear_has_reference_type();
      ::substrait::Expression_ReferenceSegment_StructField* temp = reference_type_.struct_field_;
    reference_type_.struct_field_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_ReferenceSegment_StructField& Expression_ReferenceSegment::struct_field() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.ReferenceSegment.struct_field)
  return has_struct_field()
      ? *reference_type_.struct_field_
      : *reinterpret_cast< ::substrait::Expression_ReferenceSegment_StructField*>(&::substrait::_Expression_ReferenceSegment_StructField_default_instance_);
}
inline ::substrait::Expression_ReferenceSegment_StructField* Expression_ReferenceSegment::mutable_struct_field() {
  if (!has_struct_field()) {
    clear_reference_type();
    set_has_struct_field();
    reference_type_.struct_field_ = CreateMaybeMessage< ::substrait::Expression_ReferenceSegment_StructField >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.ReferenceSegment.struct_field)
  return reference_type_.struct_field_;
}

// .substrait.Expression.ReferenceSegment.ListElement list_element = 3;
inline bool Expression_ReferenceSegment::has_list_element() const {
  return reference_type_case() == kListElement;
}
inline void Expression_ReferenceSegment::set_has_list_element() {
  _oneof_case_[0] = kListElement;
}
inline void Expression_ReferenceSegment::clear_list_element() {
  if (has_list_element()) {
    delete reference_type_.list_element_;
    clear_has_reference_type();
  }
}
inline const ::substrait::Expression_ReferenceSegment_ListElement& Expression_ReferenceSegment::_internal_list_element() const {
  return *reference_type_.list_element_;
}
inline ::substrait::Expression_ReferenceSegment_ListElement* Expression_ReferenceSegment::release_list_element() {
  // @@protoc_insertion_point(field_release:substrait.Expression.ReferenceSegment.list_element)
  if (has_list_element()) {
    clear_has_reference_type();
      ::substrait::Expression_ReferenceSegment_ListElement* temp = reference_type_.list_element_;
    reference_type_.list_element_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_ReferenceSegment_ListElement& Expression_ReferenceSegment::list_element() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.ReferenceSegment.list_element)
  return has_list_element()
      ? *reference_type_.list_element_
      : *reinterpret_cast< ::substrait::Expression_ReferenceSegment_ListElement*>(&::substrait::_Expression_ReferenceSegment_ListElement_default_instance_);
}
inline ::substrait::Expression_ReferenceSegment_ListElement* Expression_ReferenceSegment::mutable_list_element() {
  if (!has_list_element()) {
    clear_reference_type();
    set_has_list_element();
    reference_type_.list_element_ = CreateMaybeMessage< ::substrait::Expression_ReferenceSegment_ListElement >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.ReferenceSegment.list_element)
  return reference_type_.list_element_;
}

inline bool Expression_ReferenceSegment::has_reference_type() const {
  return reference_type_case() != REFERENCE_TYPE_NOT_SET;
}
inline void Expression_ReferenceSegment::clear_has_reference_type() {
  _oneof_case_[0] = REFERENCE_TYPE_NOT_SET;
}
inline Expression_ReferenceSegment::ReferenceTypeCase Expression_ReferenceSegment::reference_type_case() const {
  return Expression_ReferenceSegment::ReferenceTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Expression_MaskExpression_Select

// .substrait.Expression.MaskExpression.StructSelect struct = 1;
inline bool Expression_MaskExpression_Select::has_struct_() const {
  return type_case() == kStruct;
}
inline void Expression_MaskExpression_Select::set_has_struct_() {
  _oneof_case_[0] = kStruct;
}
inline void Expression_MaskExpression_Select::clear_struct_() {
  if (has_struct_()) {
    delete type_.struct__;
    clear_has_type();
  }
}
inline const ::substrait::Expression_MaskExpression_StructSelect& Expression_MaskExpression_Select::_internal_struct_() const {
  return *type_.struct__;
}
inline ::substrait::Expression_MaskExpression_StructSelect* Expression_MaskExpression_Select::release_struct_() {
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.Select.struct)
  if (has_struct_()) {
    clear_has_type();
      ::substrait::Expression_MaskExpression_StructSelect* temp = type_.struct__;
    type_.struct__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_MaskExpression_StructSelect& Expression_MaskExpression_Select::struct_() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.Select.struct)
  return has_struct_()
      ? *type_.struct__
      : *reinterpret_cast< ::substrait::Expression_MaskExpression_StructSelect*>(&::substrait::_Expression_MaskExpression_StructSelect_default_instance_);
}
inline ::substrait::Expression_MaskExpression_StructSelect* Expression_MaskExpression_Select::mutable_struct_() {
  if (!has_struct_()) {
    clear_type();
    set_has_struct_();
    type_.struct__ = CreateMaybeMessage< ::substrait::Expression_MaskExpression_StructSelect >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.Select.struct)
  return type_.struct__;
}

// .substrait.Expression.MaskExpression.ListSelect list = 2;
inline bool Expression_MaskExpression_Select::has_list() const {
  return type_case() == kList;
}
inline void Expression_MaskExpression_Select::set_has_list() {
  _oneof_case_[0] = kList;
}
inline void Expression_MaskExpression_Select::clear_list() {
  if (has_list()) {
    delete type_.list_;
    clear_has_type();
  }
}
inline const ::substrait::Expression_MaskExpression_ListSelect& Expression_MaskExpression_Select::_internal_list() const {
  return *type_.list_;
}
inline ::substrait::Expression_MaskExpression_ListSelect* Expression_MaskExpression_Select::release_list() {
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.Select.list)
  if (has_list()) {
    clear_has_type();
      ::substrait::Expression_MaskExpression_ListSelect* temp = type_.list_;
    type_.list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_MaskExpression_ListSelect& Expression_MaskExpression_Select::list() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.Select.list)
  return has_list()
      ? *type_.list_
      : *reinterpret_cast< ::substrait::Expression_MaskExpression_ListSelect*>(&::substrait::_Expression_MaskExpression_ListSelect_default_instance_);
}
inline ::substrait::Expression_MaskExpression_ListSelect* Expression_MaskExpression_Select::mutable_list() {
  if (!has_list()) {
    clear_type();
    set_has_list();
    type_.list_ = CreateMaybeMessage< ::substrait::Expression_MaskExpression_ListSelect >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.Select.list)
  return type_.list_;
}

// .substrait.Expression.MaskExpression.MapSelect map = 3;
inline bool Expression_MaskExpression_Select::has_map() const {
  return type_case() == kMap;
}
inline void Expression_MaskExpression_Select::set_has_map() {
  _oneof_case_[0] = kMap;
}
inline void Expression_MaskExpression_Select::clear_map() {
  if (has_map()) {
    delete type_.map_;
    clear_has_type();
  }
}
inline const ::substrait::Expression_MaskExpression_MapSelect& Expression_MaskExpression_Select::_internal_map() const {
  return *type_.map_;
}
inline ::substrait::Expression_MaskExpression_MapSelect* Expression_MaskExpression_Select::release_map() {
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.Select.map)
  if (has_map()) {
    clear_has_type();
      ::substrait::Expression_MaskExpression_MapSelect* temp = type_.map_;
    type_.map_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_MaskExpression_MapSelect& Expression_MaskExpression_Select::map() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.Select.map)
  return has_map()
      ? *type_.map_
      : *reinterpret_cast< ::substrait::Expression_MaskExpression_MapSelect*>(&::substrait::_Expression_MaskExpression_MapSelect_default_instance_);
}
inline ::substrait::Expression_MaskExpression_MapSelect* Expression_MaskExpression_Select::mutable_map() {
  if (!has_map()) {
    clear_type();
    set_has_map();
    type_.map_ = CreateMaybeMessage< ::substrait::Expression_MaskExpression_MapSelect >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.Select.map)
  return type_.map_;
}

inline bool Expression_MaskExpression_Select::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Expression_MaskExpression_Select::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Expression_MaskExpression_Select::TypeCase Expression_MaskExpression_Select::type_case() const {
  return Expression_MaskExpression_Select::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Expression_MaskExpression_StructSelect

// repeated .substrait.Expression.MaskExpression.StructItem struct_items = 1;
inline int Expression_MaskExpression_StructSelect::struct_items_size() const {
  return struct_items_.size();
}
inline void Expression_MaskExpression_StructSelect::clear_struct_items() {
  struct_items_.Clear();
}
inline ::substrait::Expression_MaskExpression_StructItem* Expression_MaskExpression_StructSelect::mutable_struct_items(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.StructSelect.struct_items)
  return struct_items_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::Expression_MaskExpression_StructItem >*
Expression_MaskExpression_StructSelect::mutable_struct_items() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.MaskExpression.StructSelect.struct_items)
  return &struct_items_;
}
inline const ::substrait::Expression_MaskExpression_StructItem& Expression_MaskExpression_StructSelect::struct_items(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.StructSelect.struct_items)
  return struct_items_.Get(index);
}
inline ::substrait::Expression_MaskExpression_StructItem* Expression_MaskExpression_StructSelect::add_struct_items() {
  // @@protoc_insertion_point(field_add:substrait.Expression.MaskExpression.StructSelect.struct_items)
  return struct_items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::Expression_MaskExpression_StructItem >&
Expression_MaskExpression_StructSelect::struct_items() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.MaskExpression.StructSelect.struct_items)
  return struct_items_;
}

// -------------------------------------------------------------------

// Expression_MaskExpression_StructItem

// int32 field = 1;
inline void Expression_MaskExpression_StructItem::clear_field() {
  field_ = 0;
}
inline ::google::protobuf::int32 Expression_MaskExpression_StructItem::field() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.StructItem.field)
  return field_;
}
inline void Expression_MaskExpression_StructItem::set_field(::google::protobuf::int32 value) {
  
  field_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.MaskExpression.StructItem.field)
}

// .substrait.Expression.MaskExpression.Select child = 2;
inline bool Expression_MaskExpression_StructItem::has_child() const {
  return this != internal_default_instance() && child_ != NULL;
}
inline void Expression_MaskExpression_StructItem::clear_child() {
  if (GetArenaNoVirtual() == NULL && child_ != NULL) {
    delete child_;
  }
  child_ = NULL;
}
inline const ::substrait::Expression_MaskExpression_Select& Expression_MaskExpression_StructItem::_internal_child() const {
  return *child_;
}
inline const ::substrait::Expression_MaskExpression_Select& Expression_MaskExpression_StructItem::child() const {
  const ::substrait::Expression_MaskExpression_Select* p = child_;
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.StructItem.child)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression_MaskExpression_Select*>(
      &::substrait::_Expression_MaskExpression_Select_default_instance_);
}
inline ::substrait::Expression_MaskExpression_Select* Expression_MaskExpression_StructItem::release_child() {
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.StructItem.child)
  
  ::substrait::Expression_MaskExpression_Select* temp = child_;
  child_ = NULL;
  return temp;
}
inline ::substrait::Expression_MaskExpression_Select* Expression_MaskExpression_StructItem::mutable_child() {
  
  if (child_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression_MaskExpression_Select>(GetArenaNoVirtual());
    child_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.StructItem.child)
  return child_;
}
inline void Expression_MaskExpression_StructItem::set_allocated_child(::substrait::Expression_MaskExpression_Select* child) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete child_;
  }
  if (child) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      child = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.MaskExpression.StructItem.child)
}

// -------------------------------------------------------------------

// Expression_MaskExpression_ListSelect_ListSelectItem_ListElement

// int32 field = 1;
inline void Expression_MaskExpression_ListSelect_ListSelectItem_ListElement::clear_field() {
  field_ = 0;
}
inline ::google::protobuf::int32 Expression_MaskExpression_ListSelect_ListSelectItem_ListElement::field() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement.field)
  return field_;
}
inline void Expression_MaskExpression_ListSelect_ListSelectItem_ListElement::set_field(::google::protobuf::int32 value) {
  
  field_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement.field)
}

// -------------------------------------------------------------------

// Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice

// int32 start = 1;
inline void Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice::clear_start() {
  start_ = 0;
}
inline ::google::protobuf::int32 Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice::start() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice.start)
  return start_;
}
inline void Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice::set_start(::google::protobuf::int32 value) {
  
  start_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice.start)
}

// int32 end = 2;
inline void Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice::clear_end() {
  end_ = 0;
}
inline ::google::protobuf::int32 Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice::end() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice.end)
  return end_;
}
inline void Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice::set_end(::google::protobuf::int32 value) {
  
  end_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice.end)
}

// -------------------------------------------------------------------

// Expression_MaskExpression_ListSelect_ListSelectItem

// .substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement item = 1;
inline bool Expression_MaskExpression_ListSelect_ListSelectItem::has_item() const {
  return type_case() == kItem;
}
inline void Expression_MaskExpression_ListSelect_ListSelectItem::set_has_item() {
  _oneof_case_[0] = kItem;
}
inline void Expression_MaskExpression_ListSelect_ListSelectItem::clear_item() {
  if (has_item()) {
    delete type_.item_;
    clear_has_type();
  }
}
inline const ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& Expression_MaskExpression_ListSelect_ListSelectItem::_internal_item() const {
  return *type_.item_;
}
inline ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* Expression_MaskExpression_ListSelect_ListSelectItem::release_item() {
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.item)
  if (has_item()) {
    clear_has_type();
      ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* temp = type_.item_;
    type_.item_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement& Expression_MaskExpression_ListSelect_ListSelectItem::item() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.item)
  return has_item()
      ? *type_.item_
      : *reinterpret_cast< ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement*>(&::substrait::_Expression_MaskExpression_ListSelect_ListSelectItem_ListElement_default_instance_);
}
inline ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement* Expression_MaskExpression_ListSelect_ListSelectItem::mutable_item() {
  if (!has_item()) {
    clear_type();
    set_has_item();
    type_.item_ = CreateMaybeMessage< ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListElement >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.item)
  return type_.item_;
}

// .substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice slice = 2;
inline bool Expression_MaskExpression_ListSelect_ListSelectItem::has_slice() const {
  return type_case() == kSlice;
}
inline void Expression_MaskExpression_ListSelect_ListSelectItem::set_has_slice() {
  _oneof_case_[0] = kSlice;
}
inline void Expression_MaskExpression_ListSelect_ListSelectItem::clear_slice() {
  if (has_slice()) {
    delete type_.slice_;
    clear_has_type();
  }
}
inline const ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& Expression_MaskExpression_ListSelect_ListSelectItem::_internal_slice() const {
  return *type_.slice_;
}
inline ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* Expression_MaskExpression_ListSelect_ListSelectItem::release_slice() {
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.slice)
  if (has_slice()) {
    clear_has_type();
      ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* temp = type_.slice_;
    type_.slice_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice& Expression_MaskExpression_ListSelect_ListSelectItem::slice() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.slice)
  return has_slice()
      ? *type_.slice_
      : *reinterpret_cast< ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice*>(&::substrait::_Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice_default_instance_);
}
inline ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice* Expression_MaskExpression_ListSelect_ListSelectItem::mutable_slice() {
  if (!has_slice()) {
    clear_type();
    set_has_slice();
    type_.slice_ = CreateMaybeMessage< ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.ListSelect.ListSelectItem.slice)
  return type_.slice_;
}

inline bool Expression_MaskExpression_ListSelect_ListSelectItem::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Expression_MaskExpression_ListSelect_ListSelectItem::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Expression_MaskExpression_ListSelect_ListSelectItem::TypeCase Expression_MaskExpression_ListSelect_ListSelectItem::type_case() const {
  return Expression_MaskExpression_ListSelect_ListSelectItem::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Expression_MaskExpression_ListSelect

// repeated .substrait.Expression.MaskExpression.ListSelect.ListSelectItem selection = 1;
inline int Expression_MaskExpression_ListSelect::selection_size() const {
  return selection_.size();
}
inline void Expression_MaskExpression_ListSelect::clear_selection() {
  selection_.Clear();
}
inline ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem* Expression_MaskExpression_ListSelect::mutable_selection(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.ListSelect.selection)
  return selection_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem >*
Expression_MaskExpression_ListSelect::mutable_selection() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.MaskExpression.ListSelect.selection)
  return &selection_;
}
inline const ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem& Expression_MaskExpression_ListSelect::selection(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.ListSelect.selection)
  return selection_.Get(index);
}
inline ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem* Expression_MaskExpression_ListSelect::add_selection() {
  // @@protoc_insertion_point(field_add:substrait.Expression.MaskExpression.ListSelect.selection)
  return selection_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::Expression_MaskExpression_ListSelect_ListSelectItem >&
Expression_MaskExpression_ListSelect::selection() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.MaskExpression.ListSelect.selection)
  return selection_;
}

// .substrait.Expression.MaskExpression.Select child = 2;
inline bool Expression_MaskExpression_ListSelect::has_child() const {
  return this != internal_default_instance() && child_ != NULL;
}
inline void Expression_MaskExpression_ListSelect::clear_child() {
  if (GetArenaNoVirtual() == NULL && child_ != NULL) {
    delete child_;
  }
  child_ = NULL;
}
inline const ::substrait::Expression_MaskExpression_Select& Expression_MaskExpression_ListSelect::_internal_child() const {
  return *child_;
}
inline const ::substrait::Expression_MaskExpression_Select& Expression_MaskExpression_ListSelect::child() const {
  const ::substrait::Expression_MaskExpression_Select* p = child_;
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.ListSelect.child)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression_MaskExpression_Select*>(
      &::substrait::_Expression_MaskExpression_Select_default_instance_);
}
inline ::substrait::Expression_MaskExpression_Select* Expression_MaskExpression_ListSelect::release_child() {
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.ListSelect.child)
  
  ::substrait::Expression_MaskExpression_Select* temp = child_;
  child_ = NULL;
  return temp;
}
inline ::substrait::Expression_MaskExpression_Select* Expression_MaskExpression_ListSelect::mutable_child() {
  
  if (child_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression_MaskExpression_Select>(GetArenaNoVirtual());
    child_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.ListSelect.child)
  return child_;
}
inline void Expression_MaskExpression_ListSelect::set_allocated_child(::substrait::Expression_MaskExpression_Select* child) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete child_;
  }
  if (child) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      child = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.MaskExpression.ListSelect.child)
}

// -------------------------------------------------------------------

// Expression_MaskExpression_MapSelect_MapKey

// string map_key = 1;
inline void Expression_MaskExpression_MapSelect_MapKey::clear_map_key() {
  map_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Expression_MaskExpression_MapSelect_MapKey::map_key() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.MapSelect.MapKey.map_key)
  return map_key_.GetNoArena();
}
inline void Expression_MaskExpression_MapSelect_MapKey::set_map_key(const ::std::string& value) {
  
  map_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:substrait.Expression.MaskExpression.MapSelect.MapKey.map_key)
}
#if LANG_CXX11
inline void Expression_MaskExpression_MapSelect_MapKey::set_map_key(::std::string&& value) {
  
  map_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:substrait.Expression.MaskExpression.MapSelect.MapKey.map_key)
}
#endif
inline void Expression_MaskExpression_MapSelect_MapKey::set_map_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  map_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:substrait.Expression.MaskExpression.MapSelect.MapKey.map_key)
}
inline void Expression_MaskExpression_MapSelect_MapKey::set_map_key(const char* value, size_t size) {
  
  map_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:substrait.Expression.MaskExpression.MapSelect.MapKey.map_key)
}
inline ::std::string* Expression_MaskExpression_MapSelect_MapKey::mutable_map_key() {
  
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.MapSelect.MapKey.map_key)
  return map_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Expression_MaskExpression_MapSelect_MapKey::release_map_key() {
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.MapSelect.MapKey.map_key)
  
  return map_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Expression_MaskExpression_MapSelect_MapKey::set_allocated_map_key(::std::string* map_key) {
  if (map_key != NULL) {
    
  } else {
    
  }
  map_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_key);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.MaskExpression.MapSelect.MapKey.map_key)
}

// -------------------------------------------------------------------

// Expression_MaskExpression_MapSelect_MapKeyExpression

// string map_key_expression = 1;
inline void Expression_MaskExpression_MapSelect_MapKeyExpression::clear_map_key_expression() {
  map_key_expression_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Expression_MaskExpression_MapSelect_MapKeyExpression::map_key_expression() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.MapSelect.MapKeyExpression.map_key_expression)
  return map_key_expression_.GetNoArena();
}
inline void Expression_MaskExpression_MapSelect_MapKeyExpression::set_map_key_expression(const ::std::string& value) {
  
  map_key_expression_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:substrait.Expression.MaskExpression.MapSelect.MapKeyExpression.map_key_expression)
}
#if LANG_CXX11
inline void Expression_MaskExpression_MapSelect_MapKeyExpression::set_map_key_expression(::std::string&& value) {
  
  map_key_expression_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:substrait.Expression.MaskExpression.MapSelect.MapKeyExpression.map_key_expression)
}
#endif
inline void Expression_MaskExpression_MapSelect_MapKeyExpression::set_map_key_expression(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  map_key_expression_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:substrait.Expression.MaskExpression.MapSelect.MapKeyExpression.map_key_expression)
}
inline void Expression_MaskExpression_MapSelect_MapKeyExpression::set_map_key_expression(const char* value, size_t size) {
  
  map_key_expression_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:substrait.Expression.MaskExpression.MapSelect.MapKeyExpression.map_key_expression)
}
inline ::std::string* Expression_MaskExpression_MapSelect_MapKeyExpression::mutable_map_key_expression() {
  
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.MapSelect.MapKeyExpression.map_key_expression)
  return map_key_expression_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Expression_MaskExpression_MapSelect_MapKeyExpression::release_map_key_expression() {
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.MapSelect.MapKeyExpression.map_key_expression)
  
  return map_key_expression_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Expression_MaskExpression_MapSelect_MapKeyExpression::set_allocated_map_key_expression(::std::string* map_key_expression) {
  if (map_key_expression != NULL) {
    
  } else {
    
  }
  map_key_expression_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), map_key_expression);
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.MaskExpression.MapSelect.MapKeyExpression.map_key_expression)
}

// -------------------------------------------------------------------

// Expression_MaskExpression_MapSelect

// .substrait.Expression.MaskExpression.MapSelect.MapKey key = 1;
inline bool Expression_MaskExpression_MapSelect::has_key() const {
  return select_case() == kKey;
}
inline void Expression_MaskExpression_MapSelect::set_has_key() {
  _oneof_case_[0] = kKey;
}
inline void Expression_MaskExpression_MapSelect::clear_key() {
  if (has_key()) {
    delete select_.key_;
    clear_has_select();
  }
}
inline const ::substrait::Expression_MaskExpression_MapSelect_MapKey& Expression_MaskExpression_MapSelect::_internal_key() const {
  return *select_.key_;
}
inline ::substrait::Expression_MaskExpression_MapSelect_MapKey* Expression_MaskExpression_MapSelect::release_key() {
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.MapSelect.key)
  if (has_key()) {
    clear_has_select();
      ::substrait::Expression_MaskExpression_MapSelect_MapKey* temp = select_.key_;
    select_.key_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_MaskExpression_MapSelect_MapKey& Expression_MaskExpression_MapSelect::key() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.MapSelect.key)
  return has_key()
      ? *select_.key_
      : *reinterpret_cast< ::substrait::Expression_MaskExpression_MapSelect_MapKey*>(&::substrait::_Expression_MaskExpression_MapSelect_MapKey_default_instance_);
}
inline ::substrait::Expression_MaskExpression_MapSelect_MapKey* Expression_MaskExpression_MapSelect::mutable_key() {
  if (!has_key()) {
    clear_select();
    set_has_key();
    select_.key_ = CreateMaybeMessage< ::substrait::Expression_MaskExpression_MapSelect_MapKey >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.MapSelect.key)
  return select_.key_;
}

// .substrait.Expression.MaskExpression.MapSelect.MapKeyExpression expression = 2;
inline bool Expression_MaskExpression_MapSelect::has_expression() const {
  return select_case() == kExpression;
}
inline void Expression_MaskExpression_MapSelect::set_has_expression() {
  _oneof_case_[0] = kExpression;
}
inline void Expression_MaskExpression_MapSelect::clear_expression() {
  if (has_expression()) {
    delete select_.expression_;
    clear_has_select();
  }
}
inline const ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression& Expression_MaskExpression_MapSelect::_internal_expression() const {
  return *select_.expression_;
}
inline ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* Expression_MaskExpression_MapSelect::release_expression() {
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.MapSelect.expression)
  if (has_expression()) {
    clear_has_select();
      ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* temp = select_.expression_;
    select_.expression_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression& Expression_MaskExpression_MapSelect::expression() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.MapSelect.expression)
  return has_expression()
      ? *select_.expression_
      : *reinterpret_cast< ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression*>(&::substrait::_Expression_MaskExpression_MapSelect_MapKeyExpression_default_instance_);
}
inline ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression* Expression_MaskExpression_MapSelect::mutable_expression() {
  if (!has_expression()) {
    clear_select();
    set_has_expression();
    select_.expression_ = CreateMaybeMessage< ::substrait::Expression_MaskExpression_MapSelect_MapKeyExpression >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.MapSelect.expression)
  return select_.expression_;
}

// .substrait.Expression.MaskExpression.Select child = 3;
inline bool Expression_MaskExpression_MapSelect::has_child() const {
  return this != internal_default_instance() && child_ != NULL;
}
inline void Expression_MaskExpression_MapSelect::clear_child() {
  if (GetArenaNoVirtual() == NULL && child_ != NULL) {
    delete child_;
  }
  child_ = NULL;
}
inline const ::substrait::Expression_MaskExpression_Select& Expression_MaskExpression_MapSelect::_internal_child() const {
  return *child_;
}
inline const ::substrait::Expression_MaskExpression_Select& Expression_MaskExpression_MapSelect::child() const {
  const ::substrait::Expression_MaskExpression_Select* p = child_;
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.MapSelect.child)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression_MaskExpression_Select*>(
      &::substrait::_Expression_MaskExpression_Select_default_instance_);
}
inline ::substrait::Expression_MaskExpression_Select* Expression_MaskExpression_MapSelect::release_child() {
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.MapSelect.child)
  
  ::substrait::Expression_MaskExpression_Select* temp = child_;
  child_ = NULL;
  return temp;
}
inline ::substrait::Expression_MaskExpression_Select* Expression_MaskExpression_MapSelect::mutable_child() {
  
  if (child_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression_MaskExpression_Select>(GetArenaNoVirtual());
    child_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.MapSelect.child)
  return child_;
}
inline void Expression_MaskExpression_MapSelect::set_allocated_child(::substrait::Expression_MaskExpression_Select* child) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete child_;
  }
  if (child) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      child = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    
  } else {
    
  }
  child_ = child;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.MaskExpression.MapSelect.child)
}

inline bool Expression_MaskExpression_MapSelect::has_select() const {
  return select_case() != SELECT_NOT_SET;
}
inline void Expression_MaskExpression_MapSelect::clear_has_select() {
  _oneof_case_[0] = SELECT_NOT_SET;
}
inline Expression_MaskExpression_MapSelect::SelectCase Expression_MaskExpression_MapSelect::select_case() const {
  return Expression_MaskExpression_MapSelect::SelectCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Expression_MaskExpression

// .substrait.Expression.MaskExpression.StructSelect select = 1;
inline bool Expression_MaskExpression::has_select() const {
  return this != internal_default_instance() && select_ != NULL;
}
inline void Expression_MaskExpression::clear_select() {
  if (GetArenaNoVirtual() == NULL && select_ != NULL) {
    delete select_;
  }
  select_ = NULL;
}
inline const ::substrait::Expression_MaskExpression_StructSelect& Expression_MaskExpression::_internal_select() const {
  return *select_;
}
inline const ::substrait::Expression_MaskExpression_StructSelect& Expression_MaskExpression::select() const {
  const ::substrait::Expression_MaskExpression_StructSelect* p = select_;
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.select)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression_MaskExpression_StructSelect*>(
      &::substrait::_Expression_MaskExpression_StructSelect_default_instance_);
}
inline ::substrait::Expression_MaskExpression_StructSelect* Expression_MaskExpression::release_select() {
  // @@protoc_insertion_point(field_release:substrait.Expression.MaskExpression.select)
  
  ::substrait::Expression_MaskExpression_StructSelect* temp = select_;
  select_ = NULL;
  return temp;
}
inline ::substrait::Expression_MaskExpression_StructSelect* Expression_MaskExpression::mutable_select() {
  
  if (select_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression_MaskExpression_StructSelect>(GetArenaNoVirtual());
    select_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.MaskExpression.select)
  return select_;
}
inline void Expression_MaskExpression::set_allocated_select(::substrait::Expression_MaskExpression_StructSelect* select) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete select_;
  }
  if (select) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      select = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, select, submessage_arena);
    }
    
  } else {
    
  }
  select_ = select;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.MaskExpression.select)
}

// bool maintain_singular_struct = 2;
inline void Expression_MaskExpression::clear_maintain_singular_struct() {
  maintain_singular_struct_ = false;
}
inline bool Expression_MaskExpression::maintain_singular_struct() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.MaskExpression.maintain_singular_struct)
  return maintain_singular_struct_;
}
inline void Expression_MaskExpression::set_maintain_singular_struct(bool value) {
  
  maintain_singular_struct_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.MaskExpression.maintain_singular_struct)
}

// -------------------------------------------------------------------

// Expression_FieldReference_RootReference

// -------------------------------------------------------------------

// Expression_FieldReference_OuterReference

// uint32 steps_out = 1;
inline void Expression_FieldReference_OuterReference::clear_steps_out() {
  steps_out_ = 0u;
}
inline ::google::protobuf::uint32 Expression_FieldReference_OuterReference::steps_out() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.FieldReference.OuterReference.steps_out)
  return steps_out_;
}
inline void Expression_FieldReference_OuterReference::set_steps_out(::google::protobuf::uint32 value) {
  
  steps_out_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.FieldReference.OuterReference.steps_out)
}

// -------------------------------------------------------------------

// Expression_FieldReference

// .substrait.Expression.ReferenceSegment direct_reference = 1;
inline bool Expression_FieldReference::has_direct_reference() const {
  return reference_type_case() == kDirectReference;
}
inline void Expression_FieldReference::set_has_direct_reference() {
  _oneof_case_[0] = kDirectReference;
}
inline void Expression_FieldReference::clear_direct_reference() {
  if (has_direct_reference()) {
    delete reference_type_.direct_reference_;
    clear_has_reference_type();
  }
}
inline const ::substrait::Expression_ReferenceSegment& Expression_FieldReference::_internal_direct_reference() const {
  return *reference_type_.direct_reference_;
}
inline ::substrait::Expression_ReferenceSegment* Expression_FieldReference::release_direct_reference() {
  // @@protoc_insertion_point(field_release:substrait.Expression.FieldReference.direct_reference)
  if (has_direct_reference()) {
    clear_has_reference_type();
      ::substrait::Expression_ReferenceSegment* temp = reference_type_.direct_reference_;
    reference_type_.direct_reference_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_ReferenceSegment& Expression_FieldReference::direct_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.FieldReference.direct_reference)
  return has_direct_reference()
      ? *reference_type_.direct_reference_
      : *reinterpret_cast< ::substrait::Expression_ReferenceSegment*>(&::substrait::_Expression_ReferenceSegment_default_instance_);
}
inline ::substrait::Expression_ReferenceSegment* Expression_FieldReference::mutable_direct_reference() {
  if (!has_direct_reference()) {
    clear_reference_type();
    set_has_direct_reference();
    reference_type_.direct_reference_ = CreateMaybeMessage< ::substrait::Expression_ReferenceSegment >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.FieldReference.direct_reference)
  return reference_type_.direct_reference_;
}

// .substrait.Expression.MaskExpression masked_reference = 2;
inline bool Expression_FieldReference::has_masked_reference() const {
  return reference_type_case() == kMaskedReference;
}
inline void Expression_FieldReference::set_has_masked_reference() {
  _oneof_case_[0] = kMaskedReference;
}
inline void Expression_FieldReference::clear_masked_reference() {
  if (has_masked_reference()) {
    delete reference_type_.masked_reference_;
    clear_has_reference_type();
  }
}
inline const ::substrait::Expression_MaskExpression& Expression_FieldReference::_internal_masked_reference() const {
  return *reference_type_.masked_reference_;
}
inline ::substrait::Expression_MaskExpression* Expression_FieldReference::release_masked_reference() {
  // @@protoc_insertion_point(field_release:substrait.Expression.FieldReference.masked_reference)
  if (has_masked_reference()) {
    clear_has_reference_type();
      ::substrait::Expression_MaskExpression* temp = reference_type_.masked_reference_;
    reference_type_.masked_reference_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_MaskExpression& Expression_FieldReference::masked_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.FieldReference.masked_reference)
  return has_masked_reference()
      ? *reference_type_.masked_reference_
      : *reinterpret_cast< ::substrait::Expression_MaskExpression*>(&::substrait::_Expression_MaskExpression_default_instance_);
}
inline ::substrait::Expression_MaskExpression* Expression_FieldReference::mutable_masked_reference() {
  if (!has_masked_reference()) {
    clear_reference_type();
    set_has_masked_reference();
    reference_type_.masked_reference_ = CreateMaybeMessage< ::substrait::Expression_MaskExpression >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.FieldReference.masked_reference)
  return reference_type_.masked_reference_;
}

// .substrait.Expression expression = 3;
inline bool Expression_FieldReference::has_expression() const {
  return root_type_case() == kExpression;
}
inline void Expression_FieldReference::set_has_expression() {
  _oneof_case_[1] = kExpression;
}
inline void Expression_FieldReference::clear_expression() {
  if (has_expression()) {
    delete root_type_.expression_;
    clear_has_root_type();
  }
}
inline const ::substrait::Expression& Expression_FieldReference::_internal_expression() const {
  return *root_type_.expression_;
}
inline ::substrait::Expression* Expression_FieldReference::release_expression() {
  // @@protoc_insertion_point(field_release:substrait.Expression.FieldReference.expression)
  if (has_expression()) {
    clear_has_root_type();
      ::substrait::Expression* temp = root_type_.expression_;
    root_type_.expression_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression& Expression_FieldReference::expression() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.FieldReference.expression)
  return has_expression()
      ? *root_type_.expression_
      : *reinterpret_cast< ::substrait::Expression*>(&::substrait::_Expression_default_instance_);
}
inline ::substrait::Expression* Expression_FieldReference::mutable_expression() {
  if (!has_expression()) {
    clear_root_type();
    set_has_expression();
    root_type_.expression_ = CreateMaybeMessage< ::substrait::Expression >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.FieldReference.expression)
  return root_type_.expression_;
}

// .substrait.Expression.FieldReference.RootReference root_reference = 4;
inline bool Expression_FieldReference::has_root_reference() const {
  return root_type_case() == kRootReference;
}
inline void Expression_FieldReference::set_has_root_reference() {
  _oneof_case_[1] = kRootReference;
}
inline void Expression_FieldReference::clear_root_reference() {
  if (has_root_reference()) {
    delete root_type_.root_reference_;
    clear_has_root_type();
  }
}
inline const ::substrait::Expression_FieldReference_RootReference& Expression_FieldReference::_internal_root_reference() const {
  return *root_type_.root_reference_;
}
inline ::substrait::Expression_FieldReference_RootReference* Expression_FieldReference::release_root_reference() {
  // @@protoc_insertion_point(field_release:substrait.Expression.FieldReference.root_reference)
  if (has_root_reference()) {
    clear_has_root_type();
      ::substrait::Expression_FieldReference_RootReference* temp = root_type_.root_reference_;
    root_type_.root_reference_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_FieldReference_RootReference& Expression_FieldReference::root_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.FieldReference.root_reference)
  return has_root_reference()
      ? *root_type_.root_reference_
      : *reinterpret_cast< ::substrait::Expression_FieldReference_RootReference*>(&::substrait::_Expression_FieldReference_RootReference_default_instance_);
}
inline ::substrait::Expression_FieldReference_RootReference* Expression_FieldReference::mutable_root_reference() {
  if (!has_root_reference()) {
    clear_root_type();
    set_has_root_reference();
    root_type_.root_reference_ = CreateMaybeMessage< ::substrait::Expression_FieldReference_RootReference >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.FieldReference.root_reference)
  return root_type_.root_reference_;
}

// .substrait.Expression.FieldReference.OuterReference outer_reference = 5;
inline bool Expression_FieldReference::has_outer_reference() const {
  return root_type_case() == kOuterReference;
}
inline void Expression_FieldReference::set_has_outer_reference() {
  _oneof_case_[1] = kOuterReference;
}
inline void Expression_FieldReference::clear_outer_reference() {
  if (has_outer_reference()) {
    delete root_type_.outer_reference_;
    clear_has_root_type();
  }
}
inline const ::substrait::Expression_FieldReference_OuterReference& Expression_FieldReference::_internal_outer_reference() const {
  return *root_type_.outer_reference_;
}
inline ::substrait::Expression_FieldReference_OuterReference* Expression_FieldReference::release_outer_reference() {
  // @@protoc_insertion_point(field_release:substrait.Expression.FieldReference.outer_reference)
  if (has_outer_reference()) {
    clear_has_root_type();
      ::substrait::Expression_FieldReference_OuterReference* temp = root_type_.outer_reference_;
    root_type_.outer_reference_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_FieldReference_OuterReference& Expression_FieldReference::outer_reference() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.FieldReference.outer_reference)
  return has_outer_reference()
      ? *root_type_.outer_reference_
      : *reinterpret_cast< ::substrait::Expression_FieldReference_OuterReference*>(&::substrait::_Expression_FieldReference_OuterReference_default_instance_);
}
inline ::substrait::Expression_FieldReference_OuterReference* Expression_FieldReference::mutable_outer_reference() {
  if (!has_outer_reference()) {
    clear_root_type();
    set_has_outer_reference();
    root_type_.outer_reference_ = CreateMaybeMessage< ::substrait::Expression_FieldReference_OuterReference >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.FieldReference.outer_reference)
  return root_type_.outer_reference_;
}

inline bool Expression_FieldReference::has_reference_type() const {
  return reference_type_case() != REFERENCE_TYPE_NOT_SET;
}
inline void Expression_FieldReference::clear_has_reference_type() {
  _oneof_case_[0] = REFERENCE_TYPE_NOT_SET;
}
inline bool Expression_FieldReference::has_root_type() const {
  return root_type_case() != ROOT_TYPE_NOT_SET;
}
inline void Expression_FieldReference::clear_has_root_type() {
  _oneof_case_[1] = ROOT_TYPE_NOT_SET;
}
inline Expression_FieldReference::ReferenceTypeCase Expression_FieldReference::reference_type_case() const {
  return Expression_FieldReference::ReferenceTypeCase(_oneof_case_[0]);
}
inline Expression_FieldReference::RootTypeCase Expression_FieldReference::root_type_case() const {
  return Expression_FieldReference::RootTypeCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// Expression_Subquery_Scalar

// .substrait.Rel input = 1;
inline bool Expression_Subquery_Scalar::has_input() const {
  return this != internal_default_instance() && input_ != NULL;
}
inline void Expression_Subquery_Scalar::clear_input() {
  if (GetArenaNoVirtual() == NULL && input_ != NULL) {
    delete input_;
  }
  input_ = NULL;
}
inline const ::substrait::Rel& Expression_Subquery_Scalar::_internal_input() const {
  return *input_;
}
inline const ::substrait::Rel& Expression_Subquery_Scalar::input() const {
  const ::substrait::Rel* p = input_;
  // @@protoc_insertion_point(field_get:substrait.Expression.Subquery.Scalar.input)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Rel*>(
      &::substrait::_Rel_default_instance_);
}
inline ::substrait::Rel* Expression_Subquery_Scalar::release_input() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Subquery.Scalar.input)
  
  ::substrait::Rel* temp = input_;
  input_ = NULL;
  return temp;
}
inline ::substrait::Rel* Expression_Subquery_Scalar::mutable_input() {
  
  if (input_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Rel>(GetArenaNoVirtual());
    input_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Subquery.Scalar.input)
  return input_;
}
inline void Expression_Subquery_Scalar::set_allocated_input(::substrait::Rel* input) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete input_;
  }
  if (input) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      input = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, input, submessage_arena);
    }
    
  } else {
    
  }
  input_ = input;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Subquery.Scalar.input)
}

// -------------------------------------------------------------------

// Expression_Subquery_InPredicate

// repeated .substrait.Expression needles = 1;
inline int Expression_Subquery_InPredicate::needles_size() const {
  return needles_.size();
}
inline void Expression_Subquery_InPredicate::clear_needles() {
  needles_.Clear();
}
inline ::substrait::Expression* Expression_Subquery_InPredicate::mutable_needles(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Subquery.InPredicate.needles)
  return needles_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::Expression >*
Expression_Subquery_InPredicate::mutable_needles() {
  // @@protoc_insertion_point(field_mutable_list:substrait.Expression.Subquery.InPredicate.needles)
  return &needles_;
}
inline const ::substrait::Expression& Expression_Subquery_InPredicate::needles(int index) const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Subquery.InPredicate.needles)
  return needles_.Get(index);
}
inline ::substrait::Expression* Expression_Subquery_InPredicate::add_needles() {
  // @@protoc_insertion_point(field_add:substrait.Expression.Subquery.InPredicate.needles)
  return needles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::Expression >&
Expression_Subquery_InPredicate::needles() const {
  // @@protoc_insertion_point(field_list:substrait.Expression.Subquery.InPredicate.needles)
  return needles_;
}

// .substrait.Rel haystack = 2;
inline bool Expression_Subquery_InPredicate::has_haystack() const {
  return this != internal_default_instance() && haystack_ != NULL;
}
inline void Expression_Subquery_InPredicate::clear_haystack() {
  if (GetArenaNoVirtual() == NULL && haystack_ != NULL) {
    delete haystack_;
  }
  haystack_ = NULL;
}
inline const ::substrait::Rel& Expression_Subquery_InPredicate::_internal_haystack() const {
  return *haystack_;
}
inline const ::substrait::Rel& Expression_Subquery_InPredicate::haystack() const {
  const ::substrait::Rel* p = haystack_;
  // @@protoc_insertion_point(field_get:substrait.Expression.Subquery.InPredicate.haystack)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Rel*>(
      &::substrait::_Rel_default_instance_);
}
inline ::substrait::Rel* Expression_Subquery_InPredicate::release_haystack() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Subquery.InPredicate.haystack)
  
  ::substrait::Rel* temp = haystack_;
  haystack_ = NULL;
  return temp;
}
inline ::substrait::Rel* Expression_Subquery_InPredicate::mutable_haystack() {
  
  if (haystack_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Rel>(GetArenaNoVirtual());
    haystack_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Subquery.InPredicate.haystack)
  return haystack_;
}
inline void Expression_Subquery_InPredicate::set_allocated_haystack(::substrait::Rel* haystack) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete haystack_;
  }
  if (haystack) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      haystack = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, haystack, submessage_arena);
    }
    
  } else {
    
  }
  haystack_ = haystack;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Subquery.InPredicate.haystack)
}

// -------------------------------------------------------------------

// Expression_Subquery_SetPredicate

// .substrait.Expression.Subquery.SetPredicate.PredicateOp predicate_op = 1;
inline void Expression_Subquery_SetPredicate::clear_predicate_op() {
  predicate_op_ = 0;
}
inline ::substrait::Expression_Subquery_SetPredicate_PredicateOp Expression_Subquery_SetPredicate::predicate_op() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Subquery.SetPredicate.predicate_op)
  return static_cast< ::substrait::Expression_Subquery_SetPredicate_PredicateOp >(predicate_op_);
}
inline void Expression_Subquery_SetPredicate::set_predicate_op(::substrait::Expression_Subquery_SetPredicate_PredicateOp value) {
  
  predicate_op_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Subquery.SetPredicate.predicate_op)
}

// .substrait.Rel tuples = 2;
inline bool Expression_Subquery_SetPredicate::has_tuples() const {
  return this != internal_default_instance() && tuples_ != NULL;
}
inline void Expression_Subquery_SetPredicate::clear_tuples() {
  if (GetArenaNoVirtual() == NULL && tuples_ != NULL) {
    delete tuples_;
  }
  tuples_ = NULL;
}
inline const ::substrait::Rel& Expression_Subquery_SetPredicate::_internal_tuples() const {
  return *tuples_;
}
inline const ::substrait::Rel& Expression_Subquery_SetPredicate::tuples() const {
  const ::substrait::Rel* p = tuples_;
  // @@protoc_insertion_point(field_get:substrait.Expression.Subquery.SetPredicate.tuples)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Rel*>(
      &::substrait::_Rel_default_instance_);
}
inline ::substrait::Rel* Expression_Subquery_SetPredicate::release_tuples() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Subquery.SetPredicate.tuples)
  
  ::substrait::Rel* temp = tuples_;
  tuples_ = NULL;
  return temp;
}
inline ::substrait::Rel* Expression_Subquery_SetPredicate::mutable_tuples() {
  
  if (tuples_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Rel>(GetArenaNoVirtual());
    tuples_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Subquery.SetPredicate.tuples)
  return tuples_;
}
inline void Expression_Subquery_SetPredicate::set_allocated_tuples(::substrait::Rel* tuples) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tuples_;
  }
  if (tuples) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tuples = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tuples, submessage_arena);
    }
    
  } else {
    
  }
  tuples_ = tuples;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Subquery.SetPredicate.tuples)
}

// -------------------------------------------------------------------

// Expression_Subquery_SetComparison

// .substrait.Expression.Subquery.SetComparison.ReductionOp reduction_op = 1;
inline void Expression_Subquery_SetComparison::clear_reduction_op() {
  reduction_op_ = 0;
}
inline ::substrait::Expression_Subquery_SetComparison_ReductionOp Expression_Subquery_SetComparison::reduction_op() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Subquery.SetComparison.reduction_op)
  return static_cast< ::substrait::Expression_Subquery_SetComparison_ReductionOp >(reduction_op_);
}
inline void Expression_Subquery_SetComparison::set_reduction_op(::substrait::Expression_Subquery_SetComparison_ReductionOp value) {
  
  reduction_op_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Subquery.SetComparison.reduction_op)
}

// .substrait.Expression.Subquery.SetComparison.ComparisonOp comparison_op = 2;
inline void Expression_Subquery_SetComparison::clear_comparison_op() {
  comparison_op_ = 0;
}
inline ::substrait::Expression_Subquery_SetComparison_ComparisonOp Expression_Subquery_SetComparison::comparison_op() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Subquery.SetComparison.comparison_op)
  return static_cast< ::substrait::Expression_Subquery_SetComparison_ComparisonOp >(comparison_op_);
}
inline void Expression_Subquery_SetComparison::set_comparison_op(::substrait::Expression_Subquery_SetComparison_ComparisonOp value) {
  
  comparison_op_ = value;
  // @@protoc_insertion_point(field_set:substrait.Expression.Subquery.SetComparison.comparison_op)
}

// .substrait.Expression left = 3;
inline bool Expression_Subquery_SetComparison::has_left() const {
  return this != internal_default_instance() && left_ != NULL;
}
inline void Expression_Subquery_SetComparison::clear_left() {
  if (GetArenaNoVirtual() == NULL && left_ != NULL) {
    delete left_;
  }
  left_ = NULL;
}
inline const ::substrait::Expression& Expression_Subquery_SetComparison::_internal_left() const {
  return *left_;
}
inline const ::substrait::Expression& Expression_Subquery_SetComparison::left() const {
  const ::substrait::Expression* p = left_;
  // @@protoc_insertion_point(field_get:substrait.Expression.Subquery.SetComparison.left)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression*>(
      &::substrait::_Expression_default_instance_);
}
inline ::substrait::Expression* Expression_Subquery_SetComparison::release_left() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Subquery.SetComparison.left)
  
  ::substrait::Expression* temp = left_;
  left_ = NULL;
  return temp;
}
inline ::substrait::Expression* Expression_Subquery_SetComparison::mutable_left() {
  
  if (left_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression>(GetArenaNoVirtual());
    left_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Subquery.SetComparison.left)
  return left_;
}
inline void Expression_Subquery_SetComparison::set_allocated_left(::substrait::Expression* left) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete left_;
  }
  if (left) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      left = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, left, submessage_arena);
    }
    
  } else {
    
  }
  left_ = left;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Subquery.SetComparison.left)
}

// .substrait.Rel right = 4;
inline bool Expression_Subquery_SetComparison::has_right() const {
  return this != internal_default_instance() && right_ != NULL;
}
inline void Expression_Subquery_SetComparison::clear_right() {
  if (GetArenaNoVirtual() == NULL && right_ != NULL) {
    delete right_;
  }
  right_ = NULL;
}
inline const ::substrait::Rel& Expression_Subquery_SetComparison::_internal_right() const {
  return *right_;
}
inline const ::substrait::Rel& Expression_Subquery_SetComparison::right() const {
  const ::substrait::Rel* p = right_;
  // @@protoc_insertion_point(field_get:substrait.Expression.Subquery.SetComparison.right)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Rel*>(
      &::substrait::_Rel_default_instance_);
}
inline ::substrait::Rel* Expression_Subquery_SetComparison::release_right() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Subquery.SetComparison.right)
  
  ::substrait::Rel* temp = right_;
  right_ = NULL;
  return temp;
}
inline ::substrait::Rel* Expression_Subquery_SetComparison::mutable_right() {
  
  if (right_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Rel>(GetArenaNoVirtual());
    right_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Subquery.SetComparison.right)
  return right_;
}
inline void Expression_Subquery_SetComparison::set_allocated_right(::substrait::Rel* right) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete right_;
  }
  if (right) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      right = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, right, submessage_arena);
    }
    
  } else {
    
  }
  right_ = right;
  // @@protoc_insertion_point(field_set_allocated:substrait.Expression.Subquery.SetComparison.right)
}

// -------------------------------------------------------------------

// Expression_Subquery

// .substrait.Expression.Subquery.Scalar scalar = 1;
inline bool Expression_Subquery::has_scalar() const {
  return subquery_type_case() == kScalar;
}
inline void Expression_Subquery::set_has_scalar() {
  _oneof_case_[0] = kScalar;
}
inline void Expression_Subquery::clear_scalar() {
  if (has_scalar()) {
    delete subquery_type_.scalar_;
    clear_has_subquery_type();
  }
}
inline const ::substrait::Expression_Subquery_Scalar& Expression_Subquery::_internal_scalar() const {
  return *subquery_type_.scalar_;
}
inline ::substrait::Expression_Subquery_Scalar* Expression_Subquery::release_scalar() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Subquery.scalar)
  if (has_scalar()) {
    clear_has_subquery_type();
      ::substrait::Expression_Subquery_Scalar* temp = subquery_type_.scalar_;
    subquery_type_.scalar_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_Subquery_Scalar& Expression_Subquery::scalar() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Subquery.scalar)
  return has_scalar()
      ? *subquery_type_.scalar_
      : *reinterpret_cast< ::substrait::Expression_Subquery_Scalar*>(&::substrait::_Expression_Subquery_Scalar_default_instance_);
}
inline ::substrait::Expression_Subquery_Scalar* Expression_Subquery::mutable_scalar() {
  if (!has_scalar()) {
    clear_subquery_type();
    set_has_scalar();
    subquery_type_.scalar_ = CreateMaybeMessage< ::substrait::Expression_Subquery_Scalar >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Subquery.scalar)
  return subquery_type_.scalar_;
}

// .substrait.Expression.Subquery.InPredicate in_predicate = 2;
inline bool Expression_Subquery::has_in_predicate() const {
  return subquery_type_case() == kInPredicate;
}
inline void Expression_Subquery::set_has_in_predicate() {
  _oneof_case_[0] = kInPredicate;
}
inline void Expression_Subquery::clear_in_predicate() {
  if (has_in_predicate()) {
    delete subquery_type_.in_predicate_;
    clear_has_subquery_type();
  }
}
inline const ::substrait::Expression_Subquery_InPredicate& Expression_Subquery::_internal_in_predicate() const {
  return *subquery_type_.in_predicate_;
}
inline ::substrait::Expression_Subquery_InPredicate* Expression_Subquery::release_in_predicate() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Subquery.in_predicate)
  if (has_in_predicate()) {
    clear_has_subquery_type();
      ::substrait::Expression_Subquery_InPredicate* temp = subquery_type_.in_predicate_;
    subquery_type_.in_predicate_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_Subquery_InPredicate& Expression_Subquery::in_predicate() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Subquery.in_predicate)
  return has_in_predicate()
      ? *subquery_type_.in_predicate_
      : *reinterpret_cast< ::substrait::Expression_Subquery_InPredicate*>(&::substrait::_Expression_Subquery_InPredicate_default_instance_);
}
inline ::substrait::Expression_Subquery_InPredicate* Expression_Subquery::mutable_in_predicate() {
  if (!has_in_predicate()) {
    clear_subquery_type();
    set_has_in_predicate();
    subquery_type_.in_predicate_ = CreateMaybeMessage< ::substrait::Expression_Subquery_InPredicate >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Subquery.in_predicate)
  return subquery_type_.in_predicate_;
}

// .substrait.Expression.Subquery.SetPredicate set_predicate = 3;
inline bool Expression_Subquery::has_set_predicate() const {
  return subquery_type_case() == kSetPredicate;
}
inline void Expression_Subquery::set_has_set_predicate() {
  _oneof_case_[0] = kSetPredicate;
}
inline void Expression_Subquery::clear_set_predicate() {
  if (has_set_predicate()) {
    delete subquery_type_.set_predicate_;
    clear_has_subquery_type();
  }
}
inline const ::substrait::Expression_Subquery_SetPredicate& Expression_Subquery::_internal_set_predicate() const {
  return *subquery_type_.set_predicate_;
}
inline ::substrait::Expression_Subquery_SetPredicate* Expression_Subquery::release_set_predicate() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Subquery.set_predicate)
  if (has_set_predicate()) {
    clear_has_subquery_type();
      ::substrait::Expression_Subquery_SetPredicate* temp = subquery_type_.set_predicate_;
    subquery_type_.set_predicate_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_Subquery_SetPredicate& Expression_Subquery::set_predicate() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Subquery.set_predicate)
  return has_set_predicate()
      ? *subquery_type_.set_predicate_
      : *reinterpret_cast< ::substrait::Expression_Subquery_SetPredicate*>(&::substrait::_Expression_Subquery_SetPredicate_default_instance_);
}
inline ::substrait::Expression_Subquery_SetPredicate* Expression_Subquery::mutable_set_predicate() {
  if (!has_set_predicate()) {
    clear_subquery_type();
    set_has_set_predicate();
    subquery_type_.set_predicate_ = CreateMaybeMessage< ::substrait::Expression_Subquery_SetPredicate >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Subquery.set_predicate)
  return subquery_type_.set_predicate_;
}

// .substrait.Expression.Subquery.SetComparison set_comparison = 4;
inline bool Expression_Subquery::has_set_comparison() const {
  return subquery_type_case() == kSetComparison;
}
inline void Expression_Subquery::set_has_set_comparison() {
  _oneof_case_[0] = kSetComparison;
}
inline void Expression_Subquery::clear_set_comparison() {
  if (has_set_comparison()) {
    delete subquery_type_.set_comparison_;
    clear_has_subquery_type();
  }
}
inline const ::substrait::Expression_Subquery_SetComparison& Expression_Subquery::_internal_set_comparison() const {
  return *subquery_type_.set_comparison_;
}
inline ::substrait::Expression_Subquery_SetComparison* Expression_Subquery::release_set_comparison() {
  // @@protoc_insertion_point(field_release:substrait.Expression.Subquery.set_comparison)
  if (has_set_comparison()) {
    clear_has_subquery_type();
      ::substrait::Expression_Subquery_SetComparison* temp = subquery_type_.set_comparison_;
    subquery_type_.set_comparison_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_Subquery_SetComparison& Expression_Subquery::set_comparison() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.Subquery.set_comparison)
  return has_set_comparison()
      ? *subquery_type_.set_comparison_
      : *reinterpret_cast< ::substrait::Expression_Subquery_SetComparison*>(&::substrait::_Expression_Subquery_SetComparison_default_instance_);
}
inline ::substrait::Expression_Subquery_SetComparison* Expression_Subquery::mutable_set_comparison() {
  if (!has_set_comparison()) {
    clear_subquery_type();
    set_has_set_comparison();
    subquery_type_.set_comparison_ = CreateMaybeMessage< ::substrait::Expression_Subquery_SetComparison >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.Subquery.set_comparison)
  return subquery_type_.set_comparison_;
}

inline bool Expression_Subquery::has_subquery_type() const {
  return subquery_type_case() != SUBQUERY_TYPE_NOT_SET;
}
inline void Expression_Subquery::clear_has_subquery_type() {
  _oneof_case_[0] = SUBQUERY_TYPE_NOT_SET;
}
inline Expression_Subquery::SubqueryTypeCase Expression_Subquery::subquery_type_case() const {
  return Expression_Subquery::SubqueryTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Expression

// .substrait.Expression.Literal literal = 1;
inline bool Expression::has_literal() const {
  return rex_type_case() == kLiteral;
}
inline void Expression::set_has_literal() {
  _oneof_case_[0] = kLiteral;
}
inline void Expression::clear_literal() {
  if (has_literal()) {
    delete rex_type_.literal_;
    clear_has_rex_type();
  }
}
inline const ::substrait::Expression_Literal& Expression::_internal_literal() const {
  return *rex_type_.literal_;
}
inline ::substrait::Expression_Literal* Expression::release_literal() {
  // @@protoc_insertion_point(field_release:substrait.Expression.literal)
  if (has_literal()) {
    clear_has_rex_type();
      ::substrait::Expression_Literal* temp = rex_type_.literal_;
    rex_type_.literal_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_Literal& Expression::literal() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.literal)
  return has_literal()
      ? *rex_type_.literal_
      : *reinterpret_cast< ::substrait::Expression_Literal*>(&::substrait::_Expression_Literal_default_instance_);
}
inline ::substrait::Expression_Literal* Expression::mutable_literal() {
  if (!has_literal()) {
    clear_rex_type();
    set_has_literal();
    rex_type_.literal_ = CreateMaybeMessage< ::substrait::Expression_Literal >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.literal)
  return rex_type_.literal_;
}

// .substrait.Expression.FieldReference selection = 2;
inline bool Expression::has_selection() const {
  return rex_type_case() == kSelection;
}
inline void Expression::set_has_selection() {
  _oneof_case_[0] = kSelection;
}
inline void Expression::clear_selection() {
  if (has_selection()) {
    delete rex_type_.selection_;
    clear_has_rex_type();
  }
}
inline const ::substrait::Expression_FieldReference& Expression::_internal_selection() const {
  return *rex_type_.selection_;
}
inline ::substrait::Expression_FieldReference* Expression::release_selection() {
  // @@protoc_insertion_point(field_release:substrait.Expression.selection)
  if (has_selection()) {
    clear_has_rex_type();
      ::substrait::Expression_FieldReference* temp = rex_type_.selection_;
    rex_type_.selection_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_FieldReference& Expression::selection() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.selection)
  return has_selection()
      ? *rex_type_.selection_
      : *reinterpret_cast< ::substrait::Expression_FieldReference*>(&::substrait::_Expression_FieldReference_default_instance_);
}
inline ::substrait::Expression_FieldReference* Expression::mutable_selection() {
  if (!has_selection()) {
    clear_rex_type();
    set_has_selection();
    rex_type_.selection_ = CreateMaybeMessage< ::substrait::Expression_FieldReference >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.selection)
  return rex_type_.selection_;
}

// .substrait.Expression.ScalarFunction scalar_function = 3;
inline bool Expression::has_scalar_function() const {
  return rex_type_case() == kScalarFunction;
}
inline void Expression::set_has_scalar_function() {
  _oneof_case_[0] = kScalarFunction;
}
inline void Expression::clear_scalar_function() {
  if (has_scalar_function()) {
    delete rex_type_.scalar_function_;
    clear_has_rex_type();
  }
}
inline const ::substrait::Expression_ScalarFunction& Expression::_internal_scalar_function() const {
  return *rex_type_.scalar_function_;
}
inline ::substrait::Expression_ScalarFunction* Expression::release_scalar_function() {
  // @@protoc_insertion_point(field_release:substrait.Expression.scalar_function)
  if (has_scalar_function()) {
    clear_has_rex_type();
      ::substrait::Expression_ScalarFunction* temp = rex_type_.scalar_function_;
    rex_type_.scalar_function_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_ScalarFunction& Expression::scalar_function() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.scalar_function)
  return has_scalar_function()
      ? *rex_type_.scalar_function_
      : *reinterpret_cast< ::substrait::Expression_ScalarFunction*>(&::substrait::_Expression_ScalarFunction_default_instance_);
}
inline ::substrait::Expression_ScalarFunction* Expression::mutable_scalar_function() {
  if (!has_scalar_function()) {
    clear_rex_type();
    set_has_scalar_function();
    rex_type_.scalar_function_ = CreateMaybeMessage< ::substrait::Expression_ScalarFunction >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.scalar_function)
  return rex_type_.scalar_function_;
}

// .substrait.Expression.WindowFunction window_function = 5;
inline bool Expression::has_window_function() const {
  return rex_type_case() == kWindowFunction;
}
inline void Expression::set_has_window_function() {
  _oneof_case_[0] = kWindowFunction;
}
inline void Expression::clear_window_function() {
  if (has_window_function()) {
    delete rex_type_.window_function_;
    clear_has_rex_type();
  }
}
inline const ::substrait::Expression_WindowFunction& Expression::_internal_window_function() const {
  return *rex_type_.window_function_;
}
inline ::substrait::Expression_WindowFunction* Expression::release_window_function() {
  // @@protoc_insertion_point(field_release:substrait.Expression.window_function)
  if (has_window_function()) {
    clear_has_rex_type();
      ::substrait::Expression_WindowFunction* temp = rex_type_.window_function_;
    rex_type_.window_function_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_WindowFunction& Expression::window_function() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.window_function)
  return has_window_function()
      ? *rex_type_.window_function_
      : *reinterpret_cast< ::substrait::Expression_WindowFunction*>(&::substrait::_Expression_WindowFunction_default_instance_);
}
inline ::substrait::Expression_WindowFunction* Expression::mutable_window_function() {
  if (!has_window_function()) {
    clear_rex_type();
    set_has_window_function();
    rex_type_.window_function_ = CreateMaybeMessage< ::substrait::Expression_WindowFunction >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.window_function)
  return rex_type_.window_function_;
}

// .substrait.Expression.IfThen if_then = 6;
inline bool Expression::has_if_then() const {
  return rex_type_case() == kIfThen;
}
inline void Expression::set_has_if_then() {
  _oneof_case_[0] = kIfThen;
}
inline void Expression::clear_if_then() {
  if (has_if_then()) {
    delete rex_type_.if_then_;
    clear_has_rex_type();
  }
}
inline const ::substrait::Expression_IfThen& Expression::_internal_if_then() const {
  return *rex_type_.if_then_;
}
inline ::substrait::Expression_IfThen* Expression::release_if_then() {
  // @@protoc_insertion_point(field_release:substrait.Expression.if_then)
  if (has_if_then()) {
    clear_has_rex_type();
      ::substrait::Expression_IfThen* temp = rex_type_.if_then_;
    rex_type_.if_then_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_IfThen& Expression::if_then() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.if_then)
  return has_if_then()
      ? *rex_type_.if_then_
      : *reinterpret_cast< ::substrait::Expression_IfThen*>(&::substrait::_Expression_IfThen_default_instance_);
}
inline ::substrait::Expression_IfThen* Expression::mutable_if_then() {
  if (!has_if_then()) {
    clear_rex_type();
    set_has_if_then();
    rex_type_.if_then_ = CreateMaybeMessage< ::substrait::Expression_IfThen >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.if_then)
  return rex_type_.if_then_;
}

// .substrait.Expression.SwitchExpression switch_expression = 7;
inline bool Expression::has_switch_expression() const {
  return rex_type_case() == kSwitchExpression;
}
inline void Expression::set_has_switch_expression() {
  _oneof_case_[0] = kSwitchExpression;
}
inline void Expression::clear_switch_expression() {
  if (has_switch_expression()) {
    delete rex_type_.switch_expression_;
    clear_has_rex_type();
  }
}
inline const ::substrait::Expression_SwitchExpression& Expression::_internal_switch_expression() const {
  return *rex_type_.switch_expression_;
}
inline ::substrait::Expression_SwitchExpression* Expression::release_switch_expression() {
  // @@protoc_insertion_point(field_release:substrait.Expression.switch_expression)
  if (has_switch_expression()) {
    clear_has_rex_type();
      ::substrait::Expression_SwitchExpression* temp = rex_type_.switch_expression_;
    rex_type_.switch_expression_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_SwitchExpression& Expression::switch_expression() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.switch_expression)
  return has_switch_expression()
      ? *rex_type_.switch_expression_
      : *reinterpret_cast< ::substrait::Expression_SwitchExpression*>(&::substrait::_Expression_SwitchExpression_default_instance_);
}
inline ::substrait::Expression_SwitchExpression* Expression::mutable_switch_expression() {
  if (!has_switch_expression()) {
    clear_rex_type();
    set_has_switch_expression();
    rex_type_.switch_expression_ = CreateMaybeMessage< ::substrait::Expression_SwitchExpression >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.switch_expression)
  return rex_type_.switch_expression_;
}

// .substrait.Expression.SingularOrList singular_or_list = 8;
inline bool Expression::has_singular_or_list() const {
  return rex_type_case() == kSingularOrList;
}
inline void Expression::set_has_singular_or_list() {
  _oneof_case_[0] = kSingularOrList;
}
inline void Expression::clear_singular_or_list() {
  if (has_singular_or_list()) {
    delete rex_type_.singular_or_list_;
    clear_has_rex_type();
  }
}
inline const ::substrait::Expression_SingularOrList& Expression::_internal_singular_or_list() const {
  return *rex_type_.singular_or_list_;
}
inline ::substrait::Expression_SingularOrList* Expression::release_singular_or_list() {
  // @@protoc_insertion_point(field_release:substrait.Expression.singular_or_list)
  if (has_singular_or_list()) {
    clear_has_rex_type();
      ::substrait::Expression_SingularOrList* temp = rex_type_.singular_or_list_;
    rex_type_.singular_or_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_SingularOrList& Expression::singular_or_list() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.singular_or_list)
  return has_singular_or_list()
      ? *rex_type_.singular_or_list_
      : *reinterpret_cast< ::substrait::Expression_SingularOrList*>(&::substrait::_Expression_SingularOrList_default_instance_);
}
inline ::substrait::Expression_SingularOrList* Expression::mutable_singular_or_list() {
  if (!has_singular_or_list()) {
    clear_rex_type();
    set_has_singular_or_list();
    rex_type_.singular_or_list_ = CreateMaybeMessage< ::substrait::Expression_SingularOrList >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.singular_or_list)
  return rex_type_.singular_or_list_;
}

// .substrait.Expression.MultiOrList multi_or_list = 9;
inline bool Expression::has_multi_or_list() const {
  return rex_type_case() == kMultiOrList;
}
inline void Expression::set_has_multi_or_list() {
  _oneof_case_[0] = kMultiOrList;
}
inline void Expression::clear_multi_or_list() {
  if (has_multi_or_list()) {
    delete rex_type_.multi_or_list_;
    clear_has_rex_type();
  }
}
inline const ::substrait::Expression_MultiOrList& Expression::_internal_multi_or_list() const {
  return *rex_type_.multi_or_list_;
}
inline ::substrait::Expression_MultiOrList* Expression::release_multi_or_list() {
  // @@protoc_insertion_point(field_release:substrait.Expression.multi_or_list)
  if (has_multi_or_list()) {
    clear_has_rex_type();
      ::substrait::Expression_MultiOrList* temp = rex_type_.multi_or_list_;
    rex_type_.multi_or_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_MultiOrList& Expression::multi_or_list() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.multi_or_list)
  return has_multi_or_list()
      ? *rex_type_.multi_or_list_
      : *reinterpret_cast< ::substrait::Expression_MultiOrList*>(&::substrait::_Expression_MultiOrList_default_instance_);
}
inline ::substrait::Expression_MultiOrList* Expression::mutable_multi_or_list() {
  if (!has_multi_or_list()) {
    clear_rex_type();
    set_has_multi_or_list();
    rex_type_.multi_or_list_ = CreateMaybeMessage< ::substrait::Expression_MultiOrList >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.multi_or_list)
  return rex_type_.multi_or_list_;
}

// .substrait.Expression.Cast cast = 11;
inline bool Expression::has_cast() const {
  return rex_type_case() == kCast;
}
inline void Expression::set_has_cast() {
  _oneof_case_[0] = kCast;
}
inline void Expression::clear_cast() {
  if (has_cast()) {
    delete rex_type_.cast_;
    clear_has_rex_type();
  }
}
inline const ::substrait::Expression_Cast& Expression::_internal_cast() const {
  return *rex_type_.cast_;
}
inline ::substrait::Expression_Cast* Expression::release_cast() {
  // @@protoc_insertion_point(field_release:substrait.Expression.cast)
  if (has_cast()) {
    clear_has_rex_type();
      ::substrait::Expression_Cast* temp = rex_type_.cast_;
    rex_type_.cast_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_Cast& Expression::cast() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.cast)
  return has_cast()
      ? *rex_type_.cast_
      : *reinterpret_cast< ::substrait::Expression_Cast*>(&::substrait::_Expression_Cast_default_instance_);
}
inline ::substrait::Expression_Cast* Expression::mutable_cast() {
  if (!has_cast()) {
    clear_rex_type();
    set_has_cast();
    rex_type_.cast_ = CreateMaybeMessage< ::substrait::Expression_Cast >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.cast)
  return rex_type_.cast_;
}

// .substrait.Expression.Subquery subquery = 12;
inline bool Expression::has_subquery() const {
  return rex_type_case() == kSubquery;
}
inline void Expression::set_has_subquery() {
  _oneof_case_[0] = kSubquery;
}
inline void Expression::clear_subquery() {
  if (has_subquery()) {
    delete rex_type_.subquery_;
    clear_has_rex_type();
  }
}
inline const ::substrait::Expression_Subquery& Expression::_internal_subquery() const {
  return *rex_type_.subquery_;
}
inline ::substrait::Expression_Subquery* Expression::release_subquery() {
  // @@protoc_insertion_point(field_release:substrait.Expression.subquery)
  if (has_subquery()) {
    clear_has_rex_type();
      ::substrait::Expression_Subquery* temp = rex_type_.subquery_;
    rex_type_.subquery_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_Subquery& Expression::subquery() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.subquery)
  return has_subquery()
      ? *rex_type_.subquery_
      : *reinterpret_cast< ::substrait::Expression_Subquery*>(&::substrait::_Expression_Subquery_default_instance_);
}
inline ::substrait::Expression_Subquery* Expression::mutable_subquery() {
  if (!has_subquery()) {
    clear_rex_type();
    set_has_subquery();
    rex_type_.subquery_ = CreateMaybeMessage< ::substrait::Expression_Subquery >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.subquery)
  return rex_type_.subquery_;
}

// .substrait.Expression.Nested nested = 13;
inline bool Expression::has_nested() const {
  return rex_type_case() == kNested;
}
inline void Expression::set_has_nested() {
  _oneof_case_[0] = kNested;
}
inline void Expression::clear_nested() {
  if (has_nested()) {
    delete rex_type_.nested_;
    clear_has_rex_type();
  }
}
inline const ::substrait::Expression_Nested& Expression::_internal_nested() const {
  return *rex_type_.nested_;
}
inline ::substrait::Expression_Nested* Expression::release_nested() {
  // @@protoc_insertion_point(field_release:substrait.Expression.nested)
  if (has_nested()) {
    clear_has_rex_type();
      ::substrait::Expression_Nested* temp = rex_type_.nested_;
    rex_type_.nested_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_Nested& Expression::nested() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.nested)
  return has_nested()
      ? *rex_type_.nested_
      : *reinterpret_cast< ::substrait::Expression_Nested*>(&::substrait::_Expression_Nested_default_instance_);
}
inline ::substrait::Expression_Nested* Expression::mutable_nested() {
  if (!has_nested()) {
    clear_rex_type();
    set_has_nested();
    rex_type_.nested_ = CreateMaybeMessage< ::substrait::Expression_Nested >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.nested)
  return rex_type_.nested_;
}

// .substrait.Expression.Enum enum = 10 [deprecated = true];
inline bool Expression::has_enum_() const {
  return rex_type_case() == kEnum;
}
inline void Expression::set_has_enum_() {
  _oneof_case_[0] = kEnum;
}
inline void Expression::clear_enum_() {
  if (has_enum_()) {
    delete rex_type_.enum__;
    clear_has_rex_type();
  }
}
inline const ::substrait::Expression_Enum& Expression::_internal_enum_() const {
  return *rex_type_.enum__;
}
inline ::substrait::Expression_Enum* Expression::release_enum_() {
  // @@protoc_insertion_point(field_release:substrait.Expression.enum)
  if (has_enum_()) {
    clear_has_rex_type();
      ::substrait::Expression_Enum* temp = rex_type_.enum__;
    rex_type_.enum__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::substrait::Expression_Enum& Expression::enum_() const {
  // @@protoc_insertion_point(field_get:substrait.Expression.enum)
  return has_enum_()
      ? *rex_type_.enum__
      : *reinterpret_cast< ::substrait::Expression_Enum*>(&::substrait::_Expression_Enum_default_instance_);
}
inline ::substrait::Expression_Enum* Expression::mutable_enum_() {
  if (!has_enum_()) {
    clear_rex_type();
    set_has_enum_();
    rex_type_.enum__ = CreateMaybeMessage< ::substrait::Expression_Enum >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:substrait.Expression.enum)
  return rex_type_.enum__;
}

inline bool Expression::has_rex_type() const {
  return rex_type_case() != REX_TYPE_NOT_SET;
}
inline void Expression::clear_has_rex_type() {
  _oneof_case_[0] = REX_TYPE_NOT_SET;
}
inline Expression::RexTypeCase Expression::rex_type_case() const {
  return Expression::RexTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SortField

// .substrait.Expression expr = 1;
inline bool SortField::has_expr() const {
  return this != internal_default_instance() && expr_ != NULL;
}
inline void SortField::clear_expr() {
  if (GetArenaNoVirtual() == NULL && expr_ != NULL) {
    delete expr_;
  }
  expr_ = NULL;
}
inline const ::substrait::Expression& SortField::_internal_expr() const {
  return *expr_;
}
inline const ::substrait::Expression& SortField::expr() const {
  const ::substrait::Expression* p = expr_;
  // @@protoc_insertion_point(field_get:substrait.SortField.expr)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Expression*>(
      &::substrait::_Expression_default_instance_);
}
inline ::substrait::Expression* SortField::release_expr() {
  // @@protoc_insertion_point(field_release:substrait.SortField.expr)
  
  ::substrait::Expression* temp = expr_;
  expr_ = NULL;
  return temp;
}
inline ::substrait::Expression* SortField::mutable_expr() {
  
  if (expr_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Expression>(GetArenaNoVirtual());
    expr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.SortField.expr)
  return expr_;
}
inline void SortField::set_allocated_expr(::substrait::Expression* expr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete expr_;
  }
  if (expr) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      expr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, expr, submessage_arena);
    }
    
  } else {
    
  }
  expr_ = expr;
  // @@protoc_insertion_point(field_set_allocated:substrait.SortField.expr)
}

// .substrait.SortField.SortDirection direction = 2;
inline bool SortField::has_direction() const {
  return sort_kind_case() == kDirection;
}
inline void SortField::set_has_direction() {
  _oneof_case_[0] = kDirection;
}
inline void SortField::clear_direction() {
  if (has_direction()) {
    sort_kind_.direction_ = 0;
    clear_has_sort_kind();
  }
}
inline ::substrait::SortField_SortDirection SortField::direction() const {
  // @@protoc_insertion_point(field_get:substrait.SortField.direction)
  if (has_direction()) {
    return static_cast< ::substrait::SortField_SortDirection >(sort_kind_.direction_);
  }
  return static_cast< ::substrait::SortField_SortDirection >(0);
}
inline void SortField::set_direction(::substrait::SortField_SortDirection value) {
  if (!has_direction()) {
    clear_sort_kind();
    set_has_direction();
  }
  sort_kind_.direction_ = value;
  // @@protoc_insertion_point(field_set:substrait.SortField.direction)
}

// uint32 comparison_function_reference = 3;
inline bool SortField::has_comparison_function_reference() const {
  return sort_kind_case() == kComparisonFunctionReference;
}
inline void SortField::set_has_comparison_function_reference() {
  _oneof_case_[0] = kComparisonFunctionReference;
}
inline void SortField::clear_comparison_function_reference() {
  if (has_comparison_function_reference()) {
    sort_kind_.comparison_function_reference_ = 0u;
    clear_has_sort_kind();
  }
}
inline ::google::protobuf::uint32 SortField::comparison_function_reference() const {
  // @@protoc_insertion_point(field_get:substrait.SortField.comparison_function_reference)
  if (has_comparison_function_reference()) {
    return sort_kind_.comparison_function_reference_;
  }
  return 0u;
}
inline void SortField::set_comparison_function_reference(::google::protobuf::uint32 value) {
  if (!has_comparison_function_reference()) {
    clear_sort_kind();
    set_has_comparison_function_reference();
  }
  sort_kind_.comparison_function_reference_ = value;
  // @@protoc_insertion_point(field_set:substrait.SortField.comparison_function_reference)
}

inline bool SortField::has_sort_kind() const {
  return sort_kind_case() != SORT_KIND_NOT_SET;
}
inline void SortField::clear_has_sort_kind() {
  _oneof_case_[0] = SORT_KIND_NOT_SET;
}
inline SortField::SortKindCase SortField::sort_kind_case() const {
  return SortField::SortKindCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AggregateFunction_ReferenceRel

// int32 subtree_ordinal = 1;
inline void AggregateFunction_ReferenceRel::clear_subtree_ordinal() {
  subtree_ordinal_ = 0;
}
inline ::google::protobuf::int32 AggregateFunction_ReferenceRel::subtree_ordinal() const {
  // @@protoc_insertion_point(field_get:substrait.AggregateFunction.ReferenceRel.subtree_ordinal)
  return subtree_ordinal_;
}
inline void AggregateFunction_ReferenceRel::set_subtree_ordinal(::google::protobuf::int32 value) {
  
  subtree_ordinal_ = value;
  // @@protoc_insertion_point(field_set:substrait.AggregateFunction.ReferenceRel.subtree_ordinal)
}

// -------------------------------------------------------------------

// AggregateFunction

// uint32 function_reference = 1;
inline void AggregateFunction::clear_function_reference() {
  function_reference_ = 0u;
}
inline ::google::protobuf::uint32 AggregateFunction::function_reference() const {
  // @@protoc_insertion_point(field_get:substrait.AggregateFunction.function_reference)
  return function_reference_;
}
inline void AggregateFunction::set_function_reference(::google::protobuf::uint32 value) {
  
  function_reference_ = value;
  // @@protoc_insertion_point(field_set:substrait.AggregateFunction.function_reference)
}

// repeated .substrait.FunctionArgument arguments = 7;
inline int AggregateFunction::arguments_size() const {
  return arguments_.size();
}
inline void AggregateFunction::clear_arguments() {
  arguments_.Clear();
}
inline ::substrait::FunctionArgument* AggregateFunction::mutable_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.AggregateFunction.arguments)
  return arguments_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::FunctionArgument >*
AggregateFunction::mutable_arguments() {
  // @@protoc_insertion_point(field_mutable_list:substrait.AggregateFunction.arguments)
  return &arguments_;
}
inline const ::substrait::FunctionArgument& AggregateFunction::arguments(int index) const {
  // @@protoc_insertion_point(field_get:substrait.AggregateFunction.arguments)
  return arguments_.Get(index);
}
inline ::substrait::FunctionArgument* AggregateFunction::add_arguments() {
  // @@protoc_insertion_point(field_add:substrait.AggregateFunction.arguments)
  return arguments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::FunctionArgument >&
AggregateFunction::arguments() const {
  // @@protoc_insertion_point(field_list:substrait.AggregateFunction.arguments)
  return arguments_;
}

// repeated .substrait.FunctionOption options = 8;
inline int AggregateFunction::options_size() const {
  return options_.size();
}
inline void AggregateFunction::clear_options() {
  options_.Clear();
}
inline ::substrait::FunctionOption* AggregateFunction::mutable_options(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.AggregateFunction.options)
  return options_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::FunctionOption >*
AggregateFunction::mutable_options() {
  // @@protoc_insertion_point(field_mutable_list:substrait.AggregateFunction.options)
  return &options_;
}
inline const ::substrait::FunctionOption& AggregateFunction::options(int index) const {
  // @@protoc_insertion_point(field_get:substrait.AggregateFunction.options)
  return options_.Get(index);
}
inline ::substrait::FunctionOption* AggregateFunction::add_options() {
  // @@protoc_insertion_point(field_add:substrait.AggregateFunction.options)
  return options_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::FunctionOption >&
AggregateFunction::options() const {
  // @@protoc_insertion_point(field_list:substrait.AggregateFunction.options)
  return options_;
}

// .substrait.Type output_type = 5;
inline bool AggregateFunction::has_output_type() const {
  return this != internal_default_instance() && output_type_ != NULL;
}
inline const ::substrait::Type& AggregateFunction::_internal_output_type() const {
  return *output_type_;
}
inline const ::substrait::Type& AggregateFunction::output_type() const {
  const ::substrait::Type* p = output_type_;
  // @@protoc_insertion_point(field_get:substrait.AggregateFunction.output_type)
  return p != NULL ? *p : *reinterpret_cast<const ::substrait::Type*>(
      &::substrait::_Type_default_instance_);
}
inline ::substrait::Type* AggregateFunction::release_output_type() {
  // @@protoc_insertion_point(field_release:substrait.AggregateFunction.output_type)
  
  ::substrait::Type* temp = output_type_;
  output_type_ = NULL;
  return temp;
}
inline ::substrait::Type* AggregateFunction::mutable_output_type() {
  
  if (output_type_ == NULL) {
    auto* p = CreateMaybeMessage<::substrait::Type>(GetArenaNoVirtual());
    output_type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:substrait.AggregateFunction.output_type)
  return output_type_;
}
inline void AggregateFunction::set_allocated_output_type(::substrait::Type* output_type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(output_type_);
  }
  if (output_type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      output_type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, output_type, submessage_arena);
    }
    
  } else {
    
  }
  output_type_ = output_type;
  // @@protoc_insertion_point(field_set_allocated:substrait.AggregateFunction.output_type)
}

// .substrait.AggregationPhase phase = 4;
inline void AggregateFunction::clear_phase() {
  phase_ = 0;
}
inline ::substrait::AggregationPhase AggregateFunction::phase() const {
  // @@protoc_insertion_point(field_get:substrait.AggregateFunction.phase)
  return static_cast< ::substrait::AggregationPhase >(phase_);
}
inline void AggregateFunction::set_phase(::substrait::AggregationPhase value) {
  
  phase_ = value;
  // @@protoc_insertion_point(field_set:substrait.AggregateFunction.phase)
}

// repeated .substrait.SortField sorts = 3;
inline int AggregateFunction::sorts_size() const {
  return sorts_.size();
}
inline void AggregateFunction::clear_sorts() {
  sorts_.Clear();
}
inline ::substrait::SortField* AggregateFunction::mutable_sorts(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.AggregateFunction.sorts)
  return sorts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::SortField >*
AggregateFunction::mutable_sorts() {
  // @@protoc_insertion_point(field_mutable_list:substrait.AggregateFunction.sorts)
  return &sorts_;
}
inline const ::substrait::SortField& AggregateFunction::sorts(int index) const {
  // @@protoc_insertion_point(field_get:substrait.AggregateFunction.sorts)
  return sorts_.Get(index);
}
inline ::substrait::SortField* AggregateFunction::add_sorts() {
  // @@protoc_insertion_point(field_add:substrait.AggregateFunction.sorts)
  return sorts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::SortField >&
AggregateFunction::sorts() const {
  // @@protoc_insertion_point(field_list:substrait.AggregateFunction.sorts)
  return sorts_;
}

// .substrait.AggregateFunction.AggregationInvocation invocation = 6;
inline void AggregateFunction::clear_invocation() {
  invocation_ = 0;
}
inline ::substrait::AggregateFunction_AggregationInvocation AggregateFunction::invocation() const {
  // @@protoc_insertion_point(field_get:substrait.AggregateFunction.invocation)
  return static_cast< ::substrait::AggregateFunction_AggregationInvocation >(invocation_);
}
inline void AggregateFunction::set_invocation(::substrait::AggregateFunction_AggregationInvocation value) {
  
  invocation_ = value;
  // @@protoc_insertion_point(field_set:substrait.AggregateFunction.invocation)
}

// repeated .substrait.Expression args = 2 [deprecated = true];
inline int AggregateFunction::args_size() const {
  return args_.size();
}
inline void AggregateFunction::clear_args() {
  args_.Clear();
}
inline ::substrait::Expression* AggregateFunction::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:substrait.AggregateFunction.args)
  return args_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::substrait::Expression >*
AggregateFunction::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:substrait.AggregateFunction.args)
  return &args_;
}
inline const ::substrait::Expression& AggregateFunction::args(int index) const {
  // @@protoc_insertion_point(field_get:substrait.AggregateFunction.args)
  return args_.Get(index);
}
inline ::substrait::Expression* AggregateFunction::add_args() {
  // @@protoc_insertion_point(field_add:substrait.AggregateFunction.args)
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::substrait::Expression >&
AggregateFunction::args() const {
  // @@protoc_insertion_point(field_list:substrait.AggregateFunction.args)
  return args_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace substrait

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::substrait::JoinRel_JoinType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::substrait::JoinRel_JoinType>() {
  return ::substrait::JoinRel_JoinType_descriptor();
}
template <> struct is_proto_enum< ::substrait::SetRel_SetOp> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::substrait::SetRel_SetOp>() {
  return ::substrait::SetRel_SetOp_descriptor();
}
template <> struct is_proto_enum< ::substrait::DdlRel_DdlObject> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::substrait::DdlRel_DdlObject>() {
  return ::substrait::DdlRel_DdlObject_descriptor();
}
template <> struct is_proto_enum< ::substrait::DdlRel_DdlOp> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::substrait::DdlRel_DdlOp>() {
  return ::substrait::DdlRel_DdlOp_descriptor();
}
template <> struct is_proto_enum< ::substrait::WriteRel_WriteOp> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::substrait::WriteRel_WriteOp>() {
  return ::substrait::WriteRel_WriteOp_descriptor();
}
template <> struct is_proto_enum< ::substrait::WriteRel_OutputMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::substrait::WriteRel_OutputMode>() {
  return ::substrait::WriteRel_OutputMode_descriptor();
}
template <> struct is_proto_enum< ::substrait::HashJoinRel_JoinType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::substrait::HashJoinRel_JoinType>() {
  return ::substrait::HashJoinRel_JoinType_descriptor();
}
template <> struct is_proto_enum< ::substrait::MergeJoinRel_JoinType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::substrait::MergeJoinRel_JoinType>() {
  return ::substrait::MergeJoinRel_JoinType_descriptor();
}
template <> struct is_proto_enum< ::substrait::Expression_Cast_FailureBehavior> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::substrait::Expression_Cast_FailureBehavior>() {
  return ::substrait::Expression_Cast_FailureBehavior_descriptor();
}
template <> struct is_proto_enum< ::substrait::Expression_Subquery_SetPredicate_PredicateOp> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::substrait::Expression_Subquery_SetPredicate_PredicateOp>() {
  return ::substrait::Expression_Subquery_SetPredicate_PredicateOp_descriptor();
}
template <> struct is_proto_enum< ::substrait::Expression_Subquery_SetComparison_ComparisonOp> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::substrait::Expression_Subquery_SetComparison_ComparisonOp>() {
  return ::substrait::Expression_Subquery_SetComparison_ComparisonOp_descriptor();
}
template <> struct is_proto_enum< ::substrait::Expression_Subquery_SetComparison_ReductionOp> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::substrait::Expression_Subquery_SetComparison_ReductionOp>() {
  return ::substrait::Expression_Subquery_SetComparison_ReductionOp_descriptor();
}
template <> struct is_proto_enum< ::substrait::SortField_SortDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::substrait::SortField_SortDirection>() {
  return ::substrait::SortField_SortDirection_descriptor();
}
template <> struct is_proto_enum< ::substrait::AggregateFunction_AggregationInvocation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::substrait::AggregateFunction_AggregationInvocation>() {
  return ::substrait::AggregateFunction_AggregationInvocation_descriptor();
}
template <> struct is_proto_enum< ::substrait::AggregationPhase> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::substrait::AggregationPhase>() {
  return ::substrait::AggregationPhase_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_substrait_2falgebra_2eproto
